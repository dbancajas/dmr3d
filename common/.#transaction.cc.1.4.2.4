/* Copyright (c) 2003 by Gurindar S. Sohi for the Wisconsin
 * Multiscalar Project.  ALL RIGHTS RESERVED.
 *
 * This software is furnished under the Multiscalar license.
 * For details see the LICENSE.mscalar file in the top-level source
 * directory, or online at http://www.cs.wisc.edu/mscalar/LICENSE
 *
 */

/* description:    a memory transaction
 * initial author: Philip Wells 
 *
 */
 
#include "simics/first.h"
RCSID("$Id: transaction.cc,v 1.4.2.4 2005/07/26 17:49:44 pwells Exp $");

#include "definitions.h"
#include "config_extern.h"
#include "transaction.h"



// default constructor
mem_trans_t::mem_trans_t()
{
	// Probably a waste of time.  Need to fix this class
	// Just don't want to use fields before they are initialized
	bzero(this, sizeof(*this));
	itlb_miss = false;
}

// Copy constructor
// Need to copy data, so can't use default copy const.
mem_trans_t::mem_trans_t(mem_trans_t &trans)
{
	phys_addr = trans.phys_addr;
	virt_addr = trans.virt_addr;
	size = trans.size;

	asi = trans.asi;
	ini_ptr = trans.ini_ptr;

	read = trans.read;
	write = trans.write;
	atomic = trans.atomic;
	hw_prefetch = trans.hw_prefetch;
	ifetch = trans.ifetch;
	control = trans.control;
	speculative = trans.speculative;
	supervisor = trans.supervisor;
	priv = trans.priv;

	call_complete_request = trans.call_complete_request;
	
	sw_prefetch = trans.sw_prefetch;
	prefetch_fcn = trans.prefetch_fcn;
	cache_phys = trans.cache_phys;
	cache_virt = trans.cache_virt;
	
	inverse_endian = trans.inverse_endian;
	page_cross = trans.page_cross;
	
	if (trans.data) {
		data = new uint8[size];
		memcpy(data, trans.data, size); 
	} else {
		data = NULL;
	}
	
	membar_mflag = trans.membar_mflag;
	membar_cflag = trans.membar_cflag;
	
	id = trans.id;
	cpu_id = trans.cpu_id;
	io_device = trans.io_device;
	may_stall = trans.may_stall;

	dinst = trans.dinst;

	completed = trans.completed;
	request_time = trans.request_time;

	events = trans.events;
	pending_events = trans.pending_events;
	itlb_miss = trans.itlb_miss;
    cache_prefetch = trans.cache_prefetch;
    random_trans = trans.random_trans;
}

mem_trans_t::~mem_trans_t()
{
	//if (g_conf_cache_date && data) delete [] data;
}


// Constructor passing simics v9_trans
mem_trans_t::mem_trans_t(v9_memory_transaction *trans)
{
	copy(trans);
}

bool
mem_trans_t::is_cacheable()
{
	if (!cache_phys) return false;
	
	return true;
}

bool
mem_trans_t::get_itlb_miss()
{
	return itlb_miss;
}

void 
mem_trans_t::set_itlb_miss(bool val)
{
	itlb_miss = val;
}

bool
mem_trans_t::is_normal_asi()
{
	if (
	(asi >= 0x04 && asi <= 0x11) ||
	(asi >= 0x18 && asi <= 0x19) ||
	(asi >= 0x24 && asi <= 0x2c) ||
	(asi >= 0x70 && asi <= 0x73) ||
	(asi >= 0x78 && asi <= 0x79) ||
	(asi >= 0x80 /*&& asi <= 0xff */)
	) return true;
	
	return false;
}

bool 
mem_trans_t::is_io_space() {
	return (phys_addr >= 0x100000000ULL);  // TODO: Fix. Up to 4 GB for now
}

// Copy relevant info from simics v9_trans
void mem_trans_t::copy(v9_memory_transaction *trans)
{
	generic_transaction_t *gtrans = &(trans->s);
	
	phys_addr = gtrans->physical_address;
	virt_addr = gtrans->logical_address;
	size = gtrans->size;
	
	asi = trans->address_space;
	ini_ptr = gtrans->ini_ptr;

	read = SIM_mem_op_is_read(gtrans) ? true : false;
	write = SIM_mem_op_is_write(gtrans) ? true : false;
	atomic = gtrans->atomic;
	hw_prefetch = false;  // TODO fix for HW prefetch
	ifetch = SIM_mem_op_is_instruction(gtrans);
	control = SIM_mem_op_is_control(gtrans);
	speculative = gtrans->speculative;
	supervisor = false;  // TODO fix   
	priv = trans->priv;

	call_complete_request = true;
	
	sw_prefetch = (gtrans->type == Sim_Trans_Prefetch);
	// FIXME: hack for simics bug
	//if (trans->prefetch_fcn != 0) sw_prefetch = true;
	
	prefetch_fcn = trans->prefetch_fcn;
	cache_phys = trans->cache_physical;
	cache_virt = trans->cache_virtual;
	
	inverse_endian = gtrans->inverse_endian;
	page_cross = gtrans->page_cross;
	data = NULL;
	
	membar_mflag = 0;
	membar_cflag = 0;
	
	id = gtrans->id;
	// To indicate proper CPU or some I/O device
	cpu_id = IS_CPU_MEM_OP(gtrans->ini_type) ? SIM_get_proc_no(ini_ptr)
	                                         : SIM_number_processors();
	io_device = (IS_DEV_MEM_OP(gtrans->ini_type));
	may_stall = gtrans->may_stall;

	ASSERT(cpu_id < SIM_number_processors() || io_device);
	
	dinst = NULL; // Must be set later
	

	// Set these in cache for now
	completed = false;
	request_time = 0;
	
	events = 0;
	pending_events = 0;
    cache_prefetch = false;
    random_trans = false;
}


void
mem_trans_t::debug()
{
    DEBUG_OUT("Phys Addr : 0x%llx cpu %u ifetch %u Read %u Write %u hw_prefetch %u random_trans %u call complete %u\n",
            phys_addr, (uint32) cpu_id, ifetch, read, write, hw_prefetch, random_trans, call_complete_request);
    DEBUG_FLUSH();        
}


void
mem_trans_t::mark_event(uint32 event) {
	events |= event;
	pending_events |= event;
}

void
mem_trans_t::mark_event_no_pend(uint32 event) {
	events |= event;
}

void
mem_trans_t::clear_pending_event(uint32 event) {
	pending_events &= ~event;
}

uint32
mem_trans_t::get_events()
{
	return events;
}

bool
mem_trans_t::occurred(uint32 event)
{
	return (events & event);
}

uint32
mem_trans_t::get_pending_events()
{
	return pending_events;
}

bool
mem_trans_t::is_pending(uint32 event)
{
	return (pending_events & event);
}

bool
mem_trans_t::is_prefetch()
{
	return (hw_prefetch || cache_prefetch || sw_prefetch);
}

