/* Copyright (c) 2003 by Gurindar S. Sohi for the Wisconsin
 * Multiscalar Project.  ALL RIGHTS RESERVED.
 *
 * This software is furnished under the Multiscalar license.
 * For details see the LICENSE.mscalar file in the top-level source
 * directory, or online at http://www.cs.wisc.edu/mscalar/LICENSE
 *
 */

#ifndef _SEQUENCER_H_
#define _SEQUENCER_H_

// prioritized fetch status
const uint32 FETCH_READY             = 0x00000000;

const uint32 FETCH_GPC_UNKNOWN       = 0x00000001;
const uint32 FETCH_LDQ_FULL          = 0x00000002;
const uint32 FETCH_STQ_FULL          = 0x00000004;
const uint32 FETCH_WINDOW_FULL       = 0x00000010;

const uint32 FETCH_STALL_UNTIL_EMPTY = 0x00000100;

const uint32 FETCH_PENDING_CHECKPOINT = 0x00001000;

class sequencer_t {
private:
	static uint64     seq_id; // static sequence ID of dynamic instructions
	
	uint32            id;  // id of this sequencer
	iwindow_t         *iwindow;
	lsq_t             *lsq;
	st_buffer_t       *st_buffer;

	chip_t            *p;
	fu_t              **fus;

	uint32            *fetch_status;
	ctrl_flow_t       **ctrl_flow;

	safe_uint64        *ivec;
	safe_uint64        *shadow_ivec;

	eventq_t          *eventq;

	wait_list_t       *dead_list;
	wait_list_t       *recycle_list;

	fastsim_t         *fastsim;
	fetch_buffer_t    *fetch_buffer;
	
	// Pointers to currently mapped mai object, etc.
	mai_t             **mai;
	
	// Waiting to start new thread 
	tick_t             wait_after_switch;
	
	// Want to take a checkpoint, but not at a place where we want to stop
	// sequencer (i.e. tl > 0)
    bool wait_on_checkpoint;
    
    uint32 num_hw_ctxt;  // Number of hw_ctxts mapped to this core/sequencer
    uint8  *thread_ids;
	
public:
	static dynamic_instr_t *icache_d_instr;
	static dynamic_instr_t *mmu_d_instr;

public:
	sequencer_t (chip_t *_p, uint32 id);
	~sequencer_t (void);

	eventq_t          *get_eventq (void);

	static uint64 generate_seq_id (void);

	chip_t* get_chip (void);
	iwindow_t* get_iwindow (void);
	lsq_t* get_lsq (void);
	st_buffer_t *get_st_buffer (void);
	mai_t *get_mai_object (void);
	ctrl_flow_t* get_ctrl_flow (void);

	void advance_cycle (void);

	void start (void);
	void finish (void);

	void insert_dead (dynamic_instr_t *d_instr);
	void cleanup_dead (void);
	
	fu_t* get_fu_resource (fu_type_t unit);

	void safety_checks (void);

	bool fu_ready (uint 8);

	bool get_fu_status (uint8 tid, uint32 s);
	uint32 get_fu_status (uint8 tid);
	void set_fu_status (uint8 tid, uint32 s);
	void reset_fu_status (uint8 tid, uint32 s);

	addr_t get_pc (uint8 tid);
	addr_t get_npc (uint8 tid);

	void set_interrupt (int64 _v);
	int64 get_interrupt (void);
	int64 get_shadow_interrupt (void);
	void set_shadow_interrupt (int64 _v);
	void handle_interrupt (void);

	void reset_interrupt (void);
	void reset_shadow_interrupt (void);

	mem_hier_handle_t *get_mem_hier (void);
	void front_end_status (void);

	void handle_simulation (void);

	void prepare_for_interrupt (void);
	void squash_inflight_instructions (void);
	void forward_progress_check (void);

	dynamic_instr_t *recycle (void);
	void insert_recycle (dynamic_instr_t *d_instr);
	void schedule (void);
	wait_list_t* adjust_wait_list (wait_list_t * &wl);

	void structure_stats (void);
    

	void prepare_fastsim (void);
	void finish_fastsim (void);

	fastsim_t *get_fastsim (void);

    void write_checkpoint(FILE *file);
    void read_checkpoint(FILE *file);
    bool st_buffer_empty();
	
	// Switch sequencer to a new Simics/OS CPU
	void switch_to_thread(mai_t *mai);
	
	proc_stats_t *get_pstats();
	uint32 get_id();
	
	fetch_buffer_t *get_fetch_buffer();
	void prepare_for_checkpoint();
	bool ready_for_checkpoint();
    
    void smt_commit ();
    bool process_instr_for_commit (dynamic_instr_t *);
	
private:
	proc_stats_t *stats;

};

#endif
