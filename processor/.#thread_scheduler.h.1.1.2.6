/* Copyright (c) 2005 by Gurindar S. Sohi for the Wisconsin
 * Multiscalar Project.  ALL RIGHTS RESERVED.
 *
 * This software is furnished under the Multiscalar license.
 * For details see the LICENSE.mscalar file in the top-level source
 * directory, or online at http://www.cs.wisc.edu/mscalar/LICENSE
 *
 */

/* $Id $
 *
 * description:    thread scheduler for mapping threads to sequencers
 * initial author: Philip Wells 
 *
 */
 
#ifndef _THREAD_SCHEDULER_H_
#define _THREAD_SCHEDULER_H_


class hw_context_t {
    public:
        sequencer_t *seq;
        uint32      ctxt;
        list<mai_t *> wait_list;
        bool busy;
        uint32 curr_sys_call;
        hw_context_t(sequencer_t *_s, uint32 _c, bool _b);
};



class thread_scheduler_t
{
public:
	thread_scheduler_t(chip_t *chip);

	// Sequencer indicates that it may need to switch
	//   if it should, manage the switch
	bool thread_yield(sequencer_t *seq, uint32 ctxt, mai_t *mai, ts_yield_reason_t why);
	void ready_for_switch(sequencer_t *seq, uint32 ctxt, mai_t *mai, ts_yield_reason_t why);
	
	bool is_user_ctxt(sequencer_t *_s, uint32 _c);
	bool is_os_ctxt(sequencer_t *_s, uint32 _c);
    hw_context_t *search_hw_context(sequencer_t *seq, uint32 _ct);
    
    void read_checkpoint(FILE *file);
    void write_checkpoint(FILE *file);
    
    
	
private:

	bool is_syscall_trap(uint64 tt);

	chip_t *chip;
	
	uint32 num_seq;
	uint32 num_threads;
    
    uint32 num_hw_ctxt;
    hw_context_t **hw_context;
    uint32 *preferred_user_ctxt;
    
    uint32 next_hw_context_assignment;

	// Number of user sequencers:
	//   0 <= seq_id < num_user               --> user seq
	//   num_user <= seq_id < chip->num_seq   --> os seq
	uint32 num_user;

	
	list<hw_context_t *> idle_os_ctxt;    // idle os sequencers
	list<hw_context_t *> idle_user_ctxt;  // idle user sequencers

	list<mai_t *> wait_for_os;   // threads waiting for an os core
	list<mai_t *> wait_for_user; // threads waiting for a user core
    
    // system call to h/w context mapping
    map <uint32, set<hw_context_t *> > syscall_context;
    
    hw_context_t *find_ctxt_for_thread(mai_t *mai, bool desire_user_seq, uint32 syscall);
    mai_t *find_thread_for_ctxt(hw_context_t *hwc, bool user_seq);
    void    provision_syscall();
    
    
    // different scheduling algos
    hw_context_t *eager_fifo_ctxt(mai_t *mai, bool desire_user_ctxt, uint32 sycall);
    mai_t *eager_fifo_thread(hw_context_t *hwc, bool user_ctxt);
    
    mai_t *maximize_cache_thread(hw_context_t *hwc, bool user_ctxt);
    hw_context_t *maximize_cache_ctxt(mai_t *mai, bool desire_user_ctxt, uint32 syscall);
    
    hw_context_t *get_syscall_context(uint32 syscall);
    hw_context_t *match_user_context(mai_t *mai);
    void assign_new_syscall_ctxt(uint32 syscall, uint32 req);
    
    void debug_idle_context(list<hw_context_t *> l);
};


#endif // _THREAD_SCHEDULER_H_
