/* Copyright (c) 2003 by Gurindar S. Sohi for the Wisconsin
 * Multiscalar Project.  ALL RIGHTS RESERVED.
 *
 * This software is furnished under the Multiscalar license.
 * For details see the LICENSE.mscalar file in the top-level source
 * directory, or online at http://www.cs.wisc.edu/mscalar/LICENSE
 *
 */

#include "simics/first.h"
RCSID("$Id: mai.cc,v 1.7.2.2 2005/10/31 15:16:59 pwells Exp $");

#include "definitions.h"
#include "mai.h"
#include "mai_instr.h"
#include "isa.h"
#include "fu.h"
#include "dynamic.h"
#include "window.h"
#include "iwindow.h"
#include "sequencer.h"
#include "chip.h"
#include "fu.h"
#include "eventq.h"
#include "ctrl_flow.h"
#include "ras.h"
#include "lsq.h"
#include "mem_xaction.h"
#include "st_buffer.h"
#include "config_extern.h"

#include "mem_hier_iface.h"
#include "transaction.h"
#include "proc_stats.h"
#include "counter.h"
#include "histogram.h"
#include "stats.h"

mai_t::mai_t (conf_object_t *_cpu, chip_t *_p) {
	cpu = _cpu;
	p = _p;
	shadow_cpu = 0;

	auto_probe_sim_parameters ();
}

mai_t::~mai_t () {
}

conf_object_t*
mai_t::get_cpu_obj () {
	return cpu;
}

void 
mai_t::auto_probe_sim_parameters () {

	simics_lsq_enable (cpu, g_conf_use_internal_lsq);
	if (!g_conf_memory_image_size);
		g_conf_memory_image_size = get_memory_image_size ();
}

uint64
mai_t::get_memory_image_size () {
	conf_object_t *obj = 0; 
	obj = SIM_get_object ("memory0");
	if (!obj) {
		SIM_clear_exception ();
		obj = SIM_get_object ("server_memory0");
	}
	
	if (!obj) FAIL;

	attr_value_t mem_obj_attr = SIM_get_attribute (obj, "image");
	ASSERT (mem_obj_attr.kind == Sim_Val_Object);

	conf_object_t *mem_obj = mem_obj_attr.u.object;

	attr_value_t mem_image_size_attr = SIM_get_attribute (mem_obj, "size");
	ASSERT (mem_image_size_attr.kind == Sim_Val_Integer);

	return mem_image_size_attr.u.integer;
}

void 
mai_t::simics_lsq_enable (conf_object_t *_cpu, bool b) {
	attr_value_t *lsq_enabled = new attr_value_t ();

	lsq_enabled->kind = Sim_Val_Integer;
	lsq_enabled->u.integer = static_cast <int32> (b);
	SIM_set_attribute (_cpu, "lsq-enabled", lsq_enabled);
}

void
mai_t::set_reorder_buffer_size (uint64 entries) {
	attr_value_t *rob_size = new attr_value_t ();

	rob_size->kind = Sim_Val_Integer;
	rob_size->u.integer = entries;
	
	set_error_t e = 
		SIM_set_attribute (cpu, "reorder-buffer-size", rob_size);


	ASSERT (e == Sim_Set_Ok);	

	delete rob_size;
}

bool
mai_t::is_supervisor () {
	
	uint32 level = SIM_cpu_privilege_level (cpu);
	
	FE_EXCEPTION_CHECK;
	if (level) return true; else return false;
}

void
mai_t::setup_trap_context () {
	//sequencer_t *seq = p->get_sequencer_from_thread(SIM_get_proc_no(cpu));
	//proc_stats_t *pstats = p->get_pstats (seq->get_id());

    proc_stats_t *pstats = p->get_pstats (SIM_get_proc_no(cpu));

	uint64 tl = get_tl ();
	ASSERT (tl > 0);

	if (tl == STAT_GET (pstats->stat_tl)) {
//		DEBUG_OUT ("skipping setup_trap_context ()\n");
		return;
	}

	STAT_INC (pstats->stat_tl);
//	ASSERT (STAT_GET (pstats->stat_tl) == tl);

	uint64 tt = get_tt (tl);
	STAT_SET (pstats->stat_tt [tl], tt);
}



void
mai_t::handle_interrupt (sequencer_t *seq) {

	ASSERT(seq == p->get_sequencer_from_thread(SIM_get_proc_no(cpu)));
    uint8 seq_thr_ctxt = p->get_seq_ctxt(SIM_get_proc_no(cpu));
    
	proc_stats_t *pstats = p->get_pstats (seq->get_id());
	instruction_error_t    ie;
	instruction_error_t    shadow_ie;
	st_buffer_t           *st_buffer = seq->get_st_buffer ();

	int64                  ivec = seq->get_interrupt (seq_thr_ctxt);

	// st buffer needs to be empty
	if (!st_buffer->empty ()) {
  		return;
	}

	switch ((ie = SIM_instruction_handle_interrupt (cpu, ivec))) {
	case Sim_IE_OK:
		STAT_INC (pstats->stat_interrupts);
		// after mai call
		setup_trap_context ();
		seq->reset_interrupt (seq_thr_ctxt);

		if (check_shadow ()) {

			int64 shadow_ivec = seq->get_shadow_interrupt (seq_thr_ctxt);
			ASSERT (shadow_ivec == ivec);

			shadow_ie = SIM_instruction_handle_interrupt (shadow_cpu, shadow_ivec);
			ASSERT (shadow_ie == Sim_IE_OK);

			seq->reset_shadow_interrupt (seq_thr_ctxt);

//			DEBUG_OUT ("handled interrupt %lld\n", ivec);
		}

		FE_EXCEPTION_CHECK;

		break;
	case Sim_IE_Illegal_Interrupt_Point:
		seq->prepare_for_interrupt (this);
		break;
	case Sim_IE_Interrupts_Disabled:
		break;

	default:
		FAIL;
	}
}


uint64
mai_t::get_tl () {
	int64 tl = SIM_get_register_number (cpu, "tl");
	return (static_cast <uint64> (SIM_read_register (cpu, tl)));
}

uint64
mai_t::get_tt (uint64 tl) {

	char tt_s [5];

	sprintf (tt_s, "tt%lld", tl);
	int64 tt = SIM_get_register_number (cpu, tt_s);
	return (static_cast <uint64> (SIM_read_register (cpu, tt)));
}

addr_t
mai_t::get_pc () {
	int64 pc = SIM_get_register_number (cpu, "pc");
	return (static_cast <addr_t> (SIM_read_register (cpu, pc)));
}

addr_t
mai_t::get_npc () {
	int64 npc = SIM_get_register_number (cpu, "npc");
	return (static_cast <addr_t> (SIM_read_register (cpu, npc)));
}

void mai_t::break_sim (tick_t when) {
	ASSERT (when >= 0);
	SIM_break_cycle (cpu, when);	
}

void
mai_t::piq () {
	int              i;
	instruction_id_t id;

	attr_value_t     ipc;
	attr_value_t     inpc;
	attr_value_t     opc;
	attr_value_t     onpc;

	i = 0; 
	while ((id = SIM_instruction_nth_id (cpu, i))) {

		dynamic_instr_t *d_instr = static_cast <dynamic_instr_t *> 
	          	(SIM_instruction_get_user_data (id));

		mai_instruction_t *mai_instr = d_instr->get_mai_instruction (); 
		
		instruction_id_t shadow_instr_id = 
			mai_instr->get_shadow_instr_id ();

do_again:	
		ipc = SIM_instruction_read_input_reg (id, V9_Reg_Id_PC);
		inpc= SIM_instruction_read_input_reg (id, V9_Reg_Id_NPC);
		opc = SIM_instruction_read_output_reg (id, V9_Reg_Id_PC);
		onpc= SIM_instruction_read_output_reg (id, V9_Reg_Id_NPC);

		DEBUG_OUT ("%d, i: %d, phase: %d sync: %d spec: %d, status: %d exception: %d\n", 
		i,  id,
		SIM_instruction_phase (id), 
		SIM_instruction_is_sync (id), 
		SIM_instruction_speculative (id), 
		SIM_instruction_status (id) & Sim_IS_Faulting, 
		SIM_instruction_status (id));

		DEBUG_OUT ("PC (0x%llx, 0x%llx) (0x%llx, 0x%llx)\n", 
		ipc.u.integer, inpc.u.integer, opc.u.integer, onpc.u.integer);

		FE_EXCEPTION_CHECK;

		if (id == mai_instr->get_instr_id ()) {
			mai_instr->debug (1);

			id = shadow_instr_id;

			DEBUG_OUT ("SHADOW---\n");
			if (id) {
				ASSERT (shadow_instr_id == SIM_instruction_nth_id (shadow_cpu, i));	

				FE_EXCEPTION_CHECK;
				goto do_again;
			} else 
				DEBUG_OUT ("none.\n");
		} else { 
			mai_instr->shadow_debug (1);
		}

		i++;	
	}
}

void 
mai_t::set_shadow_cpu_obj (conf_object_t *_cpu) {
	
	shadow_cpu = _cpu;
	copy_master_simics_attributes ();

	simics_lsq_enable (shadow_cpu, g_conf_use_internal_lsq);
}

void 
mai_t::copy_master_simics_attributes () {

	attr_value_t temp = SIM_get_attribute (cpu, "reorder-buffer-size");
	attr_value_t *rob_size = new attr_value_t ();

	rob_size->kind = Sim_Val_Integer;
	rob_size->u.integer = temp.u.integer;
	
	set_error_t e = SIM_set_attribute (shadow_cpu, "reorder-buffer-size", rob_size);
	ASSERT (e == Sim_Set_Ok);	

}

conf_object_t *
mai_t::get_shadow_cpu_obj (void) {
	return shadow_cpu;
}

bool 
mai_t::check_shadow (void) {
	if (shadow_cpu) return true; else return false;

}

int32
mai_t::get_id() {
	return SIM_get_proc_no(cpu);
}
