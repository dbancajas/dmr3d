/* Copyright (c) 2003 by Gurindar S. Sohi for the Wisconsin
 * Multiscalar Project.  ALL RIGHTS RESERVED.
 *
 * This software is furnished under the Multiscalar license.
 * For details see the LICENSE.mscalar file in the top-level source
 * directory, or online at http://www.cs.wisc.edu/mscalar/LICENSE
 *
 */

#include "simics/first.h"
RCSID("$Id: sequencer.cc,v 1.12.2.4 2005/08/30 18:34:04 kchak Exp $");

#include "definitions.h"
#include "window.h"
#include "iwindow.h"
#include "sequencer.h"
#include "fu.h"
#include "isa.h"
#include "proc_tm.h"
#include "eventq.h"
#include "dynamic.h"
#include "mai_instr.h"
#include "mai.h"
#include "ras.h"
#include "ctrl_flow.h"
#include "lsq.h"
#include "st_buffer.h"
#include "mem_xaction.h"
#include "v9_mem_xaction.h"
#include "transaction.h"
#include "wait_list.h"
#include "mem_hier_handle.h"
#include "proc_stats.h"
#include "counter.h"
#include "histogram.h"
#include "stats.h"
#include "config_extern.h"
#include "fastsim.h"

// static initializations
uint64 sequencer_t::seq_id = 0;
dynamic_instr_t *sequencer_t::icache_d_instr = 0;
dynamic_instr_t *sequencer_t::mmu_d_instr = 0;

sequencer_t::sequencer_t (proc_tm_t *_p) {
	p = _p;
	mai_t *mai = get_mai_object ();

	iwindow = new iwindow_t (g_conf_window_size);
	mai->set_reorder_buffer_size (g_conf_window_size);

	lsq = new lsq_t (p);
	st_buffer = new st_buffer_t (g_conf_stbuf_size, p);

	fus = new (fu_t *) [FU_TYPES];	
	for (fu_type_t unit = FU_NONE; unit < FU_TYPES; ++unit) {
		fus [unit] = new fu_t (unit, g_conf_fu_latencies [unit], 
			g_conf_fu_count [unit]);
	}

	fetch_status = 0x0;
	
	ctrl_flow = new ctrl_flow_t (this, mai->get_pc (), mai->get_npc ());

	eventq = new eventq_t (g_conf_eventq_size);
	dead_list = new wait_list_t (g_conf_dead_list_size);
	recycle_list = new wait_list_t (g_conf_recycle_list_size);
	
	fastsim = new fastsim_t (mai->get_cpu_obj ());

#if 0
	if (g_conf_use_fastsim) 
		prepare_fastsim ();
#endif

	ivec.initialize ();
	shadow_ivec.initialize ();
}

sequencer_t::~sequencer_t (void) {
	delete iwindow;

	delete [] fus;
	delete ctrl_flow;
	delete lsq;
	delete st_buffer;

	delete eventq;
	delete dead_list;
	delete recycle_list;

	delete fastsim;
}

uint64 
sequencer_t::generate_seq_id (void) {
	return seq_id++;
}

fu_t*
sequencer_t::get_fu_resource (fu_type_t unit) {
	if (unit == FU_TYPES) 
		return 0; 
	else 	
		return fus [unit];
}

proc_tm_t*
sequencer_t::get_proc_tm (void) {
	return p;
}

iwindow_t*
sequencer_t::get_iwindow (void) {
	return iwindow;
}

lsq_t*
sequencer_t::get_lsq (void) {
	return lsq;
}

st_buffer_t*
sequencer_t::get_st_buffer (void) {
	return st_buffer;
}

mai_t*
sequencer_t::get_mai_object (void) {
	return (p->get_mai_object ());
}

void 
sequencer_t::safety_checks (void) {
	if (SIM_get_pending_exception ()) FAIL;
}

void
sequencer_t::front_end_status () {
	memq_t *ldq = lsq->get_ldq ();
	memq_t *stq = lsq->get_stq ();

	// iwindow
	if (iwindow->empty ()) {
		reset_fu_status (FETCH_STALL_UNTIL_EMPTY); 
		reset_fu_status (FETCH_WINDOW_FULL);

		ASSERT (ldq->empty ());
		ASSERT (stq->empty ());
	
	} else if (iwindow->full ()) {
		set_fu_status (FETCH_WINDOW_FULL);
	} else {
		ASSERT (!iwindow->empty ());
		ASSERT (!iwindow->full ());

		reset_fu_status (FETCH_WINDOW_FULL);
	}

	// ldq
	if (!ldq->full ()) {
		reset_fu_status (FETCH_LDQ_FULL);
	}

	// stq
	if (!stq->full ())  {
		reset_fu_status (FETCH_STQ_FULL);
	}
}

void 
sequencer_t::advance_cycle (void) {
    proc_stats_t *pstats = p->get_pstats ();
	
	STAT_INC (pstats->stat_cycles);

	if (fastsim->fastsim_mode ()) {
		if (iwindow->empty ()) 
			if (fastsim->sim ())
				finish_fastsim ();

		return;	
	}

	handle_interrupt ();

	start ();
	finish ();

	eventq->advance_cycle ();

	schedule ();

	cleanup_dead ();

	front_end_status ();
	st_buffer->advance_cycle ();

	safety_checks ();

	pstats->iwindow_stats (iwindow);
	
	handle_simulation ();

	forward_progress_check ();
}

void
sequencer_t::forward_progress_check () {
	proc_stats_t *pstats = p->get_pstats ();

	uint64 check_cycle = STAT_GET (pstats->stat_check_cycle);

	if (check_cycle == p->get_g_cycles ()) {
		uint64 last_commits = STAT_GET (pstats->stat_last_commits);

		check_cycle += g_conf_check_freq;
		STAT_SET (pstats->stat_check_cycle, check_cycle);

		uint64 commits = STAT_GET (pstats->stat_commits);
		STAT_SET (pstats->stat_last_commits, commits);

		if (last_commits == commits) {
            p->get_mai_object()->piq();
			DEBUG_OUT ("No forward progress for CPU %d.at %llu \n", p->get_id(),p->get_g_cycles()); 
			FAIL;
		}
	}
}

void 
sequencer_t::handle_simulation () {
	proc_stats_t **pstats_list = p->get_pstats_list ();
	mai_t *mai = p->get_mai_object ();

	uint32 i = 0;
	uint64 total_commits = 0;
	uint64 total_cycles = 0;

	while (pstats_list [i] != 0) {
		total_commits += (uint64) pstats_list [i]->stat_commits->get_total ();
		total_cycles += (uint64) pstats_list [i]->stat_cycles->get_total ();

		i++;
	}


	if (g_conf_run_cycles && 
		p->get_g_cycles () == (uint64) g_conf_run_cycles) {

		structure_stats ();
		p->print_stats ();
        p->get_mem_hier()->print_stats();
		mai->break_sim (0);
	}

	if (g_conf_run_commits && 
		total_commits >= (uint64) g_conf_run_commits) {

		structure_stats ();
		p->print_stats ();
        p->get_mem_hier()->print_stats();
		mai->break_sim (0);
	}

	if ( g_conf_heart_beat && ((p->get_g_cycles () % g_conf_heart_beat_cycles) == 0) ) 
		DEBUG_OUT ("cpu%d committed %lld instructions in %lld cycles\n", 
			p->get_id (), total_commits, total_cycles);
}

void
sequencer_t::structure_stats () {
	proc_stats_t *pstats = p->get_pstats ();

	STAT_SET (pstats->stat_dead_list_size, dead_list->get_size ());
	STAT_SET (pstats->stat_recycle_list_size, recycle_list->get_size ());
}


void 
sequencer_t::prepare_fastsim () {
	squash_inflight_instructions ();	
	ASSERT (!fastsim->fastsim_mode ());

	fastsim->sim_icount (g_conf_fastsim_icount);

	if (ivec.is_valid ())
		fastsim->set_interrupt (get_interrupt ());
}

void 
sequencer_t::finish_fastsim () {
	ASSERT (!fastsim->fastsim_mode ());
	set_interrupt (fastsim->get_interrupt ());
}


void 
sequencer_t::prepare_for_interrupt () {
	mai_t *mai = p->get_mai_object ();

	if (ivec.is_valid () && 
		( !mai->check_shadow () || shadow_ivec.is_valid () )) 
	 {
		if (!get_fu_status (FETCH_STALL_UNTIL_EMPTY)) 
			set_fu_status (FETCH_STALL_UNTIL_EMPTY);
		
		st_buffer->panic_clear ();

		if (g_conf_handle_interrupt_early)
			squash_inflight_instructions ();
	}
}

void
sequencer_t::squash_inflight_instructions () {

	dynamic_instr_t *d_instr = iwindow->head ();
	if (!d_instr) return;

	if (d_instr->get_pipe_stage () <= PIPE_EXECUTE) {
		d_instr->kill_all ();
		return;
	}

	uint32 index = iwindow->get_last_created ();
	uint32  head = iwindow->get_last_committed ();

	do {
		d_instr      = iwindow->peek (index);
		index        = iwindow->window_decrement (index);

		if (d_instr->get_sync () && d_instr->get_pipe_stage () > PIPE_EXECUTE) break;

	} while (index != head);

	if (d_instr->get_next_d_instr ())
		d_instr->get_next_d_instr ()->kill_all ();
}


void
sequencer_t::start (void) {

	uint32 fetch_avail = g_conf_max_fetch;
	
	while (!p->pending_checkpoint && fu_ready () && fetch_avail > 0 && 
		iwindow->slot_avail ()) {

		dynamic_instr_t *d_instr = 0;
		
		if (g_conf_recycle_instr)
			d_instr = recycle ();

		if (!d_instr)
			d_instr = new dynamic_instr_t (this);

		d_instr->set_pipe_stage (PIPE_INSERT);
		d_instr->wakeup ();

		fetch_avail--;
	}

//	DEBUG_OUT ("fetched %lld instructions at cycle %lld\n", 
//		g_conf_max_fetch - fetch_avail, p->get_g_cycles ());
}

void 
sequencer_t::finish (void) {
	proc_stats_t *pstats = p->get_pstats ();
	uint32 commit_avail = g_conf_max_commit;

	while (commit_avail > 0 && !iwindow->empty ()) {
		dynamic_instr_t *d_instr = iwindow->head ();
		ASSERT (d_instr);

		if (d_instr->speculative ()) {
			d_instr->kill_all ();
		} else if (d_instr->get_pipe_stage () == PIPE_MEM_ACCESS) {
			if (d_instr->is_load ()) {
				d_instr->ld_mem_access ();
			} else if (d_instr->is_store ()) {
				if (d_instr->immediate_release_store () && !st_buffer->empty ())
					break;
				d_instr->st_mem_access ();
			} else FAIL;

//			commit_avail--;

		} else if (d_instr->get_pipe_stage () == PIPE_MEM_ACCESS_SAFE) {
			ASSERT (d_instr->is_load ());
			if (!st_buffer->empty ()) break;

			d_instr->safe_ld_mem_access (); 
//			commit_avail--;

		} else if (d_instr->retire_ready ()) {
			if (d_instr->is_store () && 
			    !d_instr->immediate_release_store () &&
			    st_buffer->full ()) 
				break;

			d_instr->retire ();

			STAT_INC (pstats->stat_commits);
			commit_avail--;

		} else if (g_conf_thread_per_core > 1) {
            // Running in SMT mode   
            
        }
			break;
	}
}

void
sequencer_t::insert_dead (dynamic_instr_t *d_instr) {

	wait_list_t *wl = dead_list->get_end_wait_list ();
	if (wl->full ()) wl = dead_list->create_wait_list ();

	wl->insert (d_instr);

//	ASSERT (!dead_list->full ());
}

void
sequencer_t::insert_recycle (dynamic_instr_t *d_instr) {

	wait_list_t *wl = recycle_list->get_end_wait_list ();
	if (wl->full ()) wl = recycle_list->create_wait_list ();

	wl->insert (d_instr);

//	ASSERT (!recycle_list->full ());
}

dynamic_instr_t*
sequencer_t::recycle () {
	dynamic_instr_t *d_instr = recycle_list->head ();

	if (d_instr) {
		recycle_list->pop_head (d_instr);
		adjust_wait_list (recycle_list);

		d_instr->recycle ();
	}

	return d_instr;
}

wait_list_t*
sequencer_t::adjust_wait_list (wait_list_t* & start_wl) {
	wait_list_t *next_wl = 0, *wl;

	if (!start_wl->empty ()) return start_wl;

	wait_list_t *end_wl = start_wl->get_end_wait_list ();

	for (wl = start_wl; 
		wl && wl->get_next_wl () && wl->empty (); 
		wl = next_wl) {

		next_wl = wl->get_next_wl ();

		ASSERT (wl->empty ());
		wl->set_end_wait_list (0);
		wl->set_next_wait_list (0);

		delete wl;
	}

//	ASSERT (!wl->empty ());
	wl->set_end_wait_list (end_wl);

	start_wl = wl;
	return start_wl;
}

void
sequencer_t::cleanup_dead (void) {
	wait_list_t *wl = dead_list;

	for (; wl; wl = wl->get_next_wl ()) {
		while (wl->head ()) {
			dynamic_instr_t *d_instr = wl->head ();
			if (d_instr->get_outstanding () == 0x0) {
				wl->pop_head (d_instr);

				if (g_conf_recycle_instr)
					insert_recycle (d_instr);
				else	
					delete d_instr;

			} else 
				break;
		}
	}

	adjust_wait_list (dead_list);
}

bool
sequencer_t::get_fu_status (uint32 s) {
	return ((fetch_status & s) == s);	
}

uint32
sequencer_t::get_fu_status (void) {
	return fetch_status;
}

void
sequencer_t::set_fu_status (uint32 s) {
	fetch_status = (fetch_status | s);
}

void
sequencer_t::reset_fu_status (uint32 s) {
	fetch_status = (fetch_status & (~s));
}

bool
sequencer_t::fu_ready () {
	return (fetch_status == 0x0);
}

addr_t
sequencer_t::get_pc () {
	return (ctrl_flow->get_pc ());
}

addr_t
sequencer_t::get_npc () {
	return (ctrl_flow->get_npc ());
}

ctrl_flow_t*
sequencer_t::get_ctrl_flow () {
	return ctrl_flow;
}

void
sequencer_t::handle_interrupt () {
	mai_t *mai = get_mai_object ();

	if (ivec.is_valid () && 
		( !mai->check_shadow () || shadow_ivec.is_valid () ) ) 
		mai->handle_interrupt (this);
}


bool
sequencer_t::st_buffer_empty()
{
    return st_buffer->empty();
}

void 
sequencer_t::set_shadow_interrupt (int64 _v) {
	shadow_ivec.set (_v);
}


void 
sequencer_t::set_interrupt (int64 _v) {

	// fastsim mode
	if (fastsim && fastsim->fastsim_mode ()) {
		fastsim->set_interrupt (_v);
		return;
	}

	ivec.set (_v);
}

int64
sequencer_t::get_interrupt () {
	return ivec.get ();
}

int64
sequencer_t::get_shadow_interrupt () {
	return shadow_ivec.get ();
}


mem_hier_handle_t*
sequencer_t::get_mem_hier () {
	return (p->get_mem_hier ());
}

eventq_t*
sequencer_t::get_eventq () {
	return eventq;
}

void 
sequencer_t::schedule () {
	uint32 execute_avail = g_conf_max_issue;
	dynamic_instr_t *d_instr;

	if (iwindow->empty ()) return;
	
	uint32 last_created = iwindow->get_last_created ();
	uint32 index = iwindow->get_last_committed ();

	index = iwindow->window_increment (index);
	d_instr = iwindow->peek (index);

	while (execute_avail > 0 && d_instr) {
		mai_instruction_t *mai_instr = d_instr->get_mai_instruction ();
		fu_t *fu = d_instr->get_fu ();
		bool b = true;

		if (d_instr->get_sync () && iwindow->head () != d_instr)
			b = false;

		if (b && d_instr->is_load () && g_conf_issue_load_commit && 
			iwindow->head () != d_instr) 
			b = false;

		if (b && d_instr->is_store () && g_conf_issue_store_commit && 
			iwindow->head () != d_instr)
			b = false;

		if (b && g_conf_issue_non_spec && d_instr->speculative ())
			b = false;

		if (b && d_instr->is_load () && g_conf_issue_loads_non_spec &&
			d_instr->speculative ()) 
			b = false;

		if (b && d_instr->is_store () && g_conf_issue_stores_non_spec &&
			d_instr->speculative ())
			b = false;

		if (b && d_instr->get_pipe_stage () == PIPE_WAIT &&
			mai_instr->readyto_execute () && fu->get_fu ()) {

			execute_avail--;
			d_instr->set_pipe_stage (PIPE_EXECUTE);

			eventq->insert (d_instr, fu->get_latency ());

		} else if (g_conf_issue_inorder) {
			break;
		}	

		// need to reach here.
		index = iwindow->window_increment (index);
		if (index == iwindow->window_increment (last_created))
			d_instr = 0;
		else 
			d_instr = iwindow->peek (index);
	}
}

fastsim_t*
sequencer_t::get_fastsim (void) {
	return fastsim;
}


void
sequencer_t::write_checkpoint(FILE *file) 
{
    ctrl_flow->write_checkpoint(file);
}

void
sequencer_t::read_checkpoint(FILE *file)
{
    ctrl_flow->read_checkpoint(file);
}

void 
sequencer_t::reset_interrupt (void) {
	ivec.invalidate ();
}

void 
sequencer_t::reset_shadow_interrupt (void) {
	shadow_ivec.invalidate ();
}


