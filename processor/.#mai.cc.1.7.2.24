/* Copyright (c) 2003 by Gurindar S. Sohi for the Wisconsin
 * Multiscalar Project.  ALL RIGHTS RESERVED.
 *
 * This software is furnished under the Multiscalar license.
 * For details see the LICENSE.mscalar file in the top-level source
 * directory, or online at http://www.cs.wisc.edu/mscalar/LICENSE
 *
 */

#include "simics/first.h"
RCSID("$Id: mai.cc,v 1.7.2.24 2005/12/19 17:22:23 pwells Exp $");

#include "definitions.h"
#include "mai.h"
#include "mai_instr.h"
#include "isa.h"
#include "fu.h"
#include "dynamic.h"
#include "window.h"
#include "iwindow.h"
#include "sequencer.h"
#include "chip.h"
#include "fu.h"
#include "eventq.h"
#include "ctrl_flow.h"
#include "ras.h"
#include "lsq.h"
#include "mem_xaction.h"
#include "st_buffer.h"
#include "config_extern.h"
#include "thread_scheduler.h"

#include "mem_hier_iface.h"
#include "transaction.h"
#include "proc_stats.h"
#include "counter.h"
#include "histogram.h"
#include "stats.h"

mai_t::mai_t (conf_object_t *_cpu, chip_t *_p) {
	cpu = _cpu;
	p = _p;
	shadow_cpu = 0;
	idle_loop = false;
    kstack_region = 0;

	auto_probe_sim_parameters ();

	ivec.initialize ();

	v9_interface = (sparc_v9_interface_t *) 
		SIM_get_interface(cpu, SPARC_V9_INTERFACE);
	ASSERT (v9_interface);
    syscall = 0x106; // Random assignment to keep aseets happy
	tl_reg = SIM_get_register_number (cpu, "tl");

}

mai_t::~mai_t () {
}

conf_object_t*
mai_t::get_cpu_obj () {
	return cpu;
}

void 
mai_t::auto_probe_sim_parameters () {

	simics_lsq_enable (cpu, g_conf_use_internal_lsq);
	if (!g_conf_memory_image_size);
		g_conf_memory_image_size = get_memory_image_size ();
}

uint64
mai_t::get_memory_image_size () {
	conf_object_t *obj = 0; 
	obj = SIM_get_object ("memory0");
	if (!obj) {
		SIM_clear_exception ();
		obj = SIM_get_object ("server_memory0");
	}
	
	if (!obj) FAIL;

	attr_value_t mem_obj_attr = SIM_get_attribute (obj, "image");
	ASSERT (mem_obj_attr.kind == Sim_Val_Object);

	conf_object_t *mem_obj = mem_obj_attr.u.object;

	attr_value_t mem_image_size_attr = SIM_get_attribute (mem_obj, "size");
	ASSERT (mem_image_size_attr.kind == Sim_Val_Integer);

	return mem_image_size_attr.u.integer;
}

void 
mai_t::simics_lsq_enable (conf_object_t *_cpu, bool b) {
	attr_value_t *lsq_enabled = new attr_value_t ();

	lsq_enabled->kind = Sim_Val_Integer;
	lsq_enabled->u.integer = static_cast <int32> (b);
	SIM_set_attribute (_cpu, "lsq-enabled", lsq_enabled);
}

void
mai_t::set_reorder_buffer_size (uint64 entries) {
	attr_value_t *rob_size = new attr_value_t ();

	rob_size->kind = Sim_Val_Integer;
	rob_size->u.integer = entries;
	
	set_error_t e = 
		SIM_set_attribute (cpu, "reorder-buffer-size", rob_size);


	ASSERT (e == Sim_Set_Ok);	

	delete rob_size;
}

bool
mai_t::is_supervisor () {
	
	uint32 level = SIM_cpu_privilege_level (cpu);
	
	FE_EXCEPTION_CHECK;
	if (level) return true; else return false;
}

void
mai_t::setup_trap_context (bool wrpr) {
    proc_stats_t *tstats0 = p->get_tstats_list (get_id())[0];

	uint64 tl = get_tl ();
	ASSERT (tl > 0);

	if (tl == STAT_GET (tstats0->stat_tl)) {
//		DEBUG_OUT ("skipping setup_trap_context ()\n");
		return;
	}

	STAT_INC (tstats0->stat_tl);
	if (STAT_GET (tstats0->stat_tl) != tl) {
		WARNING;
		STAT_SET (tstats0->stat_tl, tl);
	}
	
	uint64 tt;
	if (wrpr) tt = 0;
	else tt = get_tt (tl);
	STAT_SET (tstats0->stat_tt [tl], tt);
	
	// Solaris syscall
	if (is_syscall_trap(tt)) {
		ASSERT(STAT_GET (tstats0->stat_syscall_num) == 0);
		ASSERT(STAT_GET (tstats0->stat_syscall_start) == 0);
		set_syscall_num();
		STAT_SET (tstats0->stat_syscall_num, syscall);
		STAT_SET (tstats0->stat_syscall_start, p->get_g_cycles());
        //if (get_id() == 0) 
        //        DEBUG_OUT("[B]syscall %llu @ %llu\n", syscall, p->get_g_cycles());
        if (kstack_region) { 
            p->set_lwp_syscall(kstack_region, syscall);
            //DEBUG_OUT("%u: stack %llx making %llu\n", get_id(), kstack_region,
            //    syscall);
        }
        
	}
    
	else if (is_interrupt_trap(tt)) {
		
		// if currently in syscall, finish it up and change to interrupt type
		if (STAT_GET (tstats0->stat_syscall_num) != 0) {
			ASSERT(STAT_GET (tstats0->stat_syscall_start) != 0);

			uint64 syscall_len = p->get_g_cycles() - 
				STAT_GET (tstats0->stat_syscall_start);
			uint64 syscall = STAT_GET (tstats0->stat_syscall_num);

			STAT_ADD (tstats0->stat_syscall_len, syscall_len, syscall);
			STAT_ADD (tstats0->stat_syscall_hit, 1, syscall);
			tstats0->stat_syscall_len_histo->inc_total(1, syscall_len);
		}
		
		// rest of code like syscall above
		set_syscall_num();
        //if (get_id() == 0) 
        //        DEBUG_OUT("syscall %llu tt = %llx\n", syscall, tt);
		STAT_SET (tstats0->stat_syscall_num, syscall);
		STAT_SET (tstats0->stat_syscall_start, p->get_g_cycles());
	}
    
}



void
mai_t::handle_interrupt (sequencer_t *seq, proc_stats_t *pstats) {

	ASSERT(seq == p->get_sequencer_from_thread(SIM_get_proc_no(cpu)));

    // TODO -- get the right stat
	proc_stats_t *tstats = p->get_tstats (get_id());
	instruction_error_t    ie;
//	instruction_error_t    shadow_ie;
	st_buffer_t           *st_buffer = seq->get_st_buffer ();

	// st buffer needs to be empty
	if (!st_buffer->empty ()) {
  		return;
	}

	switch ((ie = SIM_instruction_handle_interrupt (cpu, ivec.get() ))) {
	case Sim_IE_OK:
		STAT_INC (pstats->stat_interrupts);
		STAT_INC (tstats->stat_interrupts);
		// after mai call
		ASSERT(is_interrupt_trap(get_tt(get_tl())));
		setup_trap_context ();
		reset_interrupt ();
		seq->potential_thread_switch(seq->mai_to_tid(this), YIELD_EXCEPTION);

		FE_EXCEPTION_CHECK;

		break;
	case Sim_IE_Illegal_Interrupt_Point:
		seq->prepare_for_interrupt (this);
		break;
	case Sim_IE_Interrupts_Disabled:
		break;

	default:
		FAIL;
	}
}


uint64
mai_t::get_tl () {
	return (static_cast <uint64> (SIM_read_register (cpu, tl_reg)));
}

uint64
mai_t::get_tt (uint64 tl) {

	char tt_s [5];

	sprintf (tt_s, "tt%lld", tl);
	int64 tt = SIM_get_register_number (cpu, tt_s);
	return (static_cast <uint64> (SIM_read_register (cpu, tt)));
}

uint64
mai_t::get_tstate (uint64 tl) {

	char ts_s [5];

	sprintf (ts_s, "tstate%lld", tl);
	int64 ts = SIM_get_register_number (cpu, ts_s);
	return (static_cast <uint64> (SIM_read_register (cpu, ts)));
}

bool
mai_t::is_fill_spill (uint64 tt) {
	// spill, fill or clean win
	return ((tt >= 0x80 && tt < 0x100) || tt == 0x24);
}

bool
mai_t::is_tlb_trap (uint64 tt) {
	return (tt == 0x64 || tt == 0x68);
}


bool
mai_t::is_user_trap() {
	uint64 tl = get_tl();
	if (tl != 1) return false;
	
	uint64 tstate = get_tstate(1);
	// bit 10 is pstate copy's priv
	return (((tstate >> 10) & 1) == 0);
}

addr_t
mai_t::get_pc () {
	int64 pc = SIM_get_register_number (cpu, "pc");
	return (static_cast <addr_t> (SIM_read_register (cpu, pc)));
}

addr_t
mai_t::get_npc () {
	int64 npc = SIM_get_register_number (cpu, "npc");
	return (static_cast <addr_t> (SIM_read_register (cpu, npc)));
}

void mai_t::break_sim (tick_t when) {
	ASSERT (when >= 0);
	SIM_break_cycle (cpu, when);	
}

void
mai_t::piq () {
	int              i;
	instruction_id_t id;

	attr_value_t     ipc;
	attr_value_t     inpc;
	attr_value_t     opc;
	attr_value_t     onpc;

	i = 0; 
	while ((id = SIM_instruction_nth_id (cpu, i))) {

		dynamic_instr_t *d_instr = static_cast <dynamic_instr_t *> 
	          	(SIM_instruction_get_user_data (id));

		mai_instruction_t *mai_instr = d_instr->get_mai_instruction (); 
		
		instruction_id_t shadow_instr_id = 
			mai_instr->get_shadow_instr_id ();

do_again:	
		ipc = SIM_instruction_read_input_reg (id, V9_Reg_Id_PC);
		inpc= SIM_instruction_read_input_reg (id, V9_Reg_Id_NPC);
		opc = SIM_instruction_read_output_reg (id, V9_Reg_Id_PC);
		onpc= SIM_instruction_read_output_reg (id, V9_Reg_Id_NPC);

		DEBUG_OUT ("%d, i: %d, phase: %d sync: %d spec: %d, status: %d exception: %d\n", 
		i,  id,
		SIM_instruction_phase (id), 
		SIM_instruction_is_sync (id), 
		SIM_instruction_speculative (id), 
		SIM_instruction_status (id) & Sim_IS_Faulting, 
		SIM_instruction_status (id));

		DEBUG_OUT ("PC (0x%llx, 0x%llx) (0x%llx, 0x%llx)\n", 
		ipc.u.integer, inpc.u.integer, opc.u.integer, onpc.u.integer);

		FE_EXCEPTION_CHECK;

		if (id == mai_instr->get_instr_id ()) {
			mai_instr->debug (1);

			id = shadow_instr_id;

			DEBUG_OUT ("SHADOW---\n");
			if (id) {
				ASSERT (shadow_instr_id == SIM_instruction_nth_id (shadow_cpu, i));	

				FE_EXCEPTION_CHECK;
				goto do_again;
			} else 
				DEBUG_OUT ("none.\n");
		} else { 
			mai_instr->shadow_debug (1);
		}

		i++;	
	}
}

void 
mai_t::set_shadow_cpu_obj (conf_object_t *_cpu) {
	
	shadow_cpu = _cpu;
	copy_master_simics_attributes ();

	simics_lsq_enable (shadow_cpu, g_conf_use_internal_lsq);
}

void 
mai_t::copy_master_simics_attributes () {

	attr_value_t temp = SIM_get_attribute (cpu, "reorder-buffer-size");
	attr_value_t *rob_size = new attr_value_t ();

	rob_size->kind = Sim_Val_Integer;
	rob_size->u.integer = temp.u.integer;
	
	set_error_t e = SIM_set_attribute (shadow_cpu, "reorder-buffer-size", rob_size);
	ASSERT (e == Sim_Set_Ok);	

}

conf_object_t *
mai_t::get_shadow_cpu_obj (void) {
	return shadow_cpu;
}

bool 
mai_t::check_shadow (void) {
	if (shadow_cpu) return true; else return false;

}

int32
mai_t::get_id() {
	return SIM_get_proc_no(cpu);
}

void
mai_t::set_interrupt(uint64 vector) {
	ivec.set(vector);
}

void
mai_t::reset_interrupt() {
	ivec.invalidate();
}

bool
mai_t::pending_interrupt() {
	return ivec.is_valid ();
}

uint64
mai_t::get_interrupt() {
	return ivec.get ();
}

void
mai_t::write_checkpoint(FILE *file) 
{
	fprintf(file, "%llu %d\n", ivec.is_valid() ? ivec.get() : 0, ivec.is_valid());
    fprintf(file, "%llu\n", syscall);
}

void
mai_t::read_checkpoint(FILE *file)
{
	uint64 temp_ivec;
	uint32 temp_valid;
	fscanf(file, "%llu %d\n", &temp_ivec, &temp_valid);
	if (temp_valid)
		ivec.set(temp_ivec);
	else
		ivec.invalidate();
    fscanf(file, "%llu\n", &syscall);
}



void
mai_t::set_syscall_num(bool provided, uint64 val)
{
	if (provided) {
		syscall = val;
		return;
	}
    uint64 tt = get_tt(get_tl());
    if (tt == 0x108)
        syscall = get_user_g1();
    else if (is_interrupt_trap(tt)) {
		if (tt == 0x60)
			syscall = SYS_NUM_SW_INTR;
		else
			syscall = SYS_NUM_HW_INTR;
//		syscall = 300 - 0x40 + tt;
	}
	else 
        syscall = tt;
}

uint64
mai_t::get_syscall_num()
{
    return syscall;
}

uint64
mai_t::get_user_g1 () {
	uint64 g1 = v9_interface->read_global_register(cpu, 0 /* normal */,
		1 /* %g1 */);
	FE_EXCEPTION_CHECK;
	return g1;
}

addr_t
mai_t::get_register (string reg) {
	int64 reg_num = SIM_get_register_number (cpu, reg.c_str());
	uint64 reg_val = static_cast <addr_t> (SIM_read_register (cpu, reg_num));
	FE_EXCEPTION_CHECK;
	return reg_val;
}

proc_stats_t *
mai_t::get_tstats() {
	return p->get_tstats(get_id());
}

bool
mai_t::is_idle_loop() {
	return idle_loop;
}

void
mai_t::set_idle_loop(bool idle) {
	idle_loop = idle;
}



bool
mai_t::is_syscall_trap(uint64 tt)
{
	return (
		               //   LINUX TT                        OPEN SOLARIS TT DOC
		tt == 0x100 || // SunOS Syscall                         old system call
//		tt == 0x106 || //                                                nfssys
		tt == 0x108 || // Solaris Syscall             ILP32 system call on LP64
		tt == 0x110 || // Linux 32bit Syscall             V9 user trap handlers
		tt == 0x111 || // Old Linux 64bit Syscall                     "
// short execution, don't count it:
//		tt == 0x124 || //                                         get timestamp
//		tt == 0x126 || //                                            self xcall
// short execution, don't count it:
//		tt == 0x127 || // indirect Solaris Syscall                 get hrestime
		
		tt == 0x140 || //                                      LP64 system call
		tt == 0x16d  // Linux 64bit Syscall
		);
}

bool
mai_t::is_interrupt_trap(uint64 tt)
{
	return (tt >= 0x41 && tt <= 0x4f) || tt == 0x60;
}

void
mai_t::set_kstack_region()
{
    uint64 stack_ptr = get_register("sp");
    kstack_region = stack_ptr - stack_ptr % 0xc000;
}

uint64
mai_t::get_kstack_region()
{
    return kstack_region;
}
