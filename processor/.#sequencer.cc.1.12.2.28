/* Copyright (c) 2003 by Gurindar S. Sohi for the Wisconsin
 * Multiscalar Project.  ALL RIGHTS RESERVED.
 *
 * This software is furnished under the Multiscalar license.
 * For details see the LICENSE.mscalar file in the top-level source
 * directory, or online at http://www.cs.wisc.edu/mscalar/LICENSE
 *
 */

#include "simics/first.h"
RCSID("$Id: sequencer.cc,v 1.12.2.28 2005/11/25 17:00:58 kchak Exp $");

#include "definitions.h"
#include "window.h"
#include "iwindow.h"
#include "sequencer.h"
#include "fu.h"
#include "isa.h"
#include "chip.h"
#include "eventq.h"
#include "dynamic.h"
#include "mai_instr.h"
#include "mai.h"
#include "ras.h"
#include "ctrl_flow.h"
#include "lsq.h"
#include "st_buffer.h"
#include "mem_xaction.h"
#include "v9_mem_xaction.h"
#include "transaction.h"
#include "wait_list.h"
#include "mem_hier_handle.h"
#include "proc_stats.h"
#include "counter.h"
#include "histogram.h"
#include "stats.h"
#include "config_extern.h"
#include "fastsim.h"
#include "fetch_buffer.h"
#include "thread_scheduler.h"
#include "thread_context.h"

// static initializations
uint64 sequencer_t::seq_id = 0;
dynamic_instr_t *sequencer_t::icache_d_instr = 0;
dynamic_instr_t *sequencer_t::mmu_d_instr = 0;

sequencer_t::sequencer_t (chip_t *_p, uint32 _id, uint32 *mai_ids, uint32 _ctxts) 
    : num_hw_ctxt (_ctxts) 
{
	p = _p;
	id = _id;

    mai = new mai_t *[num_hw_ctxt];
    ctrl_flow = new ctrl_flow_t *[num_hw_ctxt];
    fetch_status = new uint32[num_hw_ctxt];
    icount      = new uint32[num_hw_ctxt];
    
    thread_ids = new uint32[num_hw_ctxt];
    
    check_thread_yield = new bool[num_hw_ctxt];
	thread_yield_reason = new ts_yield_reason_t[num_hw_ctxt];
	
	// Waiting to start new thread 
	wait_after_switch = new tick_t[num_hw_ctxt];
    last_thread_switch = new tick_t[num_hw_ctxt];
    wait_on_checkpoint = new bool[num_hw_ctxt];
    mem_hier_seq = new (sequencer_t *)[num_hw_ctxt];
    
    for (uint32 i = 0; i < num_hw_ctxt; i++)
    {
        mai[i] = p->get_mai_object(mai_ids[i]);
        if (mai[i]) {
            fetch_status[i] = 0x0;
            ctrl_flow[i] = new ctrl_flow_t (this, mai[i]->get_pc (), mai[i]->get_npc (), i);
            mai[i]->set_reorder_buffer_size (g_conf_window_size);  
            fastsim = p->get_fastsim(id);
        } else {
            fetch_status[i] = FETCH_GPC_UNKNOWN;
            ctrl_flow[i] = new ctrl_flow_t (this, 0, 0, i);
        }
        
		mem_hier_seq[i] = this; 
        thread_ids[i] = mai_ids[i];
        wait_after_switch[i] = 0;
        last_thread_switch[i] = 0;
        check_thread_yield[i] = false;
        wait_on_checkpoint[i] = false;
        icount[i] = 0;
    }
	
	iwindow = new iwindow_t (g_conf_window_size);


	lsq = new lsq_t (this);
	st_buffer = new st_buffer_t (g_conf_stbuf_size, this);

	fus = new (fu_t *) [FU_TYPES];	
	for (fu_type_t unit = FU_NONE; unit < FU_TYPES; ++unit) {
		fus [unit] = new fu_t (unit, g_conf_fu_latencies [unit], 
			g_conf_fu_count [unit]);
	}

	
	fetch_buffer = new fetch_buffer_t (this, num_hw_ctxt);

	eventq = new eventq_t (g_conf_eventq_size);
	dead_list = new wait_list_t (g_conf_dead_list_size);
	recycle_list = new wait_list_t (g_conf_recycle_list_size);
	
#if 0
	if (g_conf_use_fastsim) 
		prepare_fastsim ();
#endif
	

	generate_pstats_list();
}

sequencer_t::~sequencer_t (void) {
	delete iwindow;

	delete [] fus;
	delete ctrl_flow;
	delete lsq;
	delete st_buffer;

	delete eventq;
	delete dead_list;
	delete recycle_list;
}

uint64 
sequencer_t::generate_seq_id (void) {
	return seq_id++;
}

fu_t*
sequencer_t::get_fu_resource (fu_type_t unit) {
	if (unit == FU_TYPES) 
		return 0; 
	else 	
		return fus [unit];
}

chip_t *
sequencer_t::get_chip (void) {
	return p;
}

iwindow_t*
sequencer_t::get_iwindow (void) {
	return iwindow;
}

lsq_t*
sequencer_t::get_lsq (void) {
	return lsq;
}

st_buffer_t*
sequencer_t::get_st_buffer (void) {
	return st_buffer;
}

mai_t*
sequencer_t::get_mai_object (uint8 tid) {
	return mai[tid];
}

void 
sequencer_t::safety_checks (void) {
	if (SIM_get_pending_exception ()) FAIL;
}

void
sequencer_t::front_end_status () {
	memq_t *ldq = lsq->get_ldq ();
	memq_t *stq = lsq->get_stq ();

	// iwindow
    
    if (num_hw_ctxt == 1) {
        if (iwindow->empty ()) {
            reset_fu_status (0, FETCH_STALL_UNTIL_EMPTY); 
            reset_fu_status (0, FETCH_WINDOW_FULL);
            ASSERT (ldq->empty ());
            ASSERT (stq->empty ());
            
        } else if (iwindow->full ()) {
            set_fu_status (0, FETCH_WINDOW_FULL);
        } else {
            ASSERT (!iwindow->empty ());
            ASSERT (!iwindow->full ());
            
            reset_fu_status (0, FETCH_WINDOW_FULL);
        }
        
    } else {
        // SMT mode assume 2-way
        bool all_empty = true;
        for (uint32 i = 0; i < num_hw_ctxt; i++)
        {
            if (iwindow->empty_ctxt(i)) {
                reset_fu_status (i, FETCH_STALL_UNTIL_EMPTY); 
                reset_fu_status (i, FETCH_WINDOW_FULL);
            } else 
                all_empty = false;
        }
        if (all_empty) {
            ASSERT (ldq->empty ());
            ASSERT (stq->empty ());
        }
        
            
        if (iwindow->full()) {
            for (uint32 i = 0; i < num_hw_ctxt; i++)
                set_fu_status (i, FETCH_WINDOW_FULL);
        } else {
            for (uint32 i = 0; i < num_hw_ctxt; i++)
                reset_fu_status (i, FETCH_WINDOW_FULL);
        }
        
    }
        

	// ldq
	if (!ldq->full ()) {
        for (uint32 i = 0; i < num_hw_ctxt; i++)
            reset_fu_status (i, FETCH_LDQ_FULL);
	}

	// stq
	if (!stq->full ())  {
        for (uint32 i = 0; i < num_hw_ctxt; i++)
            reset_fu_status (i, FETCH_STQ_FULL);
	}
}

void 
sequencer_t::advance_cycle (void) {
    
    bool early_return = true;
    for (uint32 i = 0; i < num_hw_ctxt; i++)
    {
        proc_stats_t *pstats = get_pstats (i);
        if (mai[i]) {
			early_return = false;
			STAT_INC (pstats->stat_cycles);  // only when ctxt not idle
		}
        else
			STAT_INC(pstats->stat_idle_context_cycles);
    }
    
    if (early_return) return;
    
    
	if (fastsim && fastsim->fastsim_mode ()) {
		if (iwindow->empty ()) 
			if (fastsim->sim ())
				finish_fastsim ();

		return;	
	}

	handle_interrupt ();

	start ();
	finish ();

	eventq->advance_cycle ();

	schedule ();
	
	cleanup_dead ();

	front_end_status ();
	if (!g_conf_disable_stbuffer) st_buffer->advance_cycle ();

	safety_checks ();

    // For window do with 0th context
    proc_stats_t *pstats = get_pstats(0);
	if (pstats) pstats->iwindow_stats (iwindow);
	
	handle_simulation ();

	forward_progress_check ();

	check_for_thread_switch();
}

void
sequencer_t::check_for_thread_switch()
{
	if (!g_conf_separate_user_os)
		return;

    
    for (uint32 i = 0; i < num_hw_ctxt; i++)
    {
        last_thread_switch[i]++;
        
        if (!mai[i]) continue;
        
        if (!check_thread_yield[i] && g_conf_thread_preempt && 
            last_thread_switch[i] > (tick_t) g_conf_thread_preempt) 
        {
            check_thread_yield[i] = true;
            thread_yield_reason[i] = YIELD_LONG_RUNNING;
        }
        
        if (check_thread_yield[i]) {
            ASSERT(thread_yield_reason[i] != YIELD_NONE);
            if (p->get_scheduler()->thread_yield(this , i, mai[i], 
                thread_yield_reason[i]))
            {
                set_fu_status(i, FETCH_PENDING_SWITCH);
            } 
            // don't try again for awhile...
            // Need to investigate if we need a more conservative
            // backoff
            else if (thread_yield_reason[i] == YIELD_LONG_RUNNING)
                last_thread_switch[i] = 0;
            
            check_thread_yield[i] = false;
        }
        
        if (((get_fu_status(i) & FETCH_PENDING_SWITCH) == FETCH_PENDING_SWITCH) &&
            iwindow->empty_ctxt(i) && st_buffer_empty())
        {
            p->get_scheduler()->ready_for_switch(this, i, mai[i], thread_yield_reason[i]);
            reset_fu_status(i, FETCH_PENDING_SWITCH);
        }
        
    }
}

void
sequencer_t::forward_progress_check () {
    
    for (uint32 i = 0; i < num_hw_ctxt; i++)
    {
        proc_stats_t *pstats = get_pstats (i);
        if (pstats) {
            uint64 check_cycle = STAT_GET (pstats->stat_check_cycle);
            
            if (check_cycle == p->get_g_cycles ()) {
                uint64 last_commits = STAT_GET (pstats->stat_last_commits);
                
                check_cycle += g_conf_check_freq;
                STAT_SET (pstats->stat_check_cycle, check_cycle);
                
                uint64 commits = STAT_GET (pstats->stat_commits);
                STAT_SET (pstats->stat_last_commits, commits);
                
                if (last_commits == commits && mai[i] 
                    && last_thread_switch[i] >= 10000) {
                    mai[i]->piq();
                    DEBUG_OUT ("No forward progress for Seq %d ctxt %d at %llu \n",
                    get_id(),i, p->get_g_cycles()); 
                    FAIL;
                }
            }
        }
        
    }
}

void 
sequencer_t::handle_simulation () {

    for (uint32 i = 0; i < num_hw_ctxt; i++)
    {
        if (wait_on_checkpoint[i]) {
            ASSERT(mai[i]);
            if (mai[i]->get_tl() == 0) {
                wait_on_checkpoint[i] = false;
                set_fu_status(i, FETCH_PENDING_CHECKPOINT);
            }
            STAT_INC(get_pstats(i)->stat_checkpoint_penalty);
        } else if (get_fu_status(i, FETCH_PENDING_CHECKPOINT)) {
            if (iwindow->empty_ctxt(i) && mai[i] && mai[i]->get_tl() != 0) {
                wait_on_checkpoint[i] = true;
                reset_fu_status(i, FETCH_PENDING_CHECKPOINT);
            }
            STAT_INC(get_pstats(i)->stat_checkpoint_penalty);
        }
        
    }

	//ASSERT(mai[0]);

	uint64 total_commits = 0;
	uint64 total_cycles = 0;

    for (uint32 c = 0; c < num_hw_ctxt; c++)
    {
        if (mai[c])
        {
            
			uint32 i = 0;
            while (pstats_list[c][i] != 0) {
                total_commits += (uint64) pstats_list[c][i]->stat_commits->get_total ();
                total_cycles += (uint64) pstats_list[c][i]->stat_cycles->get_total ();
                
                i++;
            }
            
            
            if (g_conf_run_cycles && 
            p->get_g_cycles () == (uint64) g_conf_run_cycles) {
                
                structure_stats ();
                p->print_stats ();
                p->get_mem_hier()->print_stats();
                mai[c]->break_sim (0);
            }
            
            if (g_conf_run_commits && 
            total_commits >= (uint64) g_conf_run_commits) {
                
                structure_stats ();
                p->print_stats ();
                p->get_mem_hier()->print_stats();
                mai[c]->break_sim (0);
            }
        }
        
    }
    
	if ( g_conf_heart_beat && ((p->get_g_cycles () % g_conf_heart_beat_cycles) == 0) ) 
		DEBUG_OUT ("seq%d committed %lld instructions in %lld cycles\n", 
			get_id (), total_commits, total_cycles);
}

void
sequencer_t::structure_stats () {
	proc_stats_t *pstats = get_pstats (0);

	STAT_SET (pstats->stat_dead_list_size, dead_list->get_size ());
	STAT_SET (pstats->stat_recycle_list_size, recycle_list->get_size ());
}


void 
sequencer_t::prepare_fastsim () {
    
    // Not handle fastsim in SMT
	squash_inflight_instructions (0);	
	ASSERT (!fastsim->fastsim_mode ());

	fastsim->sim_icount (g_conf_fastsim_icount);

    /* FastSIM won't work with SMT */
	if (mai[0] && mai[0]->pending_interrupt())
		fastsim->set_interrupt (mai[0]->get_interrupt ());
}

void 
sequencer_t::finish_fastsim () {
	ASSERT (!fastsim->fastsim_mode ());
    // TODO SMT with fastsim
	mai[0]->set_interrupt (fastsim->get_interrupt ());
}


void 
sequencer_t::prepare_for_interrupt (mai_t *_ma) {
    uint8 tid ;
    for (tid = 0 ; tid < num_hw_ctxt; tid++)
    {
        if (mai[tid] == _ma) break;
    }
    
	ASSERT(tid < num_hw_ctxt && mai[tid]);
	
	if (mai[tid]->pending_interrupt ()) 
	{
		if (!get_fu_status (tid, FETCH_STALL_UNTIL_EMPTY)) 
			set_fu_status (tid, FETCH_STALL_UNTIL_EMPTY);
		
		st_buffer->panic_clear ();

		if (g_conf_handle_interrupt_early)
			squash_inflight_instructions (tid);
	}
}

void
sequencer_t::squash_inflight_instructions (uint8 tid) {

	dynamic_instr_t *d_instr = iwindow->head ();
	if (!d_instr) return;

	if (d_instr->get_tid() == tid && 
        d_instr->get_pipe_stage () <= PIPE_EXECUTE) {
		d_instr->kill_all ();
		return;
	}

	uint32 index = iwindow->get_last_created ();
	uint32  head = iwindow->get_last_committed ();

	do {
		d_instr      = iwindow->peek (index);
		index        = iwindow->window_decrement (index);

		if (d_instr->get_tid() == tid && 
            d_instr->get_sync () && d_instr->get_pipe_stage () > PIPE_EXECUTE) break;

	} while (index != head);

	if (d_instr->get_next_d_instr ())
		d_instr->get_next_d_instr ()->kill_all ();
}

uint8 sequencer_t::select_thread_for_fetch(list<uint8> tlist)
{
       if (tlist.size() == 1) return tlist.front();
       uint32 selected_tid = tlist.front();
       list<uint8>::iterator it = tlist.begin();
       while (it != tlist.end())
       {
           if (icount[*it] < icount[selected_tid])
               selected_tid = *it;
           it++;
       }
       return selected_tid;
       //return p->get_g_cycles() % num_hw_ctxt;
}

void
sequencer_t::start (void) {

	uint32 fetch_avail = g_conf_max_fetch;
	
    for (uint32 i=0; i < num_hw_ctxt; i++)
    {
        if (wait_after_switch[i]) {
            STAT_INC(get_pstats(i)->stat_thread_switch_overhead);
            proc_stats_t *tstats = get_tstats (i);
			if (tstats)
				STAT_INC(tstats->stat_thread_switch_overhead);
            wait_after_switch[i]--;
        }
	}
    
    // Need to select thread to fetch from
    list<uint8> tid_list;
    
    for (uint32 i = 0; i < num_hw_ctxt; i++)
        if (fu_ready(i) && !wait_after_switch[i]) tid_list.push_back(i);
    
    
	while (tid_list.size()  && fetch_avail > 0 && iwindow->slot_avail ()) {

        uint8 tid = select_thread_for_fetch (tid_list);
        
        if (!fu_ready(tid)) {
			ASSERT(get_fu_status(tid, FETCH_PENDING_CHECKPOINT));
			tid_list.remove(tid);
			continue;
		}
		dynamic_instr_t *d_instr = 0;
		
		if (g_conf_recycle_instr)
			d_instr = recycle (tid);

		if (!d_instr)
			d_instr = new dynamic_instr_t (this, tid);
        
        

        icount[tid]++;
		d_instr->set_pipe_stage (PIPE_INSERT);
		d_instr->wakeup ();
        
        if (!fu_ready(tid)) tid_list.remove(tid);
        
		fetch_avail--;
        
	}

//	DEBUG_OUT ("fetched %lld instructions at cycle %lld\n", 
//		g_conf_max_fetch - fetch_avail, p->get_g_cycles ());
}


void sequencer_t::smt_commit (void) {
    uint32 commit_avail = g_conf_max_commit;
    
    set<uint8> tids_processed;
    uint32 tid;
    
    while (commit_avail > 0 && !iwindow->empty() && 
           tids_processed.size() < num_hw_ctxt)
    {
        dynamic_instr_t *d_instr = iwindow->peek_instr_for_commit(tids_processed);
        if (d_instr) tid = d_instr->get_tid();
        if (d_instr && process_instr_for_commit (d_instr)) {
            proc_stats_t *pstats = get_pstats (d_instr->get_tid());
            proc_stats_t *tstats = get_tstats (d_instr->get_tid());
            STAT_INC (pstats->stat_commits);
            if (tstats)
				STAT_INC (tstats->stat_commits);
            commit_avail--;
            
        } else {
            if (d_instr) tids_processed.insert(d_instr->get_tid());
            else break;
        }
    }
    
    
}

bool sequencer_t::process_instr_for_commit (dynamic_instr_t *d_instr)
{
    bool retire = false;
    ASSERT(d_instr);
    
    if (d_instr->speculative ()) {
        d_instr->kill_all ();
    } else if (d_instr->get_pipe_stage () == PIPE_MEM_ACCESS) {
        if (d_instr->is_load ()) {
            d_instr->ld_mem_access ();
        } else if (d_instr->is_store ()) {
            if (d_instr->immediate_release_store () && !st_buffer->empty ())
               return false;
            d_instr->st_mem_access ();
        } else FAIL;
        
        
    } else if (d_instr->get_pipe_stage () == PIPE_MEM_ACCESS_SAFE) {
        ASSERT (d_instr->is_load ());
        if (!st_buffer->empty ()) return false;
        
        d_instr->safe_ld_mem_access (); 
        
    } else if (d_instr->retire_ready ()) {
        if (d_instr->is_store () && 
            !d_instr->immediate_release_store () &&
        st_buffer->full ()) 
        return false;
        
        d_instr->retire ();
        retire = true;
    }
    
    return retire;
    
}

void 
sequencer_t::finish (void) {
    
    if (num_hw_ctxt > 1) {
        smt_commit();
        return;
    }
    
	proc_stats_t *pstats = get_pstats (0);
	proc_stats_t *tstats = get_tstats (0);
	uint32 commit_avail = g_conf_max_commit;
    uint32 tid;

	while (commit_avail > 0 && !iwindow->empty ()) {
		dynamic_instr_t *d_instr = iwindow->head ();
		ASSERT (d_instr);
        tid = d_instr->get_tid();
		if (process_instr_for_commit (d_instr)) {

			STAT_INC (pstats->stat_commits);
			if (tstats) STAT_INC (tstats->stat_commits);
			commit_avail--;

		} else 
			break;
	}
}

void
sequencer_t::insert_dead (dynamic_instr_t *d_instr) {

	wait_list_t *wl = dead_list->get_end_wait_list ();
	if (wl->full ()) wl = dead_list->create_wait_list ();

	wl->insert (d_instr);

//	ASSERT (!dead_list->full ());
}

void
sequencer_t::insert_recycle (dynamic_instr_t *d_instr) {

	wait_list_t *wl = recycle_list->get_end_wait_list ();
	if (wl->full ()) wl = recycle_list->create_wait_list ();

	wl->insert (d_instr);

//	ASSERT (!recycle_list->full ());
}

dynamic_instr_t*
sequencer_t::recycle (uint8 tid) {
	dynamic_instr_t *d_instr = recycle_list->head ();

	if (d_instr) {
		recycle_list->pop_head (d_instr);
		adjust_wait_list (recycle_list);

		d_instr->recycle (tid);
	}

	return d_instr;
}

wait_list_t*
sequencer_t::adjust_wait_list (wait_list_t* & start_wl) {
	wait_list_t *next_wl = 0, *wl;

	if (!start_wl->empty ()) return start_wl;

	wait_list_t *end_wl = start_wl->get_end_wait_list ();

	for (wl = start_wl; 
		wl && wl->get_next_wl () && wl->empty (); 
		wl = next_wl) {

		next_wl = wl->get_next_wl ();

		ASSERT (wl->empty ());
		wl->set_end_wait_list (0);
		wl->set_next_wait_list (0);

		delete wl;
	}

//	ASSERT (!wl->empty ());
	wl->set_end_wait_list (end_wl);

	start_wl = wl;
	return start_wl;
}

void
sequencer_t::cleanup_dead (void) {
	wait_list_t *wl = dead_list;

	for (; wl; wl = wl->get_next_wl ()) {
		while (wl->head ()) {
			dynamic_instr_t *d_instr = wl->head ();
			if (d_instr->get_outstanding () == 0x0) {
				wl->pop_head (d_instr);

				if (g_conf_recycle_instr)
					insert_recycle (d_instr);
				else	
					delete d_instr;

			} else 
				break;
		}
	}

	adjust_wait_list (dead_list);
}

bool
sequencer_t::get_fu_status (uint8 tid, uint32 s) {
	return ((fetch_status[tid] & s) == s);	
}

uint32
sequencer_t::get_fu_status (uint8 tid) {
	return fetch_status[tid];
}

void
sequencer_t::set_fu_status (uint8 tid, uint32 s) {
	fetch_status[tid] = (fetch_status[tid] | s);
}

void
sequencer_t::reset_fu_status (uint8 tid, uint32 s) {
	fetch_status[tid] = (fetch_status[tid] & (~s));
}

bool
sequencer_t::fu_ready (uint8 tid) {
	return (fetch_status[tid] == 0x0);
}

addr_t
sequencer_t::get_pc (uint8 tid) {
	return (ctrl_flow[tid]->get_pc ());
}

addr_t
sequencer_t::get_npc (uint8 tid) {
	return (ctrl_flow[tid]->get_npc ());
}

ctrl_flow_t*
sequencer_t::get_ctrl_flow (uint8 tid) {
	return ctrl_flow[tid];
}

void
sequencer_t::handle_interrupt () {
    
    for (uint32 i = 0; i < num_hw_ctxt; i++)
    {
        
        if (mai[i] && mai[i]->pending_interrupt())
            mai[i]->handle_interrupt (this, get_pstats(i));
        
    }
}


bool
sequencer_t::st_buffer_empty()
{
    return st_buffer->empty();
}

int64
sequencer_t::get_interrupt (uint8 tid) {
	return mai[tid]->get_interrupt ();
}

int64
sequencer_t::get_shadow_interrupt (uint8 tid) {
	return 0; //shadow_ivec.get ();
}


mem_hier_handle_t*
sequencer_t::get_mem_hier () {
	return (p->get_mem_hier ());
}

eventq_t*
sequencer_t::get_eventq () {
	return eventq;
}

void 
sequencer_t::schedule () {
	uint32 execute_avail = g_conf_max_issue;
	dynamic_instr_t *d_instr;

	if (iwindow->empty ()) return;
	
	uint32 last_created = iwindow->get_last_created ();
	uint32 index = iwindow->get_last_committed ();

	index = iwindow->window_increment (index);
	d_instr = iwindow->peek (index);

	while (execute_avail > 0 && d_instr) {
		mai_instruction_t *mai_instr = d_instr->get_mai_instruction ();
		fu_t *fu = d_instr->get_fu ();
		bool b = true;

		if (d_instr->get_sync () && ((num_hw_ctxt == 1 && iwindow->head () != d_instr) ||
            (num_hw_ctxt > 1 && iwindow->head_per_thread(d_instr->get_tid()) !=  d_instr)))
			b = false;

		if (b && d_instr->is_load () && g_conf_issue_load_commit && 
			iwindow->head () != d_instr) 
			b = false;

		if (b && d_instr->is_store () && g_conf_issue_store_commit && 
			iwindow->head () != d_instr)
			b = false;

		if (b && g_conf_issue_non_spec && d_instr->speculative ())
			b = false;

		if (b && d_instr->is_load () && g_conf_issue_loads_non_spec &&
			d_instr->speculative ()) 
			b = false;

		if (b && d_instr->is_store () && g_conf_issue_stores_non_spec &&
			d_instr->speculative ())
			b = false;

		if (b && d_instr->get_pipe_stage () == PIPE_WAIT &&
			mai_instr->readyto_execute () && fu->get_fu ()) {

			execute_avail--;
			d_instr->set_pipe_stage (PIPE_EXECUTE);

			eventq->insert (d_instr, fu->get_latency ());

		} else if (g_conf_issue_inorder) {
			break;
		}	

		// need to reach here.
		index = iwindow->window_increment (index);
		if (index == iwindow->window_increment (last_created))
			d_instr = 0;
		else 
			d_instr = iwindow->peek (index);
	}
}

fastsim_t*
sequencer_t::get_fastsim (void) {
	return fastsim;
}


void
sequencer_t::write_checkpoint(FILE *file) 
{
    for (uint32 i = 0; i < num_hw_ctxt; i++)
    {
        fprintf(file, "%u\n", (uint32)thread_ids[i]);
        ctrl_flow[i]->write_checkpoint(file);

		uint32 j = 0;
		while (pstats_list[i][j] != 0) {
			pstats_list[i][j]->stats->to_file(file);
			j++;
		}
    }
	
	lsq->write_checkpoint(file);
}

void
sequencer_t::read_checkpoint(FILE *file)
{
    for (uint32 i = 0; i < num_hw_ctxt; i++)
    {
        fscanf(file, "%u\n", &thread_ids[i]);
        mai[i] = p->get_mai_object(thread_ids[i]);
        ctrl_flow[i]->read_checkpoint(file);
		
		uint32 j = 0;
		while (pstats_list[i][j] != 0) {
			pstats_list[i][j]->stats->from_file(file);
			j++;
		}
        if (!mai[i]) set_fu_status(i, FETCH_GPC_UNKNOWN);
    }

	lsq->read_checkpoint(file);
}

// Switch sequencer to a new Simics/OS visible CPU
void
sequencer_t::switch_to_thread(mai_t *_mai, uint8 t_ctxt) {

	mai[t_ctxt] = _mai;
    last_thread_switch[t_ctxt] = 0;
    thread_yield_reason[t_ctxt] = YIELD_NONE;
    
	if (!mai[t_ctxt]) {
        set_fu_status(t_ctxt, FETCH_GPC_UNKNOWN);
        thread_ids[t_ctxt] = p->get_num_cpus();
		return;
	}

	mai[t_ctxt]->set_reorder_buffer_size (g_conf_window_size);

    thread_ids[t_ctxt] = _mai->get_id();
	// Copies new mai pc/npc
    ctrl_flow[t_ctxt]->set_ctxt(t_ctxt);
	ctrl_flow[t_ctxt]->fix_spec_state();

    fastsim = p->get_fastsim(thread_ids[t_ctxt]);
	
	reset_fu_status(t_ctxt, FETCH_GPC_UNKNOWN);
	
	wait_after_switch[t_ctxt] = g_conf_thread_switch_latency;
    ASSERT(icount[t_ctxt] == 0);
    
}

proc_stats_t *
sequencer_t::get_pstats(uint8 seq_ctxt)
{
	if (g_conf_kernel_stats && mai[seq_ctxt] && mai[seq_ctxt]->is_supervisor ()) 
		return pstats_list[seq_ctxt][1];
	else
		return pstats_list[seq_ctxt][0];
}

proc_stats_t **
sequencer_t::get_pstats_list(uint8 seq_ctxt)
{
	return pstats_list[seq_ctxt];
}

proc_stats_t *
sequencer_t::get_tstats(uint8 seq_ctxt)
{
	return p->get_tstats(thread_ids[seq_ctxt]);	
}

proc_stats_t **
sequencer_t::get_tstats_list(uint8 seq_ctxt)
{
	return p->get_tstats_list(thread_ids[seq_ctxt]);	
}

uint32
sequencer_t::get_id()
{
	return id;
}

fetch_buffer_t *
sequencer_t::get_fetch_buffer()
{
	return fetch_buffer;
}

void
sequencer_t::prepare_for_checkpoint(uint32 tid)
{
	ASSERT(!wait_on_checkpoint[tid]);
	
	if (mai[tid] && mai[tid]->get_tl() > 0)
		wait_on_checkpoint[tid] = true;
	else
		set_fu_status(tid, FETCH_PENDING_CHECKPOINT);
	
	STAT_INC(get_pstats(tid)->stat_intermediate_checkpoint);
	if (get_tstats(tid)) 
		STAT_INC(get_tstats(tid)->stat_intermediate_checkpoint);
}

bool
sequencer_t::ready_for_checkpoint()
{
    
    for (uint32 i = 0; i < num_hw_ctxt; i++)
    {
        //ASSERT(mai[i] == NULL || get_fu_status(i, FETCH_PENDING_CHECKPOINT) || wait_on_checkpoint[i]);
        
        if (wait_on_checkpoint[i]) 
            return false;
        if (mai[i] && mai[i]->get_tl() > 0)
            return false;
	}
    
    if (!st_buffer_empty())
            return false;
    if (!iwindow->empty())
            return false;
    
	return true;
}

void
sequencer_t::potential_thread_switch(uint8 t_ctxt, ts_yield_reason_t why) {
	if (g_conf_separate_user_os) {
		check_thread_yield[t_ctxt] = true;
		thread_yield_reason[t_ctxt] = why;
	}
}

void
sequencer_t::generate_pstats_list () {

	pstats_list = new proc_stats_t ** [num_hw_ctxt];

	for (uint32 s = 0; s < num_hw_ctxt; s++) {

		if (g_conf_kernel_stats) 
			pstats_list[s] = new proc_stats_t * [3];
		else
			pstats_list[s] = new proc_stats_t * [2];

		char name[32];
		sprintf(name, "ctxt_stats_%u_%u", get_id(), s);

		uint32 p = 0;
		pstats_list[s][p++] = new proc_stats_t (string(name));
		
		if (g_conf_kernel_stats) {
			sprintf(name, "kctxt_stats_%u_%u", get_id(), s);
			pstats_list[s][p++] = new proc_stats_t (string(name));
		}
		
		pstats_list[s][p] = 0;
	}
	
}

void
sequencer_t::print_stats() {
	
	
	for (uint32 s = 0; s < num_hw_ctxt; s++) {
        base_counter_t *stat_elapsed_sim = pstats_list[s][0]->stat_elapsed_sim;
        base_counter_t *stat_start_sim = pstats_list[s][0]->stat_start_sim;
        stat_elapsed_sim->set (static_cast <int64> (time (0)) - 
			(int64) stat_start_sim->get_total ());
		
		uint32 i = 0;
		uint64 total_commits = 0;
		uint64 total_cycles = 0;
		while (pstats_list[s][i] != 0) {
			total_commits += (uint64) pstats_list[s][i]->stat_commits->get_total ();
			total_cycles += (uint64) pstats_list[s][i]->stat_cycles->get_total ();
			i++;
		}
		STAT_SET(pstats_list[s][0]->stat_total_commits, total_commits);
		STAT_SET(pstats_list[s][0]->stat_total_cycles, total_cycles);
			
		i = 0;
		while (pstats_list[s][i] != 0) {
			pstats_list[s][i]->print ();
            
			i++;
		}
	}
	

	
}

uint32 sequencer_t::get_thread(uint32 i)
{
    return thread_ids[i];
}

void sequencer_t::update_icount(uint32 tid, uint32 num)
{
    ASSERT(icount[tid] >= num);
    if (icount[tid]) icount[tid] -= num;
}

void sequencer_t::decrement_icount(uint32 tid)
{
    icount[tid]--;
}

void sequencer_t::set_mem_hier_seq(sequencer_t *_s, uint32 tid)
{
    ASSERT(iwindow->empty_ctxt(tid));
    mem_hier_seq[tid] = _s; 
    last_thread_switch[tid] = 0;
    // SMT context won't work now ----
    if (g_conf_share_br_pred) {
        ctrl_flow[tid]->set_direct_bp(_s->get_ctrl_flow(0)->get_direct_bp());
        ctrl_flow[tid]->set_indirect_bp(_s->get_ctrl_flow(0)->get_indirect_bp());
    }
    //DEBUG_OUT("%8llu: %d ctxt %d is now %d\n", p->get_g_cycles(), id, tid, _s->get_id());
}

sequencer_t *sequencer_t::get_mem_hier_seq(uint32 tid)
{
    return mem_hier_seq[tid];
}

void sequencer_t::invalidate_address(sequencer_t *_s, invalidate_addr_t *invalid_addr)
{
    bool req_invalidate = false;
    for (uint32 i = 0; i < num_hw_ctxt; i++)
    {
        if (mem_hier_seq[i] == _s) 
        {
            req_invalidate = true;
            break;
        }
    }
    if (req_invalidate) lsq->invalidate_address(invalid_addr);
}

uint32 sequencer_t::get_ctxt_from_mai(mai_t *_m)
{
    for (uint32 i = 0; i < num_hw_ctxt; i++)
        if (mai[i] == _m) return i;
    FAIL;
}
