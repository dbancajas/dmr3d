/* Copyright (c) 2003 by Gurindar S. Sohi for the Wisconsin
 * Multiscalar Project.  ALL RIGHTS RESERVED.
 *
 * This software is furnished under the Multiscalar license.
 * For details see the LICENSE.mscalar file in the top-level source
 * directory, or online at http://www.cs.wisc.edu/mscalar/LICENSE
 */

/* description:    translates between the simics 'timing-model' and mem-hier
 *                 interfaces
 * initial author: Philip Wells 
 *
 */
 
#include "simics/first.h"
RCSID("$Id: mem_driver.cc,v 1.4.4.12 2006/01/30 17:11:22 kchak Exp $");
 
#include "definitions.h"
#include "transaction.h"
#include "profiles.h"
#include "mem_hier_handle.h"
#include "mem_driver.h"
#include "verbose_level.h"
#include "profiles.h"
#include "mem_hier.h"
#include "external.h"
#include "startup.h"
#include "shb.h"
#include "sequencer.h"
#include "config.h"
#include "config_extern.h"
#include "chip.h"
#include <signal.h>



mem_driver_t::mem_driver_t(proc_object_t *_processor) :
    proc(_processor)
{
	mem_hier = new mem_hier_t(_processor);
	mem_hier->set_ptr(mem_hier);	
	mem_hier->set_handler(this);
    runtime_config_file = "Nothing";
	transactions = new hash_map < int, mem_trans_t *> [SIM_number_processors()+1];
    break_sim_called = false;
    advance_memhier_cycles = false;
    pending_checkpoint = false;
    paused = NULL;   
    cached_trans_id = NULL;
}


void mem_driver_t::auto_advance_memhier()
{
    uint32 count = 100;
    uint32 steps = 0;
    proc->chip->stall_front_end();
    while (!mem_hier->is_quiet()) {
        for (uint32 i = 0; i < count; i++)
            mem_hier->advance_cycle();
        steps++;
    }
    advance_memhier_cycles = false;
    
}


cycles_t 
mem_driver_t::timing_operate(conf_object_t *proc_obj, conf_object_t *space, 
	map_list_t *map, generic_transaction_t *mem_op)
{
	v9_memory_transaction_t *v9_trans = (v9_memory_transaction_t *) mem_op;
	v9_trans->s.block_STC = 1;
    sequencer_t *seq = NULL;
	
	// To indicate proper CPU or some I/O device
	uint8 proc_id = IS_CPU_MEM_OP(v9_trans->s.ini_type) ?
				SIM_get_proc_no(v9_trans->s.ini_ptr) : SIM_number_processors();

	mem_trans_t *trans;
	trans = (transactions[proc_id])[v9_trans->s.id];

	//printf("%02u@%12llu 0x%016llx: mem_driver::timing_operate()\n", 
	//	   SIM_get_proc_no(v9_trans->s.ini_ptr), SIM_cycle_count(this),
	//	   v9_trans->s.physical_address);

	if (!trans) {
		// Not found, create new one and add
        trans = mem_hier->get_mem_trans();
		trans->copy(v9_trans);
		// don't call for unstallable transactions or prefetches
		// except for the second atomic if its a read (eg ldda)
		// except that u2 doesn't mark these as atomic like u3, so
		// hack some more crap in too 
		if ((!trans->may_stall || trans->hw_prefetch) &&
			(!trans->atomic || trans->write) &&
			(trans->io_device || !trans->read))
		{
			trans->call_complete_request = false;
		}
        ASSERT(trans->id >= 0);
        
        if (!trans->io_device && paused[trans->cpu_id] && trans->may_stall) {
            cached_trans_id[trans->cpu_id] = trans->id;
            trans->completed = true;
            goto stall_indefinitely;
        }
        (transactions[proc_id])[trans->id] = trans;
		
		if (g_conf_cache_data) {
			if (trans->write) {
				// Copy write data to trans
				trans->data = new uint8[trans->size];
				SIM_c_get_mem_op_value_buf(&v9_trans->s, (char *)trans->data);  

				VERBOSE_OUT(verb_t::data, "%10s @ %12llu 0x%016llx: storing\n",
			    	        "mem-driver", external::get_current_cycle(), trans->phys_addr);
				VERBOSE_DATA("mem-driver", external::get_current_cycle(), trans->phys_addr,
				             trans->size, trans->data);
			}
			// Reads checked in snoop_operate
		}

		// Make a new request to the memory hierarchy
		// TODO: ensure ini_ptr is a cpu
        if (pending_checkpoint)
        {
            if (advance_memhier_cycles) auto_advance_memhier();
            if (mem_hier->is_quiet() && !break_sim_called) {
                mem_hier->write_checkpoint(g_conf_mem_hier_checkpoint_out);
                if (g_conf_processor_checkpoint_out != "") {
                    FILE *file = fopen(g_conf_processor_checkpoint_out.c_str(), "w");
                    proc->chip->write_checkpoint(file);
                    fclose(file);
                }
                //SIM_write_configuration_to_file(g_conf_workload_checkpoint.c_str());
                //SIM_quit(0);
                proc->raise_checkpoint_hap();
                SIM_break_simulation("Ready to take warmup checkpoint");
                break_sim_called = true;
                trans->completed = 1;
            } else {
                goto done;
            }
        } else {
            /*
            if (!trans->io_device && SIM_stalled_until(trans->ini_ptr) > 0)
                //return 0;
                return SIM_stalled_until(trans->ini_ptr);
            */    
            trans->mark_pending(PROC_REQUEST);
            trans->pending_messages++;
            if (!trans->io_device)
                seq = proc->chip->get_sequencer_from_thread(trans->cpu_id);
            ASSERT(seq || trans->io_device || !trans->may_stall);
            
            if (seq) { 
                trans->set_sequencer(seq);
                if (!trans->ifetch && g_conf_spin_check_interval &&
                        g_conf_spinloop_threshold) 
                    seq->get_spin_heuristic()->observe_mem_trans(trans, &v9_trans->s);
                mem_hier->make_request((conf_object_t *)trans->mem_hier_seq, trans);
            } else if (trans->io_device) {
                mem_hier->make_request(trans->ini_ptr, trans);
            } else if (!trans->may_stall) {
                // Can't send this down to mem_hier as we do not know
                // which cache should respond
                ASSERT(paused[trans->cpu_id]);
                trans->completed = true;
            }
        }
		// If this was a hit, complete_request was called already, but has no
		// effect because the transaction isn't stalling yet (this function
		// hasn't returned) so be done with it
		if (trans->call_complete_request) {
			ASSERT(trans->completed || trans->may_stall || g_conf_copy_transaction);

			if (trans->completed) goto done;
			else return max_stall;

		} else {
            trans->completed = 1;
            trans->clear_pending_event(PROC_REQUEST);
			goto done;
		}
		
	} else {
		// Old transaction found, delete if completed, otherwise stall
        if (trans->completed || g_conf_copy_transaction) {
			goto done;
		} else {
			fprintf(stderr, "@ %12llu Reissued Transaction 0x%016llx id: %d cpu %u\n",
					external::get_current_cycle(), trans->phys_addr, trans->id, trans->cpu_id);
			ASSERT_MSG(0, "Trans not completed after 100000 cycles");
		}
	}
	
	return max_stall; 

done:
	//if (pending_checkpoint && trans->ifetch) return 1000000000;
    return 0;
    
stall_indefinitely:
    return 1000000000;
    
}	
	
cycles_t 
mem_driver_t::snoop_operate(conf_object_t *proc_obj, conf_object_t *space, 
		map_list_t *map, generic_transaction_t *mem_op)
{
	v9_memory_transaction_t *v9_trans = (v9_memory_transaction_t *) mem_op;

	// To indicate proper CPU or some I/O device
	uint8 proc_id = IS_CPU_MEM_OP(v9_trans->s.ini_type) ?
				SIM_get_proc_no(v9_trans->s.ini_ptr) : SIM_number_processors();
	mem_trans_t *trans;
	trans = (transactions[proc_id])[v9_trans->s.id];
	
	ASSERT(trans);

	// Check if load values were correct
	if (g_conf_cache_data) {
		if (trans->read && trans->data && !trans->sw_prefetch) {
			uint8 *databuf = new uint8[trans->size];
			SIM_c_get_mem_op_value_buf(&v9_trans->s, (char *)databuf);
			
			// Output data
			VERBOSE_OUT(verb_t::data, "%10s @ %12llu 0x%016llx: recieved\n",
				"mem-driver", mem_hier->get_g_cycles(), trans->phys_addr);
			VERBOSE_DATA("mem-driver", mem_hier->get_g_cycles(),
				trans->phys_addr, trans->size, trans->data);
			
			VERBOSE_OUT(verb_t::data, "%10s @ %12llu 0x%016llx: simics\n",
				"mem-driver", mem_hier->get_g_cycles(), trans->phys_addr);
			VERBOSE_DATA("mem-driver", mem_hier->get_g_cycles(),
				trans->phys_addr, trans->size, databuf);
						 
			// Compare data
			int retval = memcmp(trans->data, databuf, trans->size);
			//ASSERT_MSG(retval == 0, "Simics/mem-hier data mismatch");
			ASSERT_WARN(retval == 0);
			if (g_conf_break_data_mismatch && retval != 0) {
				SIM_break_cycle(get_cpu(), 0);
			}
			delete [] databuf;
		}
		else if (trans->read) {
			ASSERT(trans->io_device || trans->is_io_space() ||
			       trans->sw_prefetch ||
				   // FIXME: hack to identify flush
				   SIM_get_mem_op_type(&v9_trans->s) == Sim_Trans_Cache
				   );
		}
			
	}

	transactions[proc_id].erase(trans->id);
    trans->pending_messages--;
	return 0;
}
	
void
mem_driver_t::complete_request(conf_object_t *obj, 
	conf_object_t *cpu, mem_trans_t *trans)
{
	ASSERT(trans->completed);
    trans->clear_pending_event(PROC_REQUEST);
    sequencer_t *seq = 0;
    if (!trans->io_device) 
        seq = proc->chip->get_sequencer_from_thread(SIM_get_proc_no(trans->ini_ptr));
    //if (trans->io_device || seq)
        SIM_release_stall(trans->ini_ptr, trans->id);
    
}	

void 
mem_driver_t::invalidate_address (conf_object_t *obj, conf_object_t *cpu, 
		invalidate_addr_t *invalid_addr)
{ }

void
mem_driver_t::set_cpus(conf_object_t **cpus, uint32 num_cpus, uint32 num_threads)
{
	mem_hier->set_cpus(cpus, num_cpus);
    paused = new bool[num_threads];
    cached_trans_id = new int[num_threads];
    for (uint32 i = 0; i < num_threads; i++) {
        paused[i] = true;
        cached_trans_id[i] = -1;
    }
}

conf_object_t *
mem_driver_t::get_cpu()
{
	return mem_hier->get_cpu_object(0);
}

void
mem_driver_t::set_runtime_config(string config)
{
	runtime_config_file = config; 
	mem_hier->read_runtime_config_file(config);
}

string
mem_driver_t::get_runtime_config()
{
	return runtime_config_file; 
}

void
mem_driver_t::clear_stats()
{
    mem_hier->clear_stats();
}

void
mem_driver_t::stall_mem_hier()
{
	pending_checkpoint = true;
    advance_memhier_cycles = true;
}

bool
mem_driver_t::is_mem_hier_quiet()
{
    return (mem_hier->quiet_and_ready());
}

void
mem_driver_t::print_stats()
{
	mem_hier->print_stats();
}

mem_hier_t * mem_driver_t::get_mem_hier()
{
    return mem_hier;
}

void mem_driver_t::release_proc_stall(uint32 t_id)
{
    if (cached_trans_id[t_id] >= 0) 
        SIM_release_stall(SIM_proc_no_2_ptr(t_id), cached_trans_id[t_id]);
    cached_trans_id[t_id] = -1;
    paused[t_id] = false;
}

void mem_driver_t::stall_thread(uint32 id)
{
    paused[id] = true;
}

