# 1 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/power/basic_circuit.cc"
# 1 "<built-in>"
# 1 "<command line>"
# 1 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/power/basic_circuit.cc"
# 62 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/power/basic_circuit.cc"
RCSID("$Id: basic_circuit.cc,v 1.10.2.17 2006/03/02 23:58:42 kchak Exp $");

# 1 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/common/definitions.h" 1
# 15 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/common/definitions.h"
extern "C" {

}



# 1 "/usr/include/ctype.h" 1 3 4
# 27 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 319 "/usr/include/features.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 320 "/usr/include/features.h" 2 3 4
# 342 "/usr/include/features.h" 3 4
# 1 "/usr/include/gnu/stubs.h" 1 3 4
# 343 "/usr/include/features.h" 2 3 4
# 28 "/usr/include/ctype.h" 2 3 4
# 1 "/usr/include/bits/types.h" 1 3 4
# 28 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/bits/types.h" 2 3 4


# 1 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/stddef.h" 1 3 4
# 213 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/stddef.h" 3 4
typedef unsigned int size_t;
# 32 "/usr/include/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;




__extension__ typedef signed long long int __int64_t;
__extension__ typedef unsigned long long int __uint64_t;







__extension__ typedef long long int __quad_t;
__extension__ typedef unsigned long long int __u_quad_t;
# 129 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/typesizes.h" 1 3 4
# 130 "/usr/include/bits/types.h" 2 3 4






__extension__ typedef __u_quad_t __dev_t;
__extension__ typedef unsigned int __uid_t;
__extension__ typedef unsigned int __gid_t;
__extension__ typedef unsigned long int __ino_t;
__extension__ typedef __u_quad_t __ino64_t;
__extension__ typedef unsigned int __mode_t;
__extension__ typedef unsigned int __nlink_t;
__extension__ typedef long int __off_t;
__extension__ typedef __quad_t __off64_t;
__extension__ typedef int __pid_t;
__extension__ typedef struct { int __val[2]; } __fsid_t;
__extension__ typedef long int __clock_t;
__extension__ typedef unsigned long int __rlim_t;
__extension__ typedef __u_quad_t __rlim64_t;
__extension__ typedef unsigned int __id_t;
__extension__ typedef long int __time_t;
__extension__ typedef unsigned int __useconds_t;
__extension__ typedef long int __suseconds_t;

__extension__ typedef int __daddr_t;
__extension__ typedef long int __swblk_t;
__extension__ typedef int __key_t;


__extension__ typedef int __clockid_t;


__extension__ typedef int __timer_t;


__extension__ typedef long int __blksize_t;




__extension__ typedef long int __blkcnt_t;
__extension__ typedef __quad_t __blkcnt64_t;


__extension__ typedef unsigned long int __fsblkcnt_t;
__extension__ typedef __u_quad_t __fsblkcnt64_t;


__extension__ typedef unsigned long int __fsfilcnt_t;
__extension__ typedef __u_quad_t __fsfilcnt64_t;

__extension__ typedef int __ssize_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


__extension__ typedef int __intptr_t;


__extension__ typedef unsigned int __socklen_t;
# 29 "/usr/include/ctype.h" 2 3 4

extern "C" {
# 41 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/endian.h" 1 3 4
# 38 "/usr/include/endian.h" 2 3 4
# 42 "/usr/include/ctype.h" 2 3 4






enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 81 "/usr/include/ctype.h" 3 4
extern __const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__const));
extern __const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__const));
extern __const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__const));
# 96 "/usr/include/ctype.h" 3 4






extern int isalnum (int) throw ();
extern int isalpha (int) throw ();
extern int iscntrl (int) throw ();
extern int isdigit (int) throw ();
extern int islower (int) throw ();
extern int isgraph (int) throw ();
extern int isprint (int) throw ();
extern int ispunct (int) throw ();
extern int isspace (int) throw ();
extern int isupper (int) throw ();
extern int isxdigit (int) throw ();



extern int tolower (int __c) throw ();


extern int toupper (int __c) throw ();








extern int isblank (int) throw ();






extern int isctype (int __c, int __mask) throw ();






extern int isascii (int __c) throw ();



extern int toascii (int __c) throw ();



extern int _toupper (int) throw ();
extern int _tolower (int) throw ();
# 233 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/xlocale.h" 1 3 4
# 28 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;
# 234 "/usr/include/ctype.h" 2 3 4
# 247 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, __locale_t) throw ();
extern int isalpha_l (int, __locale_t) throw ();
extern int iscntrl_l (int, __locale_t) throw ();
extern int isdigit_l (int, __locale_t) throw ();
extern int islower_l (int, __locale_t) throw ();
extern int isgraph_l (int, __locale_t) throw ();
extern int isprint_l (int, __locale_t) throw ();
extern int ispunct_l (int, __locale_t) throw ();
extern int isspace_l (int, __locale_t) throw ();
extern int isupper_l (int, __locale_t) throw ();
extern int isxdigit_l (int, __locale_t) throw ();

extern int isblank_l (int, __locale_t) throw ();



extern int __tolower_l (int __c, __locale_t __l) throw ();
extern int tolower_l (int __c, __locale_t __l) throw ();


extern int __toupper_l (int __c, __locale_t __l) throw ();
extern int toupper_l (int __c, __locale_t __l) throw ();
# 323 "/usr/include/ctype.h" 3 4
}
# 22 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/common/definitions.h" 2
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/iostream" 1 3
# 43 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/iostream" 3

# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/c++config.h" 1 3
# 35 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/c++config.h" 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/os_defines.h" 1 3
# 36 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/c++config.h" 2 3
# 45 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/iostream" 2 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ostream" 1 3
# 44 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ostream" 3

# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ios" 1 3
# 43 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ios" 3

# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/iosfwd" 1 3
# 44 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/iosfwd" 3


# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/c++locale.h" 1 3
# 40 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/c++locale.h" 3

# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/clocale" 1 3
# 48 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/clocale" 3

# 1 "/usr/include/locale.h" 1 3 4
# 29 "/usr/include/locale.h" 3 4
# 1 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/stddef.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/bits/locale.h" 1 3 4
# 27 "/usr/include/bits/locale.h" 3 4
enum
{
  __LC_CTYPE = 0,
  __LC_NUMERIC = 1,
  __LC_TIME = 2,
  __LC_COLLATE = 3,
  __LC_MONETARY = 4,
  __LC_MESSAGES = 5,
  __LC_ALL = 6,
  __LC_PAPER = 7,
  __LC_NAME = 8,
  __LC_ADDRESS = 9,
  __LC_TELEPHONE = 10,
  __LC_MEASUREMENT = 11,
  __LC_IDENTIFICATION = 12
};
# 31 "/usr/include/locale.h" 2 3 4

extern "C" {
# 52 "/usr/include/locale.h" 3 4
struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 119 "/usr/include/locale.h" 3 4
};





extern char *setlocale (int __category, __const char *__locale) throw ();


extern struct lconv *localeconv (void) throw ();


# 148 "/usr/include/locale.h" 3 4
typedef __locale_t locale_t;





extern __locale_t newlocale (int __category_mask, __const char *__locale,
                             __locale_t __base) throw ();
# 189 "/usr/include/locale.h" 3 4
extern __locale_t duplocale (__locale_t __dataset) throw ();



extern void freelocale (__locale_t __dataset) throw ();






extern __locale_t uselocale (__locale_t __dataset) throw ();







}
# 50 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/clocale" 2 3





namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
# 42 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/c++locale.h" 2 3
# 1 "/usr/include/langinfo.h" 1 3 4
# 24 "/usr/include/langinfo.h" 3 4
# 1 "/usr/include/nl_types.h" 1 3 4
# 31 "/usr/include/nl_types.h" 3 4
extern "C" {


typedef void *nl_catd;


typedef int nl_item;





extern nl_catd catopen (__const char *__cat_name, int __flag) __attribute__ ((__nonnull__ (1)));



extern char *catgets (nl_catd __catalog, int __set, int __number,
                      __const char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern int catclose (nl_catd __catalog) throw () __attribute__ ((__nonnull__ (1)));

}
# 25 "/usr/include/langinfo.h" 2 3 4

# 1 "/usr/include/bits/locale.h" 1 3 4
# 27 "/usr/include/langinfo.h" 2 3 4


extern "C" {
# 43 "/usr/include/langinfo.h" 3 4
enum
{



  ABDAY_1 = (((__LC_TIME) << 16) | (0)),

  ABDAY_2,

  ABDAY_3,

  ABDAY_4,

  ABDAY_5,

  ABDAY_6,

  ABDAY_7,



  DAY_1,

  DAY_2,

  DAY_3,

  DAY_4,

  DAY_5,

  DAY_6,

  DAY_7,



  ABMON_1,

  ABMON_2,

  ABMON_3,

  ABMON_4,

  ABMON_5,

  ABMON_6,

  ABMON_7,

  ABMON_8,

  ABMON_9,

  ABMON_10,

  ABMON_11,

  ABMON_12,



  MON_1,

  MON_2,

  MON_3,

  MON_4,

  MON_5,

  MON_6,

  MON_7,

  MON_8,

  MON_9,

  MON_10,

  MON_11,

  MON_12,


  AM_STR,

  PM_STR,


  D_T_FMT,

  D_FMT,

  T_FMT,

  T_FMT_AMPM,


  ERA,

  __ERA_YEAR,



  ERA_D_FMT,

  ALT_DIGITS,

  ERA_D_T_FMT,

  ERA_T_FMT,


  _NL_TIME_ERA_NUM_ENTRIES,
  _NL_TIME_ERA_ENTRIES,

  _NL_WABDAY_1,
  _NL_WABDAY_2,
  _NL_WABDAY_3,
  _NL_WABDAY_4,
  _NL_WABDAY_5,
  _NL_WABDAY_6,
  _NL_WABDAY_7,


  _NL_WDAY_1,
  _NL_WDAY_2,
  _NL_WDAY_3,
  _NL_WDAY_4,
  _NL_WDAY_5,
  _NL_WDAY_6,
  _NL_WDAY_7,


  _NL_WABMON_1,
  _NL_WABMON_2,
  _NL_WABMON_3,
  _NL_WABMON_4,
  _NL_WABMON_5,
  _NL_WABMON_6,
  _NL_WABMON_7,
  _NL_WABMON_8,
  _NL_WABMON_9,
  _NL_WABMON_10,
  _NL_WABMON_11,
  _NL_WABMON_12,


  _NL_WMON_1,
  _NL_WMON_2,
  _NL_WMON_3,
  _NL_WMON_4,
  _NL_WMON_5,
  _NL_WMON_6,
  _NL_WMON_7,
  _NL_WMON_8,
  _NL_WMON_9,
  _NL_WMON_10,
  _NL_WMON_11,
  _NL_WMON_12,

  _NL_WAM_STR,
  _NL_WPM_STR,

  _NL_WD_T_FMT,
  _NL_WD_FMT,
  _NL_WT_FMT,
  _NL_WT_FMT_AMPM,

  _NL_WERA_YEAR,
  _NL_WERA_D_FMT,
  _NL_WALT_DIGITS,
  _NL_WERA_D_T_FMT,
  _NL_WERA_T_FMT,

  _NL_TIME_WEEK_NDAYS,
  _NL_TIME_WEEK_1STDAY,
  _NL_TIME_WEEK_1STWEEK,
  _NL_TIME_FIRST_WEEKDAY,
  _NL_TIME_FIRST_WORKDAY,
  _NL_TIME_CAL_DIRECTION,
  _NL_TIME_TIMEZONE,

  _DATE_FMT,

  _NL_W_DATE_FMT,

  _NL_TIME_CODESET,

  _NL_NUM_LC_TIME,




  _NL_COLLATE_NRULES = (((__LC_COLLATE) << 16) | (0)),
  _NL_COLLATE_RULESETS,
  _NL_COLLATE_TABLEMB,
  _NL_COLLATE_WEIGHTMB,
  _NL_COLLATE_EXTRAMB,
  _NL_COLLATE_INDIRECTMB,
  _NL_COLLATE_GAP1,
  _NL_COLLATE_GAP2,
  _NL_COLLATE_GAP3,
  _NL_COLLATE_TABLEWC,
  _NL_COLLATE_WEIGHTWC,
  _NL_COLLATE_EXTRAWC,
  _NL_COLLATE_INDIRECTWC,
  _NL_COLLATE_SYMB_HASH_SIZEMB,
  _NL_COLLATE_SYMB_TABLEMB,
  _NL_COLLATE_SYMB_EXTRAMB,
  _NL_COLLATE_COLLSEQMB,
  _NL_COLLATE_COLLSEQWC,
  _NL_COLLATE_CODESET,
  _NL_NUM_LC_COLLATE,




  _NL_CTYPE_CLASS = (((__LC_CTYPE) << 16) | (0)),
  _NL_CTYPE_TOUPPER,
  _NL_CTYPE_GAP1,
  _NL_CTYPE_TOLOWER,
  _NL_CTYPE_GAP2,
  _NL_CTYPE_CLASS32,
  _NL_CTYPE_GAP3,
  _NL_CTYPE_GAP4,
  _NL_CTYPE_GAP5,
  _NL_CTYPE_GAP6,
  _NL_CTYPE_CLASS_NAMES,
  _NL_CTYPE_MAP_NAMES,
  _NL_CTYPE_WIDTH,
  _NL_CTYPE_MB_CUR_MAX,
  _NL_CTYPE_CODESET_NAME,
  CODESET = _NL_CTYPE_CODESET_NAME,

  _NL_CTYPE_TOUPPER32,
  _NL_CTYPE_TOLOWER32,
  _NL_CTYPE_CLASS_OFFSET,
  _NL_CTYPE_MAP_OFFSET,
  _NL_CTYPE_INDIGITS_MB_LEN,
  _NL_CTYPE_INDIGITS0_MB,
  _NL_CTYPE_INDIGITS1_MB,
  _NL_CTYPE_INDIGITS2_MB,
  _NL_CTYPE_INDIGITS3_MB,
  _NL_CTYPE_INDIGITS4_MB,
  _NL_CTYPE_INDIGITS5_MB,
  _NL_CTYPE_INDIGITS6_MB,
  _NL_CTYPE_INDIGITS7_MB,
  _NL_CTYPE_INDIGITS8_MB,
  _NL_CTYPE_INDIGITS9_MB,
  _NL_CTYPE_INDIGITS_WC_LEN,
  _NL_CTYPE_INDIGITS0_WC,
  _NL_CTYPE_INDIGITS1_WC,
  _NL_CTYPE_INDIGITS2_WC,
  _NL_CTYPE_INDIGITS3_WC,
  _NL_CTYPE_INDIGITS4_WC,
  _NL_CTYPE_INDIGITS5_WC,
  _NL_CTYPE_INDIGITS6_WC,
  _NL_CTYPE_INDIGITS7_WC,
  _NL_CTYPE_INDIGITS8_WC,
  _NL_CTYPE_INDIGITS9_WC,
  _NL_CTYPE_OUTDIGIT0_MB,
  _NL_CTYPE_OUTDIGIT1_MB,
  _NL_CTYPE_OUTDIGIT2_MB,
  _NL_CTYPE_OUTDIGIT3_MB,
  _NL_CTYPE_OUTDIGIT4_MB,
  _NL_CTYPE_OUTDIGIT5_MB,
  _NL_CTYPE_OUTDIGIT6_MB,
  _NL_CTYPE_OUTDIGIT7_MB,
  _NL_CTYPE_OUTDIGIT8_MB,
  _NL_CTYPE_OUTDIGIT9_MB,
  _NL_CTYPE_OUTDIGIT0_WC,
  _NL_CTYPE_OUTDIGIT1_WC,
  _NL_CTYPE_OUTDIGIT2_WC,
  _NL_CTYPE_OUTDIGIT3_WC,
  _NL_CTYPE_OUTDIGIT4_WC,
  _NL_CTYPE_OUTDIGIT5_WC,
  _NL_CTYPE_OUTDIGIT6_WC,
  _NL_CTYPE_OUTDIGIT7_WC,
  _NL_CTYPE_OUTDIGIT8_WC,
  _NL_CTYPE_OUTDIGIT9_WC,
  _NL_CTYPE_TRANSLIT_TAB_SIZE,
  _NL_CTYPE_TRANSLIT_FROM_IDX,
  _NL_CTYPE_TRANSLIT_FROM_TBL,
  _NL_CTYPE_TRANSLIT_TO_IDX,
  _NL_CTYPE_TRANSLIT_TO_TBL,
  _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN,
  _NL_CTYPE_TRANSLIT_DEFAULT_MISSING,
  _NL_CTYPE_TRANSLIT_IGNORE_LEN,
  _NL_CTYPE_TRANSLIT_IGNORE,
  _NL_CTYPE_MAP_TO_NONASCII,
  _NL_CTYPE_EXTRA_MAP_1,
  _NL_CTYPE_EXTRA_MAP_2,
  _NL_CTYPE_EXTRA_MAP_3,
  _NL_CTYPE_EXTRA_MAP_4,
  _NL_CTYPE_EXTRA_MAP_5,
  _NL_CTYPE_EXTRA_MAP_6,
  _NL_CTYPE_EXTRA_MAP_7,
  _NL_CTYPE_EXTRA_MAP_8,
  _NL_CTYPE_EXTRA_MAP_9,
  _NL_CTYPE_EXTRA_MAP_10,
  _NL_CTYPE_EXTRA_MAP_11,
  _NL_CTYPE_EXTRA_MAP_12,
  _NL_CTYPE_EXTRA_MAP_13,
  _NL_CTYPE_EXTRA_MAP_14,
  _NL_NUM_LC_CTYPE,




  __INT_CURR_SYMBOL = (((__LC_MONETARY) << 16) | (0)),



  __CURRENCY_SYMBOL,



  __MON_DECIMAL_POINT,



  __MON_THOUSANDS_SEP,



  __MON_GROUPING,



  __POSITIVE_SIGN,



  __NEGATIVE_SIGN,



  __INT_FRAC_DIGITS,



  __FRAC_DIGITS,



  __P_CS_PRECEDES,



  __P_SEP_BY_SPACE,



  __N_CS_PRECEDES,



  __N_SEP_BY_SPACE,



  __P_SIGN_POSN,



  __N_SIGN_POSN,



  _NL_MONETARY_CRNCYSTR,

  __INT_P_CS_PRECEDES,



  __INT_P_SEP_BY_SPACE,



  __INT_N_CS_PRECEDES,



  __INT_N_SEP_BY_SPACE,



  __INT_P_SIGN_POSN,



  __INT_N_SIGN_POSN,



  _NL_MONETARY_DUO_INT_CURR_SYMBOL,
  _NL_MONETARY_DUO_CURRENCY_SYMBOL,
  _NL_MONETARY_DUO_INT_FRAC_DIGITS,
  _NL_MONETARY_DUO_FRAC_DIGITS,
  _NL_MONETARY_DUO_P_CS_PRECEDES,
  _NL_MONETARY_DUO_P_SEP_BY_SPACE,
  _NL_MONETARY_DUO_N_CS_PRECEDES,
  _NL_MONETARY_DUO_N_SEP_BY_SPACE,
  _NL_MONETARY_DUO_INT_P_CS_PRECEDES,
  _NL_MONETARY_DUO_INT_P_SEP_BY_SPACE,
  _NL_MONETARY_DUO_INT_N_CS_PRECEDES,
  _NL_MONETARY_DUO_INT_N_SEP_BY_SPACE,
  _NL_MONETARY_DUO_P_SIGN_POSN,
  _NL_MONETARY_DUO_N_SIGN_POSN,
  _NL_MONETARY_DUO_INT_P_SIGN_POSN,
  _NL_MONETARY_DUO_INT_N_SIGN_POSN,
  _NL_MONETARY_UNO_VALID_FROM,
  _NL_MONETARY_UNO_VALID_TO,
  _NL_MONETARY_DUO_VALID_FROM,
  _NL_MONETARY_DUO_VALID_TO,
  _NL_MONETARY_CONVERSION_RATE,
  _NL_MONETARY_DECIMAL_POINT_WC,
  _NL_MONETARY_THOUSANDS_SEP_WC,
  _NL_MONETARY_CODESET,
  _NL_NUM_LC_MONETARY,



  __DECIMAL_POINT = (((__LC_NUMERIC) << 16) | (0)),



  RADIXCHAR = __DECIMAL_POINT,

  __THOUSANDS_SEP,



  THOUSEP = __THOUSANDS_SEP,

  __GROUPING,



  _NL_NUMERIC_DECIMAL_POINT_WC,
  _NL_NUMERIC_THOUSANDS_SEP_WC,
  _NL_NUMERIC_CODESET,
  _NL_NUM_LC_NUMERIC,

  __YESEXPR = (((__LC_MESSAGES) << 16) | (0)),

  __NOEXPR,

  __YESSTR,



  __NOSTR,



  _NL_MESSAGES_CODESET,
  _NL_NUM_LC_MESSAGES,

  _NL_PAPER_HEIGHT = (((__LC_PAPER) << 16) | (0)),
  _NL_PAPER_WIDTH,
  _NL_PAPER_CODESET,
  _NL_NUM_LC_PAPER,

  _NL_NAME_NAME_FMT = (((__LC_NAME) << 16) | (0)),
  _NL_NAME_NAME_GEN,
  _NL_NAME_NAME_MR,
  _NL_NAME_NAME_MRS,
  _NL_NAME_NAME_MISS,
  _NL_NAME_NAME_MS,
  _NL_NAME_CODESET,
  _NL_NUM_LC_NAME,

  _NL_ADDRESS_POSTAL_FMT = (((__LC_ADDRESS) << 16) | (0)),
  _NL_ADDRESS_COUNTRY_NAME,
  _NL_ADDRESS_COUNTRY_POST,
  _NL_ADDRESS_COUNTRY_AB2,
  _NL_ADDRESS_COUNTRY_AB3,
  _NL_ADDRESS_COUNTRY_CAR,
  _NL_ADDRESS_COUNTRY_NUM,
  _NL_ADDRESS_COUNTRY_ISBN,
  _NL_ADDRESS_LANG_NAME,
  _NL_ADDRESS_LANG_AB,
  _NL_ADDRESS_LANG_TERM,
  _NL_ADDRESS_LANG_LIB,
  _NL_ADDRESS_CODESET,
  _NL_NUM_LC_ADDRESS,

  _NL_TELEPHONE_TEL_INT_FMT = (((__LC_TELEPHONE) << 16) | (0)),
  _NL_TELEPHONE_TEL_DOM_FMT,
  _NL_TELEPHONE_INT_SELECT,
  _NL_TELEPHONE_INT_PREFIX,
  _NL_TELEPHONE_CODESET,
  _NL_NUM_LC_TELEPHONE,

  _NL_MEASUREMENT_MEASUREMENT = (((__LC_MEASUREMENT) << 16) | (0)),
  _NL_MEASUREMENT_CODESET,
  _NL_NUM_LC_MEASUREMENT,

  _NL_IDENTIFICATION_TITLE = (((__LC_IDENTIFICATION) << 16) | (0)),
  _NL_IDENTIFICATION_SOURCE,
  _NL_IDENTIFICATION_ADDRESS,
  _NL_IDENTIFICATION_CONTACT,
  _NL_IDENTIFICATION_EMAIL,
  _NL_IDENTIFICATION_TEL,
  _NL_IDENTIFICATION_FAX,
  _NL_IDENTIFICATION_LANGUAGE,
  _NL_IDENTIFICATION_TERRITORY,
  _NL_IDENTIFICATION_AUDIENCE,
  _NL_IDENTIFICATION_APPLICATION,
  _NL_IDENTIFICATION_ABBREVIATION,
  _NL_IDENTIFICATION_REVISION,
  _NL_IDENTIFICATION_DATE,
  _NL_IDENTIFICATION_CATEGORY,
  _NL_IDENTIFICATION_CODESET,
  _NL_NUM_LC_IDENTIFICATION,


  _NL_NUM
};
# 576 "/usr/include/langinfo.h" 3 4
extern char *nl_langinfo (nl_item __item) throw ();
# 587 "/usr/include/langinfo.h" 3 4
extern char *nl_langinfo_l (nl_item __item, __locale_t l);


}
# 43 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/c++locale.h" 2 3
# 1 "/usr/include/iconv.h" 1 3 4
# 24 "/usr/include/iconv.h" 3 4
# 1 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/stddef.h" 1 3 4
# 25 "/usr/include/iconv.h" 2 3 4


extern "C" {


typedef void *iconv_t;







extern iconv_t iconv_open (__const char *__tocode, __const char *__fromcode);




extern size_t iconv (iconv_t __cd, char **__restrict __inbuf,
                     size_t *__restrict __inbytesleft,
                     char **__restrict __outbuf,
                     size_t *__restrict __outbytesleft);





extern int iconv_close (iconv_t __cd);

}
# 44 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/c++locale.h" 2 3
# 1 "/usr/include/libintl.h" 1 3 4
# 35 "/usr/include/libintl.h" 3 4
extern "C" {




extern char *gettext (__const char *__msgid) throw ();



extern char *dgettext (__const char *__domainname, __const char *__msgid)
     throw ();
extern char *__dgettext (__const char *__domainname, __const char *__msgid)
     throw () __attribute__ ((__format_arg__ (2)));



extern char *dcgettext (__const char *__domainname,
                        __const char *__msgid, int __category) throw ();
extern char *__dcgettext (__const char *__domainname,
                          __const char *__msgid, int __category)
     throw () __attribute__ ((__format_arg__ (2)));




extern char *ngettext (__const char *__msgid1, __const char *__msgid2,
                       unsigned long int __n)
     throw () __attribute__ ((__format_arg__ (1))) __attribute__ ((__format_arg__ (2)));



extern char *dngettext (__const char *__domainname, __const char *__msgid1,
                        __const char *__msgid2, unsigned long int __n)
     throw () __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));



extern char *dcngettext (__const char *__domainname, __const char *__msgid1,
                         __const char *__msgid2, unsigned long int __n,
                         int __category)
     throw () __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));





extern char *textdomain (__const char *__domainname) throw ();



extern char *bindtextdomain (__const char *__domainname,
                             __const char *__dirname) throw ();



extern char *bind_textdomain_codeset (__const char *__domainname,
                                      __const char *__codeset) throw ();
# 120 "/usr/include/libintl.h" 3 4
}
# 45 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/c++locale.h" 2 3






namespace __gnu_cxx
{
  extern "C" __typeof(uselocale) __uselocale;
}


namespace std
{
  typedef __locale_t __c_locale;





  template<typename _Tv>
    int
    __convert_from_v(char* __out, const int __size, const char* __fmt,

                     _Tv __v, const __c_locale& __cloc, int __prec = -1)
    {
      __c_locale __old = __gnu_cxx::__uselocale(__cloc);
# 82 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/c++locale.h" 3
      int __ret;

      if (__prec >= 0)
        __ret = snprintf(__out, __size, __fmt, __prec, __v);
      else
        __ret = snprintf(__out, __size, __fmt, __v);
# 96 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/c++locale.h" 3
      __gnu_cxx::__uselocale(__old);




      return __ret;
    }
}
# 47 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/iosfwd" 2 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cctype" 1 3
# 47 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cctype" 3
# 66 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}
# 48 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/iosfwd" 2 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stringfwd.h" 1 3
# 43 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stringfwd.h" 3



namespace std
{
  template<typename _Alloc>
    class allocator;

  template<class _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

  template<> struct char_traits<char>;

  typedef basic_string<char> string;


  template<> struct char_traits<wchar_t>;

  typedef basic_string<wchar_t> wstring;

}
# 49 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/iosfwd" 2 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/fpos.h" 1 3
# 43 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/fpos.h" 3

# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/c++io.h" 1 3
# 35 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/c++io.h" 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cstdio" 1 3
# 48 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cstdio" 3


# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cstddef" 1 3
# 47 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cstddef" 3

# 1 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/stddef.h" 1 3 4
# 151 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/stddef.h" 3 4
typedef int ptrdiff_t;
# 49 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cstddef" 2 3

namespace std
{
  using ::ptrdiff_t;
  using ::size_t;
}
# 51 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cstdio" 2 3

# 1 "/usr/include/stdio.h" 1 3 4
# 30 "/usr/include/stdio.h" 3 4
extern "C" {



# 1 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/stddef.h" 1 3 4
# 35 "/usr/include/stdio.h" 2 3 4
# 44 "/usr/include/stdio.h" 3 4


typedef struct _IO_FILE FILE;





# 62 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 72 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 32 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 14 "/usr/include/_G_config.h" 3 4
# 1 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/stddef.h" 1 3 4
# 354 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 15 "/usr/include/_G_config.h" 2 3 4
# 24 "/usr/include/_G_config.h" 3 4
# 1 "/usr/include/wchar.h" 1 3 4
# 48 "/usr/include/wchar.h" 3 4
# 1 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/stddef.h" 1 3 4
# 49 "/usr/include/wchar.h" 2 3 4

# 1 "/usr/include/bits/wchar.h" 1 3 4
# 51 "/usr/include/wchar.h" 2 3 4
# 76 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 25 "/usr/include/_G_config.h" 2 3 4

typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 44 "/usr/include/_G_config.h" 3 4
# 1 "/usr/include/gconv.h" 1 3 4
# 28 "/usr/include/gconv.h" 3 4
# 1 "/usr/include/wchar.h" 1 3 4
# 48 "/usr/include/wchar.h" 3 4
# 1 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/stddef.h" 1 3 4
# 49 "/usr/include/wchar.h" 2 3 4
# 29 "/usr/include/gconv.h" 2 3 4


# 1 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/stddef.h" 1 3 4
# 32 "/usr/include/gconv.h" 2 3 4





enum
{
  __GCONV_OK = 0,
  __GCONV_NOCONV,
  __GCONV_NODB,
  __GCONV_NOMEM,

  __GCONV_EMPTY_INPUT,
  __GCONV_FULL_OUTPUT,
  __GCONV_ILLEGAL_INPUT,
  __GCONV_INCOMPLETE_INPUT,

  __GCONV_ILLEGAL_DESCRIPTOR,
  __GCONV_INTERNAL_ERROR
};



enum
{
  __GCONV_IS_LAST = 0x0001,
  __GCONV_IGNORE_ERRORS = 0x0002
};



struct __gconv_step;
struct __gconv_step_data;
struct __gconv_loaded_object;
struct __gconv_trans_data;



typedef int (*__gconv_fct) (struct __gconv_step *, struct __gconv_step_data *,
                            __const unsigned char **, __const unsigned char *,
                            unsigned char **, size_t *, int, int);


typedef wint_t (*__gconv_btowc_fct) (struct __gconv_step *, unsigned char);


typedef int (*__gconv_init_fct) (struct __gconv_step *);
typedef void (*__gconv_end_fct) (struct __gconv_step *);



typedef int (*__gconv_trans_fct) (struct __gconv_step *,
                                  struct __gconv_step_data *, void *,
                                  __const unsigned char *,
                                  __const unsigned char **,
                                  __const unsigned char *, unsigned char **,
                                  size_t *);


typedef int (*__gconv_trans_context_fct) (void *, __const unsigned char *,
                                          __const unsigned char *,
                                          unsigned char *, unsigned char *);


typedef int (*__gconv_trans_query_fct) (__const char *, __const char ***,
                                        size_t *);


typedef int (*__gconv_trans_init_fct) (void **, const char *);
typedef void (*__gconv_trans_end_fct) (void *);

struct __gconv_trans_data
{

  __gconv_trans_fct __trans_fct;
  __gconv_trans_context_fct __trans_context_fct;
  __gconv_trans_end_fct __trans_end_fct;
  void *__data;
  struct __gconv_trans_data *__next;
};



struct __gconv_step
{
  struct __gconv_loaded_object *__shlib_handle;
  __const char *__modname;

  int __counter;

  char *__from_name;
  char *__to_name;

  __gconv_fct __fct;
  __gconv_btowc_fct __btowc_fct;
  __gconv_init_fct __init_fct;
  __gconv_end_fct __end_fct;



  int __min_needed_from;
  int __max_needed_from;
  int __min_needed_to;
  int __max_needed_to;


  int __stateful;

  void *__data;
};



struct __gconv_step_data
{
  unsigned char *__outbuf;
  unsigned char *__outbufend;



  int __flags;



  int __invocation_counter;



  int __internal_use;

  __mbstate_t *__statep;
  __mbstate_t __state;



  struct __gconv_trans_data *__trans;
};



typedef struct __gconv_info
{
  size_t __nsteps;
  struct __gconv_step *__steps;
  __extension__ struct __gconv_step_data __data [];
} *__gconv_t;
# 45 "/usr/include/_G_config.h" 2 3 4
typedef union
{
  struct __gconv_info __cd;
  struct
  {
    struct __gconv_info __cd;
    struct __gconv_step_data __data;
  } __combined;
} _G_iconv_t;

typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));
# 33 "/usr/include/libio.h" 2 3 4
# 53 "/usr/include/libio.h" 3 4
# 1 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/stdarg.h" 1 3 4
# 43 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 54 "/usr/include/libio.h" 2 3 4
# 166 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 176 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 199 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};




struct _IO_codecvt
{
  void (*__codecvt_destr) (struct _IO_codecvt *);
  enum __codecvt_result (*__codecvt_do_out) (struct _IO_codecvt *,
                                             __mbstate_t *,
                                             const wchar_t *,
                                             const wchar_t *,
                                             const wchar_t **, char *,
                                             char *, char **);
  enum __codecvt_result (*__codecvt_do_unshift) (struct _IO_codecvt *,
                                                 __mbstate_t *, char *,
                                                 char *, char **);
  enum __codecvt_result (*__codecvt_do_in) (struct _IO_codecvt *,
                                            __mbstate_t *,
                                            const char *, const char *,
                                            const char **, wchar_t *,
                                            wchar_t *, wchar_t **);
  int (*__codecvt_do_encoding) (struct _IO_codecvt *);
  int (*__codecvt_do_always_noconv) (struct _IO_codecvt *);
  int (*__codecvt_do_length) (struct _IO_codecvt *, __mbstate_t *,
                              const char *, const char *, size_t);
  int (*__codecvt_do_max_length) (struct _IO_codecvt *);

  _G_iconv_t __cd_in;
  _G_iconv_t __cd_out;
};


struct _IO_wide_data
{
  wchar_t *_IO_read_ptr;
  wchar_t *_IO_read_end;
  wchar_t *_IO_read_base;
  wchar_t *_IO_write_base;
  wchar_t *_IO_write_ptr;
  wchar_t *_IO_write_end;
  wchar_t *_IO_buf_base;
  wchar_t *_IO_buf_end;

  wchar_t *_IO_save_base;
  wchar_t *_IO_backup_base;

  wchar_t *_IO_save_end;

  __mbstate_t _IO_state;
  __mbstate_t _IO_last_state;
  struct _IO_codecvt _codecvt;

  wchar_t _shortbuf[1];

  const struct _IO_jump_t *_wide_vtable;
};


struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 315 "/usr/include/libio.h" 3 4
  __off64_t _offset;


  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t _freeres_size;







  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};





struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 360 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, __const char *__buf,
                                 size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
                             void *__cookie, _IO_cookie_io_functions_t __fns);




extern "C" {


extern int __underflow (_IO_FILE *) throw ();
extern int __uflow (_IO_FILE *) throw ();
extern int __overflow (_IO_FILE *, int) throw ();
extern wint_t __wunderflow (_IO_FILE *) throw ();
extern wint_t __wuflow (_IO_FILE *) throw ();
extern wint_t __woverflow (_IO_FILE *, wint_t) throw ();
# 450 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp) throw ();
extern int _IO_putc (int __c, _IO_FILE *__fp) throw ();
extern int _IO_feof (_IO_FILE *__fp) throw ();
extern int _IO_ferror (_IO_FILE *__fp) throw ();

extern int _IO_peekc_locked (_IO_FILE *__fp) throw ();





extern void _IO_flockfile (_IO_FILE *) throw ();
extern void _IO_funlockfile (_IO_FILE *) throw ();
extern int _IO_ftrylockfile (_IO_FILE *) throw ();
# 480 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
                        __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
                         __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t) throw ();
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t) throw ();

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int) throw ();
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int) throw ();

extern void _IO_free_backup_area (_IO_FILE *) throw ();


extern wint_t _IO_getwc (_IO_FILE *__fp) throw ();
extern wint_t _IO_putwc (wchar_t __wc, _IO_FILE *__fp) throw ();
extern int _IO_fwide (_IO_FILE *__fp, int __mode) throw ();
# 529 "/usr/include/libio.h" 3 4
extern int _IO_vfwscanf (_IO_FILE * __restrict, const wchar_t * __restrict,
                         __gnuc_va_list, int *__restrict);
extern int _IO_vfwprintf (_IO_FILE *__restrict, const wchar_t *__restrict,
                          __gnuc_va_list);
extern __ssize_t _IO_wpadn (_IO_FILE *, wint_t, __ssize_t) throw ();
extern void _IO_free_wbackup_area (_IO_FILE *) throw ();



}
# 73 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 86 "/usr/include/stdio.h" 3 4


typedef _G_fpos_t fpos_t;





typedef _G_fpos64_t fpos64_t;
# 138 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 139 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;









extern int remove (__const char *__filename) throw ();

extern int rename (__const char *__old, __const char *__new) throw ();









extern FILE *tmpfile (void);
# 176 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void);



extern char *tmpnam (char *__s) throw ();





extern char *tmpnam_r (char *__s) throw ();
# 198 "/usr/include/stdio.h" 3 4
extern char *tempnam (__const char *__dir, __const char *__pfx)
     throw () __attribute__ ((__malloc__));








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 223 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 233 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);









extern FILE *fopen (__const char *__restrict __filename,
                    __const char *__restrict __modes);




extern FILE *freopen (__const char *__restrict __filename,
                      __const char *__restrict __modes,
                      FILE *__restrict __stream);
# 264 "/usr/include/stdio.h" 3 4


extern FILE *fopen64 (__const char *__restrict __filename,
                      __const char *__restrict __modes);
extern FILE *freopen64 (__const char *__restrict __filename,
                        __const char *__restrict __modes,
                        FILE *__restrict __stream);




extern FILE *fdopen (int __fd, __const char *__modes) throw ();





extern FILE *fopencookie (void *__restrict __magic_cookie,
                          __const char *__restrict __modes,
                          _IO_cookie_io_functions_t __io_funcs) throw ();


extern FILE *fmemopen (void *__s, size_t __len, __const char *__modes) throw ();




extern FILE *open_memstream (char **__restrict __bufloc,
                             size_t *__restrict __sizeloc) throw ();






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
                    int __modes, size_t __n) throw ();





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
                       size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();








extern int fprintf (FILE *__restrict __stream,
                    __const char *__restrict __format, ...);




extern int printf (__const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
                    __const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, __const char *__restrict __format,
                     __gnuc_va_list __arg);




extern int vprintf (__const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, __const char *__restrict __format,
                     __gnuc_va_list __arg) throw ();





extern int snprintf (char *__restrict __s, size_t __maxlen,
                     __const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
                      __const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, __const char *__restrict __f,
                      __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));
extern int __asprintf (char **__restrict __ptr,
                       __const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int asprintf (char **__restrict __ptr,
                     __const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));







extern int vdprintf (int __fd, __const char *__restrict __fmt,
                     __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, __const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
                   __const char *__restrict __format, ...);




extern int scanf (__const char *__restrict __format, ...);

extern int sscanf (__const char *__restrict __s,
                   __const char *__restrict __format, ...) throw ();








extern int vfscanf (FILE *__restrict __s, __const char *__restrict __format,
                    __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0)));





extern int vscanf (__const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0)));


extern int vsscanf (__const char *__restrict __s,
                    __const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 456 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 467 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 500 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream);






extern char *gets (char *__s);

# 545 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
                             FILE *__restrict __stream);
# 561 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                               size_t *__restrict __n, int __delimiter,
                               FILE *__restrict __stream);
extern __ssize_t getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream);







extern __ssize_t getline (char **__restrict __lineptr,
                            size_t *__restrict __n,
                            FILE *__restrict __stream);








extern int fputs (__const char *__restrict __s, FILE *__restrict __stream);





extern int puts (__const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
                     size_t __n, FILE *__restrict __stream);




extern size_t fwrite (__const void *__restrict __ptr, size_t __size,
                      size_t __n, FILE *__restrict __s);

# 622 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (__const char *__restrict __s,
                           FILE *__restrict __stream);
# 633 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
                              size_t __n, FILE *__restrict __stream);
extern size_t fwrite_unlocked (__const void *__restrict __ptr, size_t __size,
                               size_t __n, FILE *__restrict __stream);








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream);




extern void rewind (FILE *__stream);

# 669 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream);
# 688 "/usr/include/stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, __const fpos_t *__pos);
# 711 "/usr/include/stdio.h" 3 4



extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream);
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, __const fpos64_t *__pos);




extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw ();

extern int ferror (FILE *__stream) throw ();




extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw ();
extern int ferror_unlocked (FILE *__stream) throw ();








extern void perror (__const char *__s);






# 1 "/usr/include/bits/sys_errlist.h" 1 3 4
# 27 "/usr/include/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern __const char *__const sys_errlist[];


extern int _sys_nerr;
extern __const char *__const _sys_errlist[];
# 750 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) throw ();




extern int fileno_unlocked (FILE *__stream) throw ();
# 769 "/usr/include/stdio.h" 3 4
extern FILE *popen (__const char *__command, __const char *__modes);





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
                           __const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
                            __const char *__restrict __format,
                            __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw ();


extern void funlockfile (FILE *__stream) throw ();
# 836 "/usr/include/stdio.h" 3 4
}
# 53 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cstdio" 2 3
# 97 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
  using ::gets;
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
  using ::tmpnam;
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
# 153 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cstdio" 3
namespace __gnu_cxx
{
# 167 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using __gnu_cxx::snprintf;
  using __gnu_cxx::vfscanf;
  using __gnu_cxx::vscanf;
  using __gnu_cxx::vsnprintf;
  using __gnu_cxx::vsscanf;
}
# 36 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/c++io.h" 2 3

# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/gthr.h" 1 3
# 98 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/gthr.h" 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/gthr-default.h" 1 3
# 37 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/gthr-default.h" 3
# 1 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/pthread.h" 1 3 4
# 29 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 29 "/usr/include/sched.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 118 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    long int tv_nsec;
  };
# 30 "/usr/include/sched.h" 2 3 4


# 1 "/usr/include/bits/sched.h" 1 3 4
# 62 "/usr/include/bits/sched.h" 3 4
struct sched_param
  {
    int __sched_priority;
  };

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
                  int __flags, void *__arg) throw ();


}







struct __sched_param
  {
    int __sched_priority;
  };
# 98 "/usr/include/bits/sched.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 33 "/usr/include/sched.h" 2 3 4




extern "C" {


extern int sched_setparam (__pid_t __pid, __const struct sched_param *__param)
     throw ();


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();


extern int sched_setscheduler (__pid_t __pid, int __policy,
                               __const struct sched_param *__param) throw ();


extern int sched_getscheduler (__pid_t __pid) throw ();


extern int sched_yield (void) throw ();


extern int sched_get_priority_max (int __algorithm) throw ();


extern int sched_get_priority_min (int __algorithm) throw ();


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();
# 76 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
                              __const cpu_set_t *__cpuset) throw ();


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
                              cpu_set_t *__cpuset) throw ();


}
# 30 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/pthread.h" 2 3 4
# 1 "/usr/include/time.h" 1 3 4
# 30 "/usr/include/time.h" 3 4
extern "C" {







# 1 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/stddef.h" 1 3 4
# 39 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/bits/time.h" 1 3 4
# 43 "/usr/include/time.h" 2 3 4
# 58 "/usr/include/time.h" 3 4


typedef __clock_t clock_t;



# 74 "/usr/include/time.h" 3 4


typedef __time_t time_t;



# 92 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 104 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 129 "/usr/include/time.h" 3 4


struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  __const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;





typedef __pid_t pid_t;








extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
                        __const char *__restrict __format,
                        __const struct tm *__restrict __tp) throw ();





extern char *strptime (__const char *__restrict __s,
                       __const char *__restrict __fmt, struct tm *__tp)
     throw ();







extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
                          __const char *__restrict __format,
                          __const struct tm *__restrict __tp,
                          __locale_t __loc) throw ();

extern char *strptime_l (__const char *__restrict __s,
                         __const char *__restrict __fmt, struct tm *__tp,
                         __locale_t __loc) throw ();






extern struct tm *gmtime (__const time_t *__timer) throw ();



extern struct tm *localtime (__const time_t *__timer) throw ();





extern struct tm *gmtime_r (__const time_t *__restrict __timer,
                            struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (__const time_t *__restrict __timer,
                               struct tm *__restrict __tp) throw ();





extern char *asctime (__const struct tm *__tp) throw ();


extern char *ctime (__const time_t *__timer) throw ();







extern char *asctime_r (__const struct tm *__restrict __tp,
                        char *__restrict __buf) throw ();


extern char *ctime_r (__const time_t *__restrict __timer,
                      char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;





extern int stime (__const time_t *__when) throw ();
# 309 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
# 324 "/usr/include/time.h" 3 4
extern int nanosleep (__const struct timespec *__requested_time,
                      struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, __const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
                            __const struct timespec *__req,
                            struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
                         struct sigevent *__restrict __evp,
                         timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
                          __const struct itimerspec *__restrict __value,
                          struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();
# 386 "/usr/include/time.h" 3 4
extern int getdate_err;
# 395 "/usr/include/time.h" 3 4
extern struct tm *getdate (__const char *__string);
# 409 "/usr/include/time.h" 3 4
extern int getdate_r (__const char *__restrict __string,
                      struct tm *__restrict __resbufp);


}
# 31 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/pthread.h" 2 3 4


# 1 "/usr/include/signal.h" 1 3 4
# 31 "/usr/include/signal.h" 3 4
extern "C" {

# 1 "/usr/include/bits/sigset.h" 1 3 4
# 23 "/usr/include/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 34 "/usr/include/signal.h" 2 3 4
# 50 "/usr/include/signal.h" 3 4
typedef __sigset_t sigset_t;
# 400 "/usr/include/signal.h" 3 4
}
# 34 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/bits/sched.h" 1 3 4
# 24 "/usr/include/bits/pthreadtypes.h" 2 3 4


struct _pthread_fastlock
{
  long int __status;
  int __spinlock;

};



typedef struct _pthread_descr_struct *_pthread_descr;





typedef struct __pthread_attr_s
{
  int __detachstate;
  int __schedpolicy;
  struct __sched_param __schedparam;
  int __inheritsched;
  int __scope;
  size_t __guardsize;
  int __stackaddr_set;
  void *__stackaddr;
  size_t __stacksize;
} pthread_attr_t;





__extension__ typedef long long __pthread_cond_align_t;




typedef struct
{
  struct _pthread_fastlock __c_lock;
  _pthread_descr __c_waiting;
  char __padding[48 - sizeof (struct _pthread_fastlock)
                 - sizeof (_pthread_descr) - sizeof (__pthread_cond_align_t)];
  __pthread_cond_align_t __align;
} pthread_cond_t;



typedef struct
{
  int __dummy;
} pthread_condattr_t;


typedef unsigned int pthread_key_t;





typedef struct
{
  int __m_reserved;
  int __m_count;
  _pthread_descr __m_owner;
  int __m_kind;
  struct _pthread_fastlock __m_lock;
} pthread_mutex_t;



typedef struct
{
  int __mutexkind;
} pthread_mutexattr_t;



typedef int pthread_once_t;




typedef struct _pthread_rwlock_t
{
  struct _pthread_fastlock __rw_lock;
  int __rw_readers;
  _pthread_descr __rw_writer;
  _pthread_descr __rw_read_waiting;
  _pthread_descr __rw_write_waiting;
  int __rw_kind;
  int __rw_pshared;
} pthread_rwlock_t;



typedef struct
{
  int __lockkind;
  int __pshared;
} pthread_rwlockattr_t;




typedef volatile int pthread_spinlock_t;


typedef struct {
  struct _pthread_fastlock __ba_lock;
  int __ba_required;
  int __ba_present;
  _pthread_descr __ba_waiting;
} pthread_barrier_t;


typedef struct {
  int __pshared;
} pthread_barrierattr_t;





typedef unsigned long int pthread_t;
# 35 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/initspin.h" 1 3 4
# 36 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/pthread.h" 2 3 4


extern "C" {
# 68 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/pthread.h" 3 4
enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};

enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};

enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};

enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_ADAPTIVE_NP

};

enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};


enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_WRITER_NP
};
# 140 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};



enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 172 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/pthread.h" 3 4
extern int pthread_create (pthread_t *__restrict __thr,
                           __const pthread_attr_t *__restrict __attr,
                           void *(*__start_routine) (void *),
                           void *__restrict __arg) throw ();


extern pthread_t pthread_self (void) throw ();


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2) throw ();


extern void pthread_exit (void *__retval)
     throw () __attribute__ ((__noreturn__));




extern int pthread_join (pthread_t __th, void **__thread_return) throw ();





extern int pthread_detach (pthread_t __th) throw ();







extern int pthread_attr_init (pthread_attr_t *__attr) throw ();


extern int pthread_attr_destroy (pthread_attr_t *__attr) throw ();


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
                                        int __detachstate) throw ();


extern int pthread_attr_getdetachstate (__const pthread_attr_t *__attr,
                                        int *__detachstate) throw ();


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
                                       __const struct sched_param *__restrict
                                       __param) throw ();


extern int pthread_attr_getschedparam (__const pthread_attr_t *__restrict
                                       __attr,
                                       struct sched_param *__restrict __param)
     throw ();


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     throw ();


extern int pthread_attr_getschedpolicy (__const pthread_attr_t *__restrict
                                        __attr, int *__restrict __policy)
     throw ();


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
                                         int __inherit) throw ();


extern int pthread_attr_getinheritsched (__const pthread_attr_t *__restrict
                                         __attr, int *__restrict __inherit)
     throw ();


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     throw ();


extern int pthread_attr_getscope (__const pthread_attr_t *__restrict __attr,
                                  int *__restrict __scope) throw ();



extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
                                      size_t __guardsize) throw ();


extern int pthread_attr_getguardsize (__const pthread_attr_t *__restrict
                                      __attr, size_t *__restrict __guardsize)
     throw ();






extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
                                      void *__stackaddr) throw ();


extern int pthread_attr_getstackaddr (__const pthread_attr_t *__restrict
                                      __attr, void **__restrict __stackaddr)
     throw ();





extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
                                  size_t __stacksize) throw ();


extern int pthread_attr_getstack (__const pthread_attr_t *__restrict __attr,
                                  void **__restrict __stackaddr,
                                  size_t *__restrict __stacksize) throw ();





extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
                                      size_t __stacksize) throw ();


extern int pthread_attr_getstacksize (__const pthread_attr_t *__restrict
                                      __attr, size_t *__restrict __stacksize)
     throw ();



extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr) throw ();






extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
                                  __const struct sched_param *__param)
     throw ();


extern int pthread_getschedparam (pthread_t __target_thread,
                                  int *__restrict __policy,
                                  struct sched_param *__restrict __param)
     throw ();



extern int pthread_getconcurrency (void) throw ();


extern int pthread_setconcurrency (int __level) throw ();







extern int pthread_yield (void) throw ();






extern int pthread_mutex_init (pthread_mutex_t *__restrict __mutex,
                               __const pthread_mutexattr_t *__restrict
                               __mutex_attr) throw ();


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex) throw ();


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex) throw ();


extern int pthread_mutex_lock (pthread_mutex_t *__mutex) throw ();



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
                                    __const struct timespec *__restrict
                                    __abstime) throw ();



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex) throw ();






extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr) throw ();


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr) throw ();


extern int pthread_mutexattr_getpshared (__const pthread_mutexattr_t *
                                         __restrict __attr,
                                         int *__restrict __pshared) throw ();


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
                                         int __pshared) throw ();





extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     throw ();


extern int pthread_mutexattr_gettype (__const pthread_mutexattr_t *__restrict
                                      __attr, int *__restrict __kind) throw ();







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
                              __const pthread_condattr_t *__restrict
                              __cond_attr) throw ();


extern int pthread_cond_destroy (pthread_cond_t *__cond) throw ();


extern int pthread_cond_signal (pthread_cond_t *__cond) throw ();


extern int pthread_cond_broadcast (pthread_cond_t *__cond) throw ();



extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
                              pthread_mutex_t *__restrict __mutex) throw ();





extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
                                   pthread_mutex_t *__restrict __mutex,
                                   __const struct timespec *__restrict
                                   __abstime) throw ();




extern int pthread_condattr_init (pthread_condattr_t *__attr) throw ();


extern int pthread_condattr_destroy (pthread_condattr_t *__attr) throw ();


extern int pthread_condattr_getpshared (__const pthread_condattr_t *
                                        __restrict __attr,
                                        int *__restrict __pshared) throw ();


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
                                        int __pshared) throw ();







extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
                                __const pthread_rwlockattr_t *__restrict
                                __attr) throw ();


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock) throw ();


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock) throw ();


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock) throw ();



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
                                       __const struct timespec *__restrict
                                       __abstime) throw ();



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock) throw ();


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock) throw ();



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
                                       __const struct timespec *__restrict
                                       __abstime) throw ();



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock) throw ();





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr) throw ();


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr) throw ();


extern int pthread_rwlockattr_getpshared (__const pthread_rwlockattr_t *
                                          __restrict __attr,
                                          int *__restrict __pshared) throw ();


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
                                          int __pshared) throw ();


extern int pthread_rwlockattr_getkind_np (__const pthread_rwlockattr_t *__attr,
                                          int *__pref) throw ();


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
                                          int __pref) throw ();
# 518 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     throw ();


extern int pthread_spin_destroy (pthread_spinlock_t *__lock) throw ();


extern int pthread_spin_lock (pthread_spinlock_t *__lock) throw ();


extern int pthread_spin_trylock (pthread_spinlock_t *__lock) throw ();


extern int pthread_spin_unlock (pthread_spinlock_t *__lock) throw ();




extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
                                 __const pthread_barrierattr_t *__restrict
                                 __attr, unsigned int __count) throw ();

extern int pthread_barrier_destroy (pthread_barrier_t *__barrier) throw ();

extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr) throw ();

extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr) throw ();

extern int pthread_barrierattr_getpshared (__const pthread_barrierattr_t *
                                           __restrict __attr,
                                           int *__restrict __pshared) throw ();

extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
                                           int __pshared) throw ();

extern int pthread_barrier_wait (pthread_barrier_t *__barrier) throw ();
# 565 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
                               void (*__destr_function) (void *)) throw ();


extern int pthread_key_delete (pthread_key_t __key) throw ();


extern int pthread_setspecific (pthread_key_t __key,
                                __const void *__pointer) throw ();


extern void *pthread_getspecific (pthread_key_t __key) throw ();
# 585 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
                         void (*__init_routine) (void)) throw ();






extern int pthread_setcancelstate (int __state, int *__oldstate) throw ();



extern int pthread_setcanceltype (int __type, int *__oldtype) throw ();


extern int pthread_cancel (pthread_t __thr) throw ();




extern void pthread_testcancel (void) throw ();
# 619 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/pthread.h" 3 4
extern void _pthread_cleanup_push (struct _pthread_cleanup_buffer *__buffer,
                                   void (*__routine) (void *),
                                   void *__arg) throw ();







extern void _pthread_cleanup_pop (struct _pthread_cleanup_buffer *__buffer,
                                  int __execute) throw ();
# 640 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/pthread.h" 3 4
extern void _pthread_cleanup_push_defer (struct _pthread_cleanup_buffer *__buffer,
                                         void (*__routine) (void *),
                                         void *__arg) throw ();
# 651 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/pthread.h" 3 4
extern void _pthread_cleanup_pop_restore (struct _pthread_cleanup_buffer *__buffer,
                                          int __execute) throw ();





extern int pthread_getcpuclockid (pthread_t __thread_id,
                                  clockid_t *__clock_id) throw ();




# 1 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/bits/sigthread.h" 1 3 4
# 40 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/bits/sigthread.h" 3 4
extern int pthread_sigmask (int __how,
                            __const __sigset_t *__restrict __newmask,
                            __sigset_t *__restrict __oldmask)throw ();


extern int pthread_kill (pthread_t __thr, int __signo) throw ();
# 665 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/pthread.h" 2 3 4
# 680 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
                           void (*__parent) (void),
                           void (*__child) (void)) throw ();




extern void pthread_kill_other_threads_np (void) throw ();

}
# 38 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/gthr-default.h" 2 3
# 1 "/usr/include/unistd.h" 1 3 4
# 28 "/usr/include/unistd.h" 3 4
extern "C" {
# 171 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/bits/posix_opt.h" 1 3 4
# 172 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/bits/environments.h" 1 3 4
# 176 "/usr/include/unistd.h" 2 3 4
# 189 "/usr/include/unistd.h" 3 4
typedef __ssize_t ssize_t;





# 1 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/stddef.h" 1 3 4
# 196 "/usr/include/unistd.h" 2 3 4





typedef __gid_t gid_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __useconds_t useconds_t;
# 236 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
# 256 "/usr/include/unistd.h" 3 4
extern int access (__const char *__name, int __type) throw () __attribute__ ((__nonnull__ (1)));




extern int euidaccess (__const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));
# 287 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) throw ();
# 298 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence) throw ();






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes);





extern ssize_t write (int __fd, __const void *__buf, size_t __n);
# 328 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
                      __off_t __offset);






extern ssize_t pwrite (int __fd, __const void *__buf, size_t __n,
                       __off_t __offset);
# 356 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
                        __off64_t __offset);


extern ssize_t pwrite64 (int __fd, __const void *__buf, size_t __n,
                         __off64_t __offset);







extern int pipe (int __pipedes[2]) throw ();
# 378 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) throw ();
# 390 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);






extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     throw ();






extern int usleep (__useconds_t __useconds);
# 414 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (__const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1)));



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) throw ();




extern int lchown (__const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1)));




extern int chdir (__const char *__path) throw () __attribute__ ((__nonnull__ (1)));



extern int fchdir (int __fd) throw ();
# 448 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) throw ();





extern char *get_current_dir_name (void) throw ();






extern char *getwd (char *__buf) throw () __attribute__ ((__nonnull__ (1)));




extern int dup (int __fd) throw ();


extern int dup2 (int __fd, int __fd2) throw ();


extern char **__environ;

extern char **environ;





extern int execve (__const char *__path, char *__const __argv[],
                   char *__const __envp[]) throw () __attribute__ ((__nonnull__ (1)));




extern int fexecve (int __fd, char *__const __argv[], char *__const __envp[])
     throw ();




extern int execv (__const char *__path, char *__const __argv[])
     throw () __attribute__ ((__nonnull__ (1)));



extern int execle (__const char *__path, __const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1)));



extern int execl (__const char *__path, __const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1)));



extern int execvp (__const char *__file, char *__const __argv[])
     throw () __attribute__ ((__nonnull__ (1)));




extern int execlp (__const char *__file, __const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1)));




extern int nice (int __inc) throw ();




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/bits/confname.h" 1 3 4
# 26 "/usr/include/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,


    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS

  };
# 531 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (__const char *__path, int __name)
     throw () __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) throw ();


extern long int sysconf (int __name) throw () __attribute__ ((__const__));



extern size_t confstr (int __name, char *__buf, size_t __len) throw ();




extern __pid_t getpid (void) throw ();


extern __pid_t getppid (void) throw ();




extern __pid_t getpgrp (void) throw ();
# 567 "/usr/include/unistd.h" 3 4
extern __pid_t __getpgid (__pid_t __pid) throw ();

extern __pid_t getpgid (__pid_t __pid) throw ();






extern int setpgid (__pid_t __pid, __pid_t __pgid) throw ();
# 593 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) throw ();
# 610 "/usr/include/unistd.h" 3 4
extern __pid_t setsid (void) throw ();



extern __pid_t getsid (__pid_t __pid) throw ();



extern __uid_t getuid (void) throw ();


extern __uid_t geteuid (void) throw ();


extern __gid_t getgid (void) throw ();


extern __gid_t getegid (void) throw ();




extern int getgroups (int __size, __gid_t __list[]) throw ();



extern int group_member (__gid_t __gid) throw ();






extern int setuid (__uid_t __uid) throw ();




extern int setreuid (__uid_t __ruid, __uid_t __euid) throw ();




extern int seteuid (__uid_t __uid) throw ();






extern int setgid (__gid_t __gid) throw ();




extern int setregid (__gid_t __rgid, __gid_t __egid) throw ();




extern int setegid (__gid_t __gid) throw ();





extern int getresuid (__uid_t *__euid, __uid_t *__ruid, __uid_t *__suid);



extern int getresgid (__gid_t *__egid, __gid_t *__rgid, __gid_t *__sgid);



extern int setresuid (__uid_t __euid, __uid_t __ruid, __uid_t __suid);



extern int setresgid (__gid_t __egid, __gid_t __rgid, __gid_t __sgid);






extern __pid_t fork (void) throw ();






extern __pid_t vfork (void) throw ();





extern char *ttyname (int __fd) throw ();



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));



extern int isatty (int __fd) throw ();





extern int ttyslot (void) throw ();




extern int link (__const char *__from, __const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int symlink (__const char *__from, __const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int readlink (__const char *__restrict __path, char *__restrict __buf,
                     size_t __len) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int unlink (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));


extern int rmdir (__const char *__path) throw () __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) throw ();


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) throw ();






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));
# 783 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/getopt.h" 1 3 4
# 50 "/usr/include/getopt.h" 3 4
extern "C" {
# 59 "/usr/include/getopt.h" 3 4
extern char *optarg;
# 73 "/usr/include/getopt.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 152 "/usr/include/getopt.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       throw ();
# 171 "/usr/include/getopt.h" 3 4
}
# 784 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) throw () __attribute__ ((__nonnull__ (1)));






extern int sethostname (__const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1)));



extern int sethostid (long int __id) throw ();





extern int getdomainname (char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1)));
extern int setdomainname (__const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1)));





extern int vhangup (void) throw ();


extern int revoke (__const char *__file) throw () __attribute__ ((__nonnull__ (1)));







extern int profil (unsigned short int *__sample_buffer, size_t __size,
                   size_t __offset, unsigned int __scale)
     throw () __attribute__ ((__nonnull__ (1)));





extern int acct (__const char *__name) throw ();



extern char *getusershell (void) throw ();
extern void endusershell (void) throw ();
extern void setusershell (void) throw ();





extern int daemon (int __nochdir, int __noclose) throw ();






extern int chroot (__const char *__path) throw () __attribute__ ((__nonnull__ (1)));



extern char *getpass (__const char *__prompt) __attribute__ ((__nonnull__ (1)));
# 869 "/usr/include/unistd.h" 3 4
extern int fsync (int __fd);






extern long int gethostid (void);


extern void sync (void) throw ();




extern int getpagesize (void) throw () __attribute__ ((__const__));




extern int getdtablesize (void) throw ();




extern int truncate (__const char *__file, __off_t __length)
     throw () __attribute__ ((__nonnull__ (1)));
# 906 "/usr/include/unistd.h" 3 4
extern int truncate64 (__const char *__file, __off64_t __length)
     throw () __attribute__ ((__nonnull__ (1)));
# 916 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) throw ();
# 926 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) throw ();
# 936 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) throw ();





extern void *sbrk (intptr_t __delta) throw ();
# 957 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) throw ();
# 980 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len);
# 990 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len);
# 1011 "/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes) throw ();







extern char *crypt (__const char *__key, __const char *__salt)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern void encrypt (char *__block, int __edflag) throw () __attribute__ ((__nonnull__ (1)));






extern void swab (__const void *__restrict __from, void *__restrict __to,
                  ssize_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));







extern char *ctermid (char *__s) throw ();


}
# 39 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/gthr-default.h" 2 3

typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;






#pragma weak pthread_once
#pragma weak pthread_key_create
#pragma weak pthread_key_delete
#pragma weak pthread_getspecific
#pragma weak pthread_setspecific
#pragma weak pthread_create

#pragma weak pthread_mutex_lock
#pragma weak pthread_mutex_trylock
#pragma weak pthread_mutex_unlock
# 87 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  static void *const __gthread_active_ptr = (void *) &pthread_create;
  return __gthread_active_ptr != 0;
}
# 449 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_once (__gthread_once_t *once, void (*func) (void))
{
  if (__gthread_active_p ())
    return pthread_once (once, func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))
{
  return pthread_key_create (key, dtor);
}

static inline int
__gthread_key_dtor (__gthread_key_t key, void *ptr)
{

  if (ptr)
    return pthread_setspecific (key, 0);
  else
    return 0;
}

static inline int
__gthread_key_delete (__gthread_key_t key)
{
  return pthread_key_delete (key);
}

static inline void *
__gthread_getspecific (__gthread_key_t key)
{
  return pthread_getspecific (key);
}

static inline int
__gthread_setspecific (__gthread_key_t key, const void *ptr)
{
  return pthread_setspecific (key, ptr);
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_lock (mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_trylock (mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_unlock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_unlock (mutex);
  else
    return 0;
}
# 99 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/gthr.h" 2 3
# 38 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/c++io.h" 2 3

namespace std
{

  typedef long streamoff;
  typedef ptrdiff_t streamsize;

  typedef ptrdiff_t wstreamsize;

  typedef fpos_t __c_streampos;

  typedef __gthread_mutex_t __c_lock;


  typedef FILE __c_file;


  struct __ios_flags
  {
    typedef short __int_type;

    static const __int_type _S_boolalpha = 0x0001;
    static const __int_type _S_dec = 0x0002;
    static const __int_type _S_fixed = 0x0004;
    static const __int_type _S_hex = 0x0008;
    static const __int_type _S_internal = 0x0010;
    static const __int_type _S_left = 0x0020;
    static const __int_type _S_oct = 0x0040;
    static const __int_type _S_right = 0x0080;
    static const __int_type _S_scientific = 0x0100;
    static const __int_type _S_showbase = 0x0200;
    static const __int_type _S_showpoint = 0x0400;
    static const __int_type _S_showpos = 0x0800;
    static const __int_type _S_skipws = 0x1000;
    static const __int_type _S_unitbuf = 0x2000;
    static const __int_type _S_uppercase = 0x4000;
    static const __int_type _S_adjustfield = 0x0020 | 0x0080 | 0x0010;
    static const __int_type _S_basefield = 0x0002 | 0x0040 | 0x0008;
    static const __int_type _S_floatfield = 0x0100 | 0x0004;


    static const __int_type _S_badbit = 0x01;
    static const __int_type _S_eofbit = 0x02;
    static const __int_type _S_failbit = 0x04;


    static const __int_type _S_app = 0x01;
    static const __int_type _S_ate = 0x02;
    static const __int_type _S_bin = 0x04;
    static const __int_type _S_in = 0x08;
    static const __int_type _S_out = 0x10;
    static const __int_type _S_trunc = 0x20;
  };
}
# 45 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/fpos.h" 2 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cwchar" 1 3
# 48 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cwchar" 3



# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ctime" 1 3
# 48 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ctime" 3
# 64 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ctime" 3
namespace std
{
  using ::clock_t;
  using ::time_t;
  using ::tm;

  using ::clock;
  using ::difftime;
  using ::mktime;
  using ::time;
  using ::asctime;
  using ::ctime;
  using ::gmtime;
  using ::localtime;
  using ::strftime;
}
# 52 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cwchar" 2 3


# 1 "/usr/include/wchar.h" 1 3 4
# 40 "/usr/include/wchar.h" 3 4
# 1 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/stdarg.h" 1 3 4
# 41 "/usr/include/wchar.h" 2 3 4







# 1 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/stddef.h" 1 3 4
# 49 "/usr/include/wchar.h" 2 3 4
# 93 "/usr/include/wchar.h" 3 4


typedef __mbstate_t mbstate_t;



# 118 "/usr/include/wchar.h" 3 4
extern "C" {




struct tm;









extern wchar_t *wcscpy (wchar_t *__restrict __dest,
                        __const wchar_t *__restrict __src) throw ();

extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
                         __const wchar_t *__restrict __src, size_t __n)
     throw ();


extern wchar_t *wcscat (wchar_t *__restrict __dest,
                        __const wchar_t *__restrict __src) throw ();

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
                         __const wchar_t *__restrict __src, size_t __n)
     throw ();


extern int wcscmp (__const wchar_t *__s1, __const wchar_t *__s2)
     throw () __attribute__ ((__pure__));

extern int wcsncmp (__const wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));




extern int wcscasecmp (__const wchar_t *__s1, __const wchar_t *__s2) throw ();


extern int wcsncasecmp (__const wchar_t *__s1, __const wchar_t *__s2,
                        size_t __n) throw ();





extern int wcscasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
                         __locale_t __loc) throw ();

extern int wcsncasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
                          size_t __n, __locale_t __loc) throw ();





extern int wcscoll (__const wchar_t *__s1, __const wchar_t *__s2) throw ();



extern size_t wcsxfrm (wchar_t *__restrict __s1,
                       __const wchar_t *__restrict __s2, size_t __n) throw ();








extern int wcscoll_l (__const wchar_t *__s1, __const wchar_t *__s2,
                      __locale_t __loc) throw ();




extern size_t wcsxfrm_l (wchar_t *__s1, __const wchar_t *__s2,
                         size_t __n, __locale_t __loc) throw ();


extern wchar_t *wcsdup (__const wchar_t *__s) throw () __attribute__ ((__malloc__));




extern wchar_t *wcschr (__const wchar_t *__wcs, wchar_t __wc)
     throw () __attribute__ ((__pure__));

extern wchar_t *wcsrchr (__const wchar_t *__wcs, wchar_t __wc)
     throw () __attribute__ ((__pure__));





extern wchar_t *wcschrnul (__const wchar_t *__s, wchar_t __wc)
     throw () __attribute__ ((__pure__));





extern size_t wcscspn (__const wchar_t *__wcs, __const wchar_t *__reject)
     throw () __attribute__ ((__pure__));


extern size_t wcsspn (__const wchar_t *__wcs, __const wchar_t *__accept)
     throw () __attribute__ ((__pure__));

extern wchar_t *wcspbrk (__const wchar_t *__wcs, __const wchar_t *__accept)
     throw () __attribute__ ((__pure__));

extern wchar_t *wcsstr (__const wchar_t *__haystack, __const wchar_t *__needle)
     throw () __attribute__ ((__pure__));


extern wchar_t *wcstok (wchar_t *__restrict __s,
                        __const wchar_t *__restrict __delim,
                        wchar_t **__restrict __ptr) throw ();


extern size_t wcslen (__const wchar_t *__s) throw () __attribute__ ((__pure__));




extern wchar_t *wcswcs (__const wchar_t *__haystack, __const wchar_t *__needle)
     throw () __attribute__ ((__pure__));




extern size_t wcsnlen (__const wchar_t *__s, size_t __maxlen)
     throw () __attribute__ ((__pure__));





extern wchar_t *wmemchr (__const wchar_t *__s, wchar_t __c, size_t __n)
     throw () __attribute__ ((__pure__));


extern int wmemcmp (__const wchar_t *__restrict __s1,
                    __const wchar_t *__restrict __s2, size_t __n)
     throw () __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
                         __const wchar_t *__restrict __s2, size_t __n) throw ();



extern wchar_t *wmemmove (wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     throw ();


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();





extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
                          __const wchar_t *__restrict __s2, size_t __n)
     throw ();






extern wint_t btowc (int __c) throw ();



extern int wctob (wint_t __c) throw ();



extern int mbsinit (__const mbstate_t *__ps) throw () __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
                       __const char *__restrict __s, size_t __n,
                       mbstate_t *__p) throw ();


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
                       mbstate_t *__restrict __ps) throw ();


extern size_t __mbrlen (__const char *__restrict __s, size_t __n,
                        mbstate_t *__restrict __ps) throw ();
extern size_t mbrlen (__const char *__restrict __s, size_t __n,
                      mbstate_t *__restrict __ps) throw ();

# 330 "/usr/include/wchar.h" 3 4



extern size_t mbsrtowcs (wchar_t *__restrict __dst,
                         __const char **__restrict __src, size_t __len,
                         mbstate_t *__restrict __ps) throw ();



extern size_t wcsrtombs (char *__restrict __dst,
                         __const wchar_t **__restrict __src, size_t __len,
                         mbstate_t *__restrict __ps) throw ();






extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
                          __const char **__restrict __src, size_t __nmc,
                          size_t __len, mbstate_t *__restrict __ps) throw ();



extern size_t wcsnrtombs (char *__restrict __dst,
                          __const wchar_t **__restrict __src,
                          size_t __nwc, size_t __len,
                          mbstate_t *__restrict __ps) throw ();






extern int wcwidth (wchar_t __c) throw ();



extern int wcswidth (__const wchar_t *__s, size_t __n) throw ();






extern double wcstod (__const wchar_t *__restrict __nptr,
                      wchar_t **__restrict __endptr) throw ();



extern float wcstof (__const wchar_t *__restrict __nptr,
                     wchar_t **__restrict __endptr) throw ();
extern long double wcstold (__const wchar_t *__restrict __nptr,
                            wchar_t **__restrict __endptr) throw ();





extern long int wcstol (__const wchar_t *__restrict __nptr,
                        wchar_t **__restrict __endptr, int __base) throw ();



extern unsigned long int wcstoul (__const wchar_t *__restrict __nptr,
                                  wchar_t **__restrict __endptr, int __base)
     throw ();




__extension__
extern long long int wcstoll (__const wchar_t *__restrict __nptr,
                              wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstoull (__const wchar_t *__restrict __nptr,
                                        wchar_t **__restrict __endptr,
                                        int __base) throw ();






__extension__
extern long long int wcstoq (__const wchar_t *__restrict __nptr,
                             wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstouq (__const wchar_t *__restrict __nptr,
                                       wchar_t **__restrict __endptr,
                                       int __base) throw ();
# 449 "/usr/include/wchar.h" 3 4
extern long int wcstol_l (__const wchar_t *__restrict __nptr,
                          wchar_t **__restrict __endptr, int __base,
                          __locale_t __loc) throw ();

extern unsigned long int wcstoul_l (__const wchar_t *__restrict __nptr,
                                    wchar_t **__restrict __endptr,
                                    int __base, __locale_t __loc) throw ();

__extension__
extern long long int wcstoll_l (__const wchar_t *__restrict __nptr,
                                wchar_t **__restrict __endptr,
                                int __base, __locale_t __loc) throw ();

__extension__
extern unsigned long long int wcstoull_l (__const wchar_t *__restrict __nptr,
                                          wchar_t **__restrict __endptr,
                                          int __base, __locale_t __loc)
     throw ();

extern double wcstod_l (__const wchar_t *__restrict __nptr,
                        wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern float wcstof_l (__const wchar_t *__restrict __nptr,
                       wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern long double wcstold_l (__const wchar_t *__restrict __nptr,
                              wchar_t **__restrict __endptr,
                              __locale_t __loc) throw ();





extern double __wcstod_internal (__const wchar_t *__restrict __nptr,
                                 wchar_t **__restrict __endptr, int __group)
     throw ();
extern float __wcstof_internal (__const wchar_t *__restrict __nptr,
                                wchar_t **__restrict __endptr, int __group)
     throw ();
extern long double __wcstold_internal (__const wchar_t *__restrict __nptr,
                                       wchar_t **__restrict __endptr,
                                       int __group) throw ();
# 575 "/usr/include/wchar.h" 3 4
extern wchar_t *wcpcpy (wchar_t *__dest, __const wchar_t *__src) throw ();



extern wchar_t *wcpncpy (wchar_t *__dest, __const wchar_t *__src, size_t __n)
     throw ();








extern int fwide (__FILE *__fp, int __mode) throw ();






extern int fwprintf (__FILE *__restrict __stream,
                     __const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (__const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
                     __const wchar_t *__restrict __format, ...)
     throw () ;





extern int vfwprintf (__FILE *__restrict __s,
                      __const wchar_t *__restrict __format,
                      __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (__const wchar_t *__restrict __format,
                     __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
                      __const wchar_t *__restrict __format,
                      __gnuc_va_list __arg)
     throw () ;






extern int fwscanf (__FILE *__restrict __stream,
                    __const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (__const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (__const wchar_t *__restrict __s,
                    __const wchar_t *__restrict __format, ...)
     throw () ;











extern int vfwscanf (__FILE *__restrict __s,
                     __const wchar_t *__restrict __format,
                     __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (__const wchar_t *__restrict __format,
                    __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (__const wchar_t *__restrict __s,
                     __const wchar_t *__restrict __format,
                     __gnuc_va_list __arg)
     throw () ;










extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
                        __FILE *__restrict __stream);





extern int fputws (__const wchar_t *__restrict __ws,
                   __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);

# 743 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 769 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 779 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
                                 __FILE *__restrict __stream);







extern int fputws_unlocked (__const wchar_t *__restrict __ws,
                            __FILE *__restrict __stream);







extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
                        __const wchar_t *__restrict __format,
                        __const struct tm *__restrict __tp) throw ();







extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
                          __const wchar_t *__restrict __format,
                          __const struct tm *__restrict __tp,
                          __locale_t __loc) throw ();
# 824 "/usr/include/wchar.h" 3 4
}
# 55 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cwchar" 2 3
# 69 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
# 133 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cwchar" 3
namespace std
{
  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;
  using ::swprintf;
  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;
  using ::vfwscanf;
  using ::vswprintf;
  using ::vswscanf;
  using ::vwprintf;
  using ::vwscanf;
  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;
  using ::wcstof;
  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;

  using ::wcschr;

  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }

  using ::wcspbrk;

  inline wchar_t*
  wcspbrk(wchar_t* __s1, wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }

  using ::wcsrchr;

  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }

  using ::wcsstr;

  inline wchar_t*
  wcsstr(wchar_t* __s1, wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }

  using ::wmemchr;

  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }
}







namespace __gnu_cxx
{





  using ::wcstold;
# 242 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using __gnu_cxx::wcstold;
  using __gnu_cxx::wcstoll;
  using __gnu_cxx::wcstoull;
}
# 46 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/fpos.h" 2 3

namespace std
{






  template<typename _StateT>
    class fpos
    {
    public:

      typedef _StateT __state_type;

    private:
      streamoff _M_off;
      __state_type _M_st;

    public:
      __state_type
      state() const { return _M_st; }

      void
      state(__state_type __st) { _M_st = __st; }



      fpos(): _M_off(streamoff()), _M_st(__state_type()) { }

      fpos(streamoff __off, __state_type __st = __state_type())
      : _M_off(__off), _M_st(__st) { }

      operator streamoff() const { return _M_off; }

      fpos&
      operator+=(streamoff __off) { _M_off += __off; return *this; }

      fpos&
      operator-=(streamoff __off) { _M_off -= __off; return *this; }

      fpos
      operator+(streamoff __off)
      {
        fpos __t(*this);
        __t += __off;
        return __t;
      }

      fpos
      operator-(streamoff __off)
      {
        fpos __t(*this);
        __t -= __off;
        return __t;
      }

      bool
      operator==(const fpos& __pos) const
      { return _M_off == __pos._M_off; }

      bool
      operator!=(const fpos& __pos) const
      { return _M_off != __pos._M_off; }

      streamoff
      _M_position() const { return _M_off; }

      void
      _M_position(streamoff __off) { _M_off = __off; }
    };


  typedef fpos<mbstate_t> streampos;


  typedef fpos<mbstate_t> wstreampos;

}
# 50 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/iosfwd" 2 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/functexcept.h" 1 3
# 34 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/functexcept.h" 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/exception_defines.h" 1 3
# 35 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/functexcept.h" 2 3

namespace std
{

  void
  __throw_bad_exception(void);


  void
  __throw_bad_alloc(void);


  void
  __throw_bad_cast(void);

  void
  __throw_bad_typeid(void);


  void
  __throw_logic_error(const char* __s);

  void
  __throw_domain_error(const char* __s);

  void
  __throw_invalid_argument(const char* __s);

  void
  __throw_length_error(const char* __s);

  void
  __throw_out_of_range(const char* __s);

  void
  __throw_runtime_error(const char* __s);

  void
  __throw_range_error(const char* __s);

  void
  __throw_overflow_error(const char* __s);

  void
  __throw_underflow_error(const char* __s);


  void
  __throw_ios_failure(const char* __s);
}
# 51 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/iosfwd" 2 3

namespace std
{
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
            typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  class ios_base;
# 136 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/iosfwd" 3
  typedef basic_ios<char> ios;
  typedef basic_streambuf<char> streambuf;
  typedef basic_istream<char> istream;
  typedef basic_ostream<char> ostream;
  typedef basic_iostream<char> iostream;
  typedef basic_stringbuf<char> stringbuf;
  typedef basic_istringstream<char> istringstream;
  typedef basic_ostringstream<char> ostringstream;
  typedef basic_stringstream<char> stringstream;
  typedef basic_filebuf<char> filebuf;
  typedef basic_ifstream<char> ifstream;
  typedef basic_ofstream<char> ofstream;
  typedef basic_fstream<char> fstream;


  typedef basic_ios<wchar_t> wios;
  typedef basic_streambuf<wchar_t> wstreambuf;
  typedef basic_istream<wchar_t> wistream;
  typedef basic_ostream<wchar_t> wostream;
  typedef basic_iostream<wchar_t> wiostream;
  typedef basic_stringbuf<wchar_t> wstringbuf;
  typedef basic_istringstream<wchar_t> wistringstream;
  typedef basic_ostringstream<wchar_t> wostringstream;
  typedef basic_stringstream<wchar_t> wstringstream;
  typedef basic_filebuf<wchar_t> wfilebuf;
  typedef basic_ifstream<wchar_t> wifstream;
  typedef basic_ofstream<wchar_t> wofstream;
  typedef basic_fstream<wchar_t> wfstream;


}
# 45 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ios" 2 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/exception" 1 3
# 40 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/exception" 3
extern "C++" {

namespace std
{
# 52 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/exception" 3
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();


    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }


    virtual ~bad_exception() throw();
  };


  typedef void (*terminate_handler) ();

  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();


  void terminate() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();


  void unexpected() __attribute__ ((__noreturn__));
# 100 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/exception" 3
  bool uncaught_exception() throw();
}

namespace __gnu_cxx
{
# 113 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/exception" 3
  void __verbose_terminate_handler ();
}

}
# 46 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ios" 2 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/char_traits.h" 1 3
# 44 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/char_traits.h" 3

# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cstring" 1 3
# 48 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cstring" 3



# 1 "/usr/include/string.h" 1 3 4
# 28 "/usr/include/string.h" 3 4
extern "C" {




# 1 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4




extern void *memcpy (void *__restrict __dest,
                     __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, __const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, __const void *__restrict __src,
                      int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memchr (__const void *__s, int __c, size_t __n)
      throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern void *rawmemchr (__const void *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern void *memrchr (__const void *__s, int __c, size_t __n)
      throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
                      __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, __const char *__restrict __src,
                      size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
                       __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));

# 121 "/usr/include/string.h" 3 4
extern int strcoll_l (__const char *__s1, __const char *__s2, __locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, __const char *__src, size_t __n,
                         __locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));




extern char *strdup (__const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (__const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 165 "/usr/include/string.h" 3 4


extern char *strchr (__const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));

extern char *strrchr (__const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strchrnul (__const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strcspn (__const char *__s, __const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (__const char *__s, __const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strpbrk (__const char *__s, __const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strstr (__const char *__haystack, __const char *__needle)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *strtok (char *__restrict __s, __const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
                         __const char *__restrict __delim,
                         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, __const char *__restrict __delim,
                       char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));




extern char *strcasestr (__const char *__haystack, __const char *__needle)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern void *memmem (__const void *__haystack, size_t __haystacklen,
                     __const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
                        __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
                      __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (__const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (__const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) throw ();

# 281 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));





extern void __bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern void bcopy (__const void *__src, void *__dest, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *index (__const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern char *rindex (__const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));



extern int ffs (int __i) throw () __attribute__ ((__const__));




extern int ffsl (long int __l) throw () __attribute__ ((__const__));

__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));




extern int strcasecmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (__const char *__s1, __const char *__s2,
                         __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (__const char *__s1, __const char *__s2,
                          size_t __n, __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
                     __const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
                        __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
                      __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));






extern char *basename (__const char *__filename) throw () __attribute__ ((__nonnull__ (1)));
# 426 "/usr/include/string.h" 3 4
}
# 52 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cstring" 2 3
# 77 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cstring" 3
namespace std
{
  using ::memcpy;
  using ::memmove;
  using ::strcpy;
  using ::strncpy;
  using ::strcat;
  using ::strncat;
  using ::memcmp;
  using ::strcmp;
  using ::strcoll;
  using ::strncmp;
  using ::strxfrm;
  using ::strcspn;
  using ::strspn;
  using ::strtok;
  using ::memset;
  using ::strerror;
  using ::strlen;

  using ::memchr;

  inline void*
  memchr(void* __p, int __c, size_t __n)
  { return memchr(const_cast<const void*>(__p), __c, __n); }

  using ::strchr;

  inline char*
  strchr(char* __s1, int __n)
  { return __builtin_strchr(const_cast<const char*>(__s1), __n); }

  using ::strpbrk;

  inline char*
  strpbrk(char* __s1, const char* __s2)
  { return __builtin_strpbrk(const_cast<const char*>(__s1), __s2); }

  using ::strrchr;

  inline char*
  strrchr(char* __s1, int __n)
  { return __builtin_strrchr(const_cast<const char*>(__s1), __n); }

  using ::strstr;

  inline char*
  strstr(char* __s1, const char* __s2)
  { return __builtin_strstr(const_cast<const char*>(__s1), __s2); }
}
# 46 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/char_traits.h" 2 3


namespace std
{
# 61 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits
    {
      typedef _CharT char_type;

      typedef unsigned long int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2);

      static bool
      eq(const char_type& __c1, const char_type& __c2);

      static bool
      lt(const char_type& __c1, const char_type& __c2);

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n);

      static size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n);

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a);

      static char_type
      to_char_type(const int_type& __c);

      static int_type
      to_int_type(const char_type& __c);

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2);

      static int_type
      eof();

      static int_type
      not_eof(const int_type& __c);
    };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return memcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(memchr(__s, __a, __n)); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(memmove(__s1, __s2, __n)); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(memcpy(__s1, __s2, __n)); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(memset(__s, __a, __n)); }

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }



      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof() { return static_cast<int_type>((-1)); }

      static int_type
      not_eof(const int_type& __c)
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return wmemchr(__s, __a, __n); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, int_type __n)
      { return wmemmove(__s1, __s2, __n); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcpy(__s1, __s2, __n); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return wmemset(__s, __a, __n); }

      static char_type
      to_char_type(const int_type& __c) { return char_type(__c); }

      static int_type
      to_int_type(const char_type& __c) { return int_type(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof() { return static_cast<int_type>((0xffffffffu)); }

      static int_type
      not_eof(const int_type& __c)
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };


  template<typename _CharT, typename _Traits>
    struct _Char_traits_match
    {
      _CharT _M_c;
      _Char_traits_match(_CharT const& __c) : _M_c(__c) { }

      bool
      operator()(_CharT const& __a) { return _Traits::eq(_M_c, __a); }
    };
}
# 47 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ios" 2 3

# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/localefwd.h" 1 3
# 44 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/localefwd.h" 3




# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/functexcept.h" 1 3
# 34 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/functexcept.h" 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/exception_defines.h" 1 3
# 35 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/functexcept.h" 2 3

namespace std
{

  void
  __throw_bad_exception(void);


  void
  __throw_bad_alloc(void);


  void
  __throw_bad_cast(void);

  void
  __throw_bad_typeid(void);


  void
  __throw_logic_error(const char* __s);

  void
  __throw_domain_error(const char* __s);

  void
  __throw_invalid_argument(const char* __s);

  void
  __throw_length_error(const char* __s);

  void
  __throw_out_of_range(const char* __s);

  void
  __throw_runtime_error(const char* __s);

  void
  __throw_range_error(const char* __s);

  void
  __throw_overflow_error(const char* __s);

  void
  __throw_underflow_error(const char* __s);


  void
  __throw_ios_failure(const char* __s);
}
# 49 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/localefwd.h" 2 3

namespace std
{

  class locale;


  template<typename _CharT>
    inline bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isgraph(_CharT, const locale&);

  template<typename _CharT>
    inline _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    inline _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  class __enc_traits;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;


  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;
  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;


  template<typename _CharT>
    class collate;
  template<typename _CharT> class
    collate_byname;


  class time_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;
  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;


  class messages_base;
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;

  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc);

  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw();
}
# 49 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ios" 2 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/ios_base.h" 1 3
# 44 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/ios_base.h" 3

# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/atomicity.h" 1 3
# 33 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/atomicity.h" 3
typedef int _Atomic_word;

static inline _Atomic_word
__attribute__ ((__unused__))
__exchange_and_add (volatile _Atomic_word *__mem, int __val)
{
  register _Atomic_word __result;
  __asm__ __volatile__ ("lock; xadd{l} {%0,%1|%1,%0}"
                        : "=r" (__result), "+m" (*__mem)
                        : "0" (__val)
                        : "memory");
  return __result;
}

static inline void
__attribute__ ((__unused__))
__atomic_add (volatile _Atomic_word* __mem, int __val)
{
  __asm__ __volatile__ ("lock; add{l} {%1,%0|%0,%1}"
                        : "+m" (*__mem) : "ir" (__val) : "memory");
}
# 46 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/ios_base.h" 2 3

# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/locale_classes.h" 1 3
# 44 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/locale_classes.h" 3



# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/string" 1 3
# 44 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/string" 3




# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/memory" 1 3
# 53 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/memory" 3

# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algobase.h" 1 3
# 66 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algobase.h" 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/climits" 1 3
# 48 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/climits" 3

# 1 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/limits.h" 1 3 4
# 11 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/limits.h" 3 4
# 1 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/syslimits.h" 1 3 4






# 1 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/limits.h" 1 3 4
# 122 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 144 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/posix1_lim.h" 1 3 4
# 153 "/usr/include/bits/posix1_lim.h" 3 4
# 1 "/usr/include/bits/local_lim.h" 1 3 4
# 36 "/usr/include/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 37 "/usr/include/bits/local_lim.h" 2 3 4
# 154 "/usr/include/bits/posix1_lim.h" 2 3 4
# 145 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/posix2_lim.h" 1 3 4
# 149 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/xopen_lim.h" 1 3 4
# 34 "/usr/include/bits/xopen_lim.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 35 "/usr/include/bits/xopen_lim.h" 2 3 4
# 153 "/usr/include/limits.h" 2 3 4
# 123 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/limits.h" 2 3 4
# 8 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/syslimits.h" 2 3 4
# 12 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/limits.h" 2 3 4
# 50 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/climits" 2 3
# 67 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algobase.h" 2 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cstdlib" 1 3
# 48 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cstdlib" 3




# 1 "/usr/include/stdlib.h" 1 3 4
# 33 "/usr/include/stdlib.h" 3 4
# 1 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/stddef.h" 1 3 4
# 34 "/usr/include/stdlib.h" 2 3 4

extern "C" {






# 1 "/usr/include/bits/waitflags.h" 1 3 4
# 43 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/bits/waitstatus.h" 1 3 4
# 67 "/usr/include/bits/waitstatus.h" 3 4
union wait
  {
    int w_status;
    struct
      {

        unsigned int __w_termsig:7;
        unsigned int __w_coredump:1;
        unsigned int __w_retcode:8;
        unsigned int:16;







      } __wait_terminated;
    struct
      {

        unsigned int __w_stopval:8;
        unsigned int __w_stopsig:8;
        unsigned int:16;






      } __wait_stopped;
  };
# 44 "/usr/include/stdlib.h" 2 3 4
# 96 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 140 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) throw ();




extern double atof (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));

extern int atoi (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));

extern long int atol (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





__extension__ extern long long int atoll (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern double strtod (__const char *__restrict __nptr,
                      char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1)));





extern float strtof (__const char *__restrict __nptr,
                     char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1)));

extern long double strtold (__const char *__restrict __nptr,
                            char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));





extern long int strtol (__const char *__restrict __nptr,
                        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (__const char *__restrict __nptr,
                                  char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoq (__const char *__restrict __nptr,
                             char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (__const char *__restrict __nptr,
                                       char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));





__extension__
extern long long int strtoll (__const char *__restrict __nptr,
                              char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (__const char *__restrict __nptr,
                                        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

# 239 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (__const char *__restrict __nptr,
                          char **__restrict __endptr, int __base,
                          __locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (__const char *__restrict __nptr,
                                    char **__restrict __endptr,
                                    int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (__const char *__restrict __nptr,
                                char **__restrict __endptr, int __base,
                                __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (__const char *__restrict __nptr,
                                          char **__restrict __endptr,
                                          int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (__const char *__restrict __nptr,
                        char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (__const char *__restrict __nptr,
                       char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (__const char *__restrict __nptr,
                              char **__restrict __endptr,
                              __locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 3)));






extern double __strtod_internal (__const char *__restrict __nptr,
                                 char **__restrict __endptr, int __group)
     throw () __attribute__ ((__nonnull__ (1)));
extern float __strtof_internal (__const char *__restrict __nptr,
                                char **__restrict __endptr, int __group)
     throw () __attribute__ ((__nonnull__ (1)));
extern long double __strtold_internal (__const char *__restrict __nptr,
                                       char **__restrict __endptr,
                                       int __group) throw () __attribute__ ((__nonnull__ (1)));

extern long int __strtol_internal (__const char *__restrict __nptr,
                                   char **__restrict __endptr,
                                   int __base, int __group)
     throw () __attribute__ ((__nonnull__ (1)));



extern unsigned long int __strtoul_internal (__const char *__restrict __nptr,
                                             char **__restrict __endptr,
                                             int __base, int __group)
     throw () __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int __strtoll_internal (__const char *__restrict __nptr,
                                         char **__restrict __endptr,
                                         int __base, int __group)
     throw () __attribute__ ((__nonnull__ (1)));



__extension__
extern unsigned long long int __strtoull_internal (__const char *
                                                   __restrict __nptr,
                                                   char **__restrict __endptr,
                                                   int __base, int __group)
     throw () __attribute__ ((__nonnull__ (1)));
# 424 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw ();


extern long int a64l (__const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




# 1 "/usr/include/sys/types.h" 1 3 4
# 29 "/usr/include/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;
# 72 "/usr/include/sys/types.h" 3 4
typedef __mode_t mode_t;




typedef __nlink_t nlink_t;
# 105 "/usr/include/sys/types.h" 3 4
typedef __id_t id_t;
# 116 "/usr/include/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 141 "/usr/include/sys/types.h" 3 4
typedef __suseconds_t suseconds_t;





# 1 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/stddef.h" 1 3 4
# 148 "/usr/include/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 191 "/usr/include/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 216 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/sys/select.h" 1 3 4
# 31 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/select.h" 1 3 4
# 32 "/usr/include/sys/select.h" 2 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 35 "/usr/include/sys/select.h" 2 3 4
# 46 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/time.h" 1 3 4
# 69 "/usr/include/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 47 "/usr/include/sys/select.h" 2 3 4
# 55 "/usr/include/sys/select.h" 3 4
typedef long int __fd_mask;
# 67 "/usr/include/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 99 "/usr/include/sys/select.h" 3 4
extern "C" {
# 109 "/usr/include/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
                   fd_set *__restrict __writefds,
                   fd_set *__restrict __exceptfds,
                   struct timeval *__restrict __timeout);
# 121 "/usr/include/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
                    fd_set *__restrict __writefds,
                    fd_set *__restrict __exceptfds,
                    const struct timespec *__restrict __timeout,
                    const __sigset_t *__restrict __sigmask);


}
# 217 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/sysmacros.h" 1 3 4
# 29 "/usr/include/sys/sysmacros.h" 3 4
__extension__
extern __inline unsigned int gnu_dev_major (unsigned long long int __dev)
     throw ();
__extension__
extern __inline unsigned int gnu_dev_minor (unsigned long long int __dev)
     throw ();
__extension__
extern __inline unsigned long long int gnu_dev_makedev (unsigned int __major,
                                                        unsigned int __minor)
     throw ();


__extension__ extern __inline unsigned int
gnu_dev_major (unsigned long long int __dev) throw ()
{
  return ((__dev >> 8) & 0xfff) | ((unsigned int) (__dev >> 32) & ~0xfff);
}

__extension__ extern __inline unsigned int
gnu_dev_minor (unsigned long long int __dev) throw ()
{
  return (__dev & 0xff) | ((unsigned int) (__dev >> 12) & ~0xff);
}

__extension__ extern __inline unsigned long long int
gnu_dev_makedev (unsigned int __major, unsigned int __minor) throw ()
{
  return ((__minor & 0xff) | ((__major & 0xfff) << 8)
          | (((unsigned long long int) (__minor & ~0xff)) << 12)
          | (((unsigned long long int) (__major & ~0xfff)) << 32));
}
# 220 "/usr/include/sys/types.h" 2 3 4




typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 258 "/usr/include/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 267 "/usr/include/sys/types.h" 2 3 4


}
# 434 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
                        size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
                     int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
                        size_t __statelen,
                        struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
                       struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();




extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    unsigned long long int __a;
  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
                      double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
                      struct drand48_data *__restrict __buffer,
                      double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
                      long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
                      struct drand48_data *__restrict __buffer,
                      long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
                      long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
                      struct drand48_data *__restrict __buffer,
                      long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
                     struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
                      struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__));

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__));







extern void *realloc (void *__ptr, size_t __size) throw () __attribute__ ((__malloc__));

extern void free (void *__ptr) throw ();




extern void cfree (void *__ptr) throw ();



# 1 "/usr/include/alloca.h" 1 3 4
# 25 "/usr/include/alloca.h" 3 4
# 1 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/stddef.h" 1 3 4
# 26 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();





}
# 607 "/usr/include/stdlib.h" 2 3 4




extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__));




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1)));




extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));





extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) throw () __attribute__ ((__noreturn__));






extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));






extern char *getenv (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));




extern char *__secure_getenv (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));





extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (__const char *__name, __const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (__const char *__name) throw ();






extern int clearenv (void) throw ();
# 691 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1)));
# 702 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1)));
# 711 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1)));
# 721 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1)));








extern int system (__const char *__command);







extern char *canonicalize_file_name (__const char *__name)
     throw () __attribute__ ((__nonnull__ (1)));
# 749 "/usr/include/stdlib.h" 3 4
extern char *realpath (__const char *__restrict __name,
                       char *__restrict __resolved) throw ();






typedef int (*__compar_fn_t) (__const void *, __const void *);


typedef __compar_fn_t comparison_fn_t;






extern void *bsearch (__const void *__key, __const void *__base,
                      size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5)));



extern void qsort (void *__base, size_t __nmemb, size_t __size,
                   __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));



extern int abs (int __x) throw () __attribute__ ((__const__));
extern long int labs (long int __x) throw () __attribute__ ((__const__));



__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__));







extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__));
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__));




__extension__ extern lldiv_t lldiv (long long int __numer,
                                    long long int __denom)
     throw () __attribute__ ((__const__));

# 814 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
                   int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4)));




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
                   int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4)));




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3)));




extern char *qecvt (long double __value, int __ndigit,
                    int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4)));
extern char *qfcvt (long double __value, int __ndigit,
                    int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4)));
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3)));




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
                   int *__restrict __sign, char *__restrict __buf,
                   size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
                   int *__restrict __sign, char *__restrict __buf,
                   size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
                    int *__restrict __decpt, int *__restrict __sign,
                    char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
                    int *__restrict __decpt, int *__restrict __sign,
                    char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));







extern int mblen (__const char *__s, size_t __n) throw ();


extern int mbtowc (wchar_t *__restrict __pwc,
                   __const char *__restrict __s, size_t __n) throw ();


extern int wctomb (char *__s, wchar_t __wchar) throw ();



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
                        __const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
                        __const wchar_t *__restrict __pwcs, size_t __n)
     throw ();








extern int rpmatch (__const char *__response) throw () __attribute__ ((__nonnull__ (1)));
# 902 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
                      char *__const *__restrict __tokens,
                      char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));





extern void setkey (__const char *__key) throw () __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag);







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw ();






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));





}
# 53 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cstdlib" 2 3
# 84 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cstdlib" 3
namespace std
{
  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;
  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;
  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;
  using ::qsort;
  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;
  using ::wcstombs;
  using ::wctomb;

  inline long
  abs(long __i) { return labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }
}
# 136 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cstdlib" 3
namespace __gnu_cxx
{

  using ::lldiv_t;





  using ::_Exit;


  inline long long
  abs(long long __x) { return __x >= 0 ? __x : -__x; }

  inline long long
  llabs(long long __x) { return __x >= 0 ? __x : -__x; }


  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  inline lldiv_t
  lldiv(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }
# 172 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;
}

namespace std
{

  using __gnu_cxx::lldiv_t;

  using __gnu_cxx::_Exit;
  using __gnu_cxx::abs;
  using __gnu_cxx::llabs;

  using __gnu_cxx::div;
  using __gnu_cxx::lldiv;

  using __gnu_cxx::atoll;
  using __gnu_cxx::strtof;
  using __gnu_cxx::strtoll;
  using __gnu_cxx::strtoull;
  using __gnu_cxx::strtold;
}
# 68 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algobase.h" 2 3

# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/new" 1 3
# 44 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/new" 3
extern "C++" {

namespace std
{





  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }


    virtual ~bad_alloc() throw();
  };

  struct nothrow_t { };
  extern const nothrow_t nothrow;


  typedef void (*new_handler)();

  new_handler set_new_handler(new_handler) throw();
}
# 82 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/new" 3
void* operator new(std::size_t) throw (std::bad_alloc);
void* operator new[](std::size_t) throw (std::bad_alloc);
void operator delete(void*) throw();
void operator delete[](void*) throw();
void* operator new(std::size_t, const std::nothrow_t&) throw();
void* operator new[](std::size_t, const std::nothrow_t&) throw();
void operator delete(void*, const std::nothrow_t&) throw();
void operator delete[](void*, const std::nothrow_t&) throw();


inline void* operator new(std::size_t, void* __p) throw() { return __p; }
inline void* operator new[](std::size_t, void* __p) throw() { return __p; }


inline void operator delete (void*, void*) throw() { };
inline void operator delete[](void*, void*) throw() { };

}
# 70 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algobase.h" 2 3

# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_pair.h" 1 3
# 64 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_pair.h" 3
namespace std
{


template <class _T1, class _T2>
struct pair {
  typedef _T1 first_type;
  typedef _T2 second_type;

  _T1 first;
  _T2 second;




  pair() : first(), second() {}




  pair(const _T1& __a, const _T2& __b) : first(__a), second(__b) {}


  template <class _U1, class _U2>
  pair(const pair<_U1, _U2>& __p) : first(__p.first), second(__p.second) {}
};


template <class _T1, class _T2>
inline bool operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
{
  return __x.first == __y.first && __x.second == __y.second;
}


template <class _T1, class _T2>
inline bool operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
{
  return __x.first < __y.first ||
         (!(__y.first < __x.first) && __x.second < __y.second);
}


template <class _T1, class _T2>
inline bool operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return !(__x == __y);
}


template <class _T1, class _T2>
inline bool operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return __y < __x;
}


template <class _T1, class _T2>
inline bool operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return !(__y < __x);
}


template <class _T1, class _T2>
inline bool operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return !(__x < __y);
}
# 140 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_pair.h" 3
template <class _T1, class _T2>


inline pair<_T1, _T2> make_pair(_T1 __x, _T2 __y)



{
  return pair<_T1, _T2>(__x, __y);
}

}
# 72 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algobase.h" 2 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/type_traits.h" 1 3
# 53 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/type_traits.h" 3
# 90 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/type_traits.h" 3
struct __true_type {};
struct __false_type {};

template <class _Tp>
struct __type_traits {
   typedef __true_type this_dummy_member_must_be_first;
# 113 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/type_traits.h" 3
   typedef __false_type has_trivial_default_constructor;
   typedef __false_type has_trivial_copy_constructor;
   typedef __false_type has_trivial_assignment_operator;
   typedef __false_type has_trivial_destructor;
   typedef __false_type is_POD_type;
};




template<> struct __type_traits<bool> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<char> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<signed char> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<unsigned char> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<wchar_t> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<short> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<unsigned short> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<int> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<unsigned int> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<long> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<unsigned long> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<long long> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<unsigned long long> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<float> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<double> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<long double> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template <class _Tp>
struct __type_traits<_Tp*> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};





template <class _Tp> struct _Is_integer {
  typedef __false_type _Integral;
};

template<> struct _Is_integer<bool> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<char> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<signed char> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned char> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<wchar_t> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<short> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned short> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<int> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned int> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<long> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned long> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<long long> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned long long> {
  typedef __true_type _Integral;
};

template<typename _Tp> struct _Is_normal_iterator {
   typedef __false_type _Normal;
};


namespace __gnu_cxx
{
  template<typename _Iterator, typename _Container> class __normal_iterator;
}

template<typename _Iterator, typename _Container>
struct _Is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator, _Container> > {
   typedef __true_type _Normal;
};
# 73 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algobase.h" 2 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_iterator_base_types.h" 1 3
# 68 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_iterator_base_types.h" 3

namespace std
{
# 80 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag {};

  struct output_iterator_tag {};

  struct forward_iterator_tag : public input_iterator_tag {};

  struct bidirectional_iterator_tag : public forward_iterator_tag {};

  struct random_access_iterator_tag : public bidirectional_iterator_tag {};
# 102 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };







  template<typename _Iterator>
    struct iterator_traits {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Tp>
    struct iterator_traits<_Tp*> {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };

  template<typename _Tp>
    struct iterator_traits<const _Tp*> {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };







  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }

}
# 74 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algobase.h" 2 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_iterator_base_funcs.h" 1 3
# 68 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_iterator_base_funcs.h" 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/concept_check.h" 1 3
# 39 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/concept_check.h" 3
# 69 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_iterator_base_funcs.h" 2 3

namespace std
{
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last) {
        ++__first; ++__n;
      }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     
      return __last - __first;
    }
# 109 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return __distance(__first, __last, __iterator_category(__first));
    }

  template<typename _InputIter, typename _Distance>
    inline void
    __advance(_InputIter& __i, _Distance __n, input_iterator_tag)
    {

     
      while (__n--) ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
              bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--) ++__i;
      else
        while (__n++) --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     
      __i += __n;
    }
# 162 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      __advance(__i, __n, __iterator_category(__i));
    }
}
# 75 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algobase.h" 2 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_iterator.h" 1 3
# 68 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_iterator.h" 3
namespace std
{
# 89 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                      typename iterator_traits<_Iterator>::value_type,
                      typename iterator_traits<_Iterator>::difference_type,
                      typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

    public:
      typedef _Iterator iterator_type;
      typedef typename iterator_traits<_Iterator>::difference_type
                                                               difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

    public:






      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
        : current(__x.base()) { }




      iterator_type
      base() const { return current; }






      reference
      operator*() const
      {
        _Iterator __tmp = current;
        return *--__tmp;
      }






      pointer
      operator->() const { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
        --current;
        return *this;
      }






      reverse_iterator
      operator++(int)
      {
        reverse_iterator __tmp = *this;
        --current;
        return __tmp;
      }






      reverse_iterator&
      operator--()
      {
        ++current;
        return *this;
      }






      reverse_iterator operator--(int)
      {
        reverse_iterator __tmp = *this;
        ++current;
        return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }






      reverse_iterator&
      operator+=(difference_type __n)
      {
        current -= __n;
        return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }






      reverse_iterator&
      operator-=(difference_type __n)
      {
        current += __n;
        return *this;
      }






      reference
      operator[](difference_type __n) const { return *(*this + __n); }
    };
# 272 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
               const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
              const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
               const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
              const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
                const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
               const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
              const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
              const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }
# 332 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
# 358 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
        container->push_back(__value);
        return *this;
      }


      back_insert_iterator&
      operator*() { return *this; }


      back_insert_iterator&
      operator++() { return *this; }


      back_insert_iterator
      operator++(int) { return *this; }
    };
# 389 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 404 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
# 429 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
        container->push_front(__value);
        return *this;
      }


      front_insert_iterator&
      operator*() { return *this; }


      front_insert_iterator&
      operator++() { return *this; }


      front_insert_iterator
      operator++(int) { return *this; }
    };
# 460 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 479 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
# 521 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(const typename _Container::const_reference __value)
      {
        iter = container->insert(iter, __value);
        ++iter;
        return *this;
      }


      insert_iterator&
      operator*() { return *this; }


      insert_iterator&
      operator++() { return *this; }


      insert_iterator&
      operator++(int) { return *this; }
    };
# 553 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
                                         typename _Container::iterator(__i));
    }
}

namespace __gnu_cxx
{







  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
      : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                        typename iterator_traits<_Iterator>::value_type,
                        typename iterator_traits<_Iterator>::difference_type,
                        typename iterator_traits<_Iterator>::pointer,
                        typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::difference_type
                                                               difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }


      template<typename _Iter>
      inline __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
        : _M_current(__i.base()) { }


      reference
      operator*() const { return *_M_current; }

      pointer
      operator->() const { return _M_current; }

      __normal_iterator&
      operator++() { ++_M_current; return *this; }

      __normal_iterator
      operator++(int) { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--() { --_M_current; return *this; }

      __normal_iterator
      operator--(int) { return __normal_iterator(_M_current--); }


      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const { return _M_current; }
    };
# 654 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
             const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
             const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
            const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
            const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
            const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
             const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
             const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline typename __normal_iterator<_IteratorL, _Container>::difference_type
  operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
             const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline __normal_iterator<_Iterator, _Container>
  operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n,
            const __normal_iterator<_Iterator, _Container>& __i)
  { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
}
# 76 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algobase.h" 2 3


namespace std
{
# 91 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algobase.h" 3
  template<typename _ForwardIter1, typename _ForwardIter2>
    inline void
    iter_swap(_ForwardIter1 __a, _ForwardIter2 __b)
    {
      typedef typename iterator_traits<_ForwardIter1>::value_type _ValueType1;
      typedef typename iterator_traits<_ForwardIter2>::value_type _ValueType2;


     
     
     
     

      _ValueType1 __tmp = *__a;
      *__a = *__b;
      *__b = __tmp;
    }
# 118 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)
    {

     

      _Tp __tmp = __a;
      __a = __b;
      __b = __tmp;
    }
# 146 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a) return __b; return __a;
    }
# 166 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b) return __b; return __a;
    }
# 186 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a)) return __b; return __a;
    }
# 204 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b)) return __b; return __a;
    }
# 221 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algobase.h" 3
  template<typename _InputIter, typename _OutputIter>
    inline _OutputIter
    __copy(_InputIter __first, _InputIter __last,
           _OutputIter __result,
           input_iterator_tag)
    {
      for ( ; __first != __last; ++__result, ++__first)
        *__result = *__first;
      return __result;
    }

  template<typename _RandomAccessIter, typename _OutputIter>
    inline _OutputIter
    __copy(_RandomAccessIter __first, _RandomAccessIter __last,
           _OutputIter __result,
           random_access_iterator_tag)
    {
      typedef typename iterator_traits<_RandomAccessIter>::difference_type
          _Distance;
      for (_Distance __n = __last - __first; __n > 0; --__n) {
        *__result = *__first;
        ++__first;
        ++__result;
      }
      return __result;
    }

  template<typename _Tp>
    inline _Tp*
    __copy_trivial(const _Tp* __first, const _Tp* __last, _Tp* __result)
    {
      memmove(__result, __first, sizeof(_Tp) * (__last - __first));
      return __result + (__last - __first);
    }

  template<typename _InputIter, typename _OutputIter>
    inline _OutputIter
    __copy_aux2(_InputIter __first, _InputIter __last,
                _OutputIter __result, __false_type)
    { return __copy(__first, __last, __result, __iterator_category(__first)); }

  template<typename _InputIter, typename _OutputIter>
    inline _OutputIter
    __copy_aux2(_InputIter __first, _InputIter __last,
                _OutputIter __result, __true_type)
    { return __copy(__first, __last, __result, __iterator_category(__first)); }

  template<typename _Tp>
    inline _Tp*
    __copy_aux2(_Tp* __first, _Tp* __last,
                _Tp* __result, __true_type)
    { return __copy_trivial(__first, __last, __result); }

  template<typename _Tp>
    inline _Tp*
    __copy_aux2(const _Tp* __first, const _Tp* __last,
                _Tp* __result, __true_type)
    { return __copy_trivial(__first, __last, __result); }

  template<typename _InputIter, typename _OutputIter>
    inline _OutputIter
    __copy_ni2(_InputIter __first, _InputIter __last,
               _OutputIter __result, __true_type)
    {
      typedef typename iterator_traits<_InputIter>::value_type
          _ValueType;
      typedef typename __type_traits<_ValueType>::has_trivial_assignment_operator
          _Trivial;
      return _OutputIter(__copy_aux2(__first, __last,
                                     __result.base(),
                                     _Trivial()));
    }

  template<typename _InputIter, typename _OutputIter>
    inline _OutputIter
    __copy_ni2(_InputIter __first, _InputIter __last,
               _OutputIter __result, __false_type)
    {
      typedef typename iterator_traits<_InputIter>::value_type
          _ValueType;
      typedef typename __type_traits<_ValueType>::has_trivial_assignment_operator
          _Trivial;
      return __copy_aux2(__first, __last,
                         __result,
                         _Trivial());
    }

  template<typename _InputIter, typename _OutputIter>
    inline _OutputIter
    __copy_ni1(_InputIter __first, _InputIter __last,
               _OutputIter __result, __true_type)
    {
      typedef typename _Is_normal_iterator<_OutputIter>::_Normal __Normal;
      return __copy_ni2(__first.base(), __last.base(), __result, __Normal());
    }

  template<typename _InputIter, typename _OutputIter>
    inline _OutputIter
    __copy_ni1(_InputIter __first, _InputIter __last,
               _OutputIter __result, __false_type)
    {
      typedef typename _Is_normal_iterator<_OutputIter>::_Normal __Normal;
      return __copy_ni2(__first, __last, __result, __Normal());
    }
# 339 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algobase.h" 3
  template<typename _InputIter, typename _OutputIter>
    inline _OutputIter
    copy(_InputIter __first, _InputIter __last, _OutputIter __result)
    {

     
     


       typedef typename _Is_normal_iterator<_InputIter>::_Normal __Normal;
       return __copy_ni1(__first, __last, __result, __Normal());
    }




  template<typename _BidirectionalIter1, typename _BidirectionalIter2>
    inline _BidirectionalIter2
    __copy_backward(_BidirectionalIter1 __first, _BidirectionalIter1 __last,
                    _BidirectionalIter2 __result,
                    bidirectional_iterator_tag)
    {
      while (__first != __last)
        *--__result = *--__last;
      return __result;
    }

  template<typename _RandomAccessIter, typename _BidirectionalIter>
    inline _BidirectionalIter
    __copy_backward(_RandomAccessIter __first, _RandomAccessIter __last,
                    _BidirectionalIter __result,
                    random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIter>::difference_type __n;
      for (__n = __last - __first; __n > 0; --__n)
        *--__result = *--__last;
      return __result;
    }







  template<typename _BidirectionalIter1, typename _BidirectionalIter2,
           typename _BoolType>
    struct __copy_backward_dispatch
    {
      static _BidirectionalIter2
      copy(_BidirectionalIter1 __first, _BidirectionalIter1 __last,
           _BidirectionalIter2 __result)
      {
        return __copy_backward(__first, __last,
                               __result,
                               __iterator_category(__first));
      }
    };

  template<typename _Tp>
    struct __copy_backward_dispatch<_Tp*, _Tp*, __true_type>
    {
      static _Tp*
      copy(const _Tp* __first, const _Tp* __last, _Tp* __result)
      {
        const ptrdiff_t _Num = __last - __first;
        memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
        return __result - _Num;
      }
    };

  template<typename _Tp>
    struct __copy_backward_dispatch<const _Tp*, _Tp*, __true_type>
    {
      static _Tp*
      copy(const _Tp* __first, const _Tp* __last, _Tp* __result)
      {
        return __copy_backward_dispatch<_Tp*, _Tp*, __true_type>
          ::copy(__first, __last, __result);
      }
    };

  template<typename _BI1, typename _BI2>
    inline _BI2
    __copy_backward_aux(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename __type_traits<typename iterator_traits<_BI2>::value_type>
                            ::has_trivial_assignment_operator _Trivial;
      return __copy_backward_dispatch<_BI1, _BI2, _Trivial>
                  ::copy(__first, __last, __result);
    }

  template <typename _BI1, typename _BI2>
    inline _BI2
    __copy_backward_output_normal_iterator(_BI1 __first, _BI1 __last,
                                           _BI2 __result, __true_type)
    { return _BI2(__copy_backward_aux(__first, __last, __result.base())); }

  template <typename _BI1, typename _BI2>
    inline _BI2
    __copy_backward_output_normal_iterator(_BI1 __first, _BI1 __last,
                                           _BI2 __result, __false_type)
    { return __copy_backward_aux(__first, __last, __result); }

  template <typename _BI1, typename _BI2>
    inline _BI2
    __copy_backward_input_normal_iterator(_BI1 __first, _BI1 __last,
                                          _BI2 __result, __true_type)
    {
      typedef typename _Is_normal_iterator<_BI2>::_Normal __Normal;
      return __copy_backward_output_normal_iterator(__first.base(), __last.base(),
                                                    __result, __Normal());
    }

  template <typename _BI1, typename _BI2>
    inline _BI2
    __copy_backward_input_normal_iterator(_BI1 __first, _BI1 __last,
                                          _BI2 __result, __false_type)
    {
      typedef typename _Is_normal_iterator<_BI2>::_Normal __Normal;
      return __copy_backward_output_normal_iterator(__first, __last, __result,
                                                    __Normal());
    }
# 477 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algobase.h" 3
  template <typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     



      typedef typename _Is_normal_iterator<_BI1>::_Normal __Normal;
      return __copy_backward_input_normal_iterator(__first, __last, __result,
                                                   __Normal());
    }
# 509 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algobase.h" 3
  template<typename _ForwardIter, typename _Tp>
    void
    fill(_ForwardIter __first, _ForwardIter __last, const _Tp& __value)
    {

     

      for ( ; __first != __last; ++__first)
        *__first = __value;
    }
# 531 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algobase.h" 3
  template<typename _OutputIter, typename _Size, typename _Tp>
    _OutputIter
    fill_n(_OutputIter __first, _Size __n, const _Tp& __value)
    {

     

      for ( ; __n > 0; --__n, ++__first)
        *__first = __value;
      return __first;
    }



  inline void
  fill(unsigned char* __first, unsigned char* __last, const unsigned char& __c)
  {
    unsigned char __tmp = __c;
    memset(__first, __tmp, __last - __first);
  }

  inline void
  fill(signed char* __first, signed char* __last, const signed char& __c)
  {
    signed char __tmp = __c;
    memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
  }

  inline void
  fill(char* __first, char* __last, const char& __c)
  {
    char __tmp = __c;
    memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
  }

  template<typename _Size>
    inline unsigned char*
    fill_n(unsigned char* __first, _Size __n, const unsigned char& __c)
    {
      fill(__first, __first + __n, __c);
      return __first + __n;
    }

  template<typename _Size>
    inline signed char*
    fill_n(char* __first, _Size __n, const signed char& __c)
    {
      fill(__first, __first + __n, __c);
      return __first + __n;
    }

  template<typename _Size>
    inline char*
    fill_n(char* __first, _Size __n, const char& __c)
    {
      fill(__first, __first + __n, __c);
      return __first + __n;
    }
# 606 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algobase.h" 3
  template<typename _InputIter1, typename _InputIter2>
    pair<_InputIter1, _InputIter2>
    mismatch(_InputIter1 __first1, _InputIter1 __last1,
             _InputIter2 __first2)
    {

     
     
     

     


      while (__first1 != __last1 && *__first1 == *__first2) {
        ++__first1;
        ++__first2;
      }
      return pair<_InputIter1, _InputIter2>(__first1, __first2);
    }
# 640 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algobase.h" 3
  template<typename _InputIter1, typename _InputIter2, typename _BinaryPredicate>
    pair<_InputIter1, _InputIter2>
    mismatch(_InputIter1 __first1, _InputIter1 __last1,
             _InputIter2 __first2,
             _BinaryPredicate __binary_pred)
    {

     
     

      while (__first1 != __last1 && __binary_pred(*__first1, *__first2)) {
        ++__first1;
        ++__first2;
      }
      return pair<_InputIter1, _InputIter2>(__first1, __first2);
    }
# 668 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algobase.h" 3
  template<typename _InputIter1, typename _InputIter2>
    inline bool
    equal(_InputIter1 __first1, _InputIter1 __last1,
          _InputIter2 __first2)
    {

     
     
     



      for ( ; __first1 != __last1; ++__first1, ++__first2)
        if (!(*__first1 == *__first2))
          return false;
      return true;
    }
# 699 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algobase.h" 3
  template<typename _InputIter1, typename _InputIter2, typename _BinaryPredicate>
    inline bool
    equal(_InputIter1 __first1, _InputIter1 __last1,
          _InputIter2 __first2,
          _BinaryPredicate __binary_pred)
    {

     
     

      for ( ; __first1 != __last1; ++__first1, ++__first2)
        if (!__binary_pred(*__first1, *__first2))
          return false;
      return true;
    }
# 732 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algobase.h" 3
  template<typename _InputIter1, typename _InputIter2>
    bool
    lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                            _InputIter2 __first2, _InputIter2 __last2)
    {

     
     
     

     


      for ( ; __first1 != __last1 && __first2 != __last2
            ; ++__first1, ++__first2) {
        if (*__first1 < *__first2)
          return true;
        if (*__first2 < *__first1)
          return false;
      }
      return __first1 == __last1 && __first2 != __last2;
    }
# 767 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algobase.h" 3
  template<typename _InputIter1, typename _InputIter2, typename _Compare>
    bool
    lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                            _InputIter2 __first2, _InputIter2 __last2,
                            _Compare __comp)
    {

     
     

      for ( ; __first1 != __last1 && __first2 != __last2
            ; ++__first1, ++__first2) {
        if (__comp(*__first1, *__first2))
          return true;
        if (__comp(*__first2, *__first1))
          return false;
      }
      return __first1 == __last1 && __first2 != __last2;
    }

  inline bool
  lexicographical_compare(const unsigned char* __first1, const unsigned char* __last1,
                          const unsigned char* __first2, const unsigned char* __last2)
  {
    const size_t __len1 = __last1 - __first1;
    const size_t __len2 = __last2 - __first2;
    const int __result = memcmp(__first1, __first2, min(__len1, __len2));
    return __result != 0 ? __result < 0 : __len1 < __len2;
  }

  inline bool
  lexicographical_compare(const char* __first1, const char* __last1,
                          const char* __first2, const char* __last2)
  {

    return lexicographical_compare((const signed char*) __first1,
                                   (const signed char*) __last1,
                                   (const signed char*) __first2,
                                   (const signed char*) __last2);






  }

}
# 55 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/memory" 2 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_alloc.h" 1 3
# 88 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_alloc.h" 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/functexcept.h" 1 3
# 34 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/functexcept.h" 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/exception_defines.h" 1 3
# 35 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/functexcept.h" 2 3

namespace std
{

  void
  __throw_bad_exception(void);


  void
  __throw_bad_alloc(void);


  void
  __throw_bad_cast(void);

  void
  __throw_bad_typeid(void);


  void
  __throw_logic_error(const char* __s);

  void
  __throw_domain_error(const char* __s);

  void
  __throw_invalid_argument(const char* __s);

  void
  __throw_length_error(const char* __s);

  void
  __throw_out_of_range(const char* __s);

  void
  __throw_runtime_error(const char* __s);

  void
  __throw_range_error(const char* __s);

  void
  __throw_overflow_error(const char* __s);

  void
  __throw_underflow_error(const char* __s);


  void
  __throw_ios_failure(const char* __s);
}
# 89 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_alloc.h" 2 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_threads.h" 1 3
# 54 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_threads.h" 3
namespace std
{




  struct _Refcount_Base
  {

    typedef size_t _RC_t;


    volatile _RC_t _M_ref_count;


    __gthread_mutex_t _M_ref_count_lock;

    _Refcount_Base(_RC_t __n) : _M_ref_count(__n)
    {

      __gthread_mutex_t __tmp = {0, 0, 0, PTHREAD_MUTEX_TIMED_NP, { 0, 0 }};
      _M_ref_count_lock = __tmp;





    }

    void
    _M_incr()
    {
      __gthread_mutex_lock(&_M_ref_count_lock);
      ++_M_ref_count;
      __gthread_mutex_unlock(&_M_ref_count_lock);
    }

    _RC_t
    _M_decr()
    {
      __gthread_mutex_lock(&_M_ref_count_lock);
      volatile _RC_t __tmp = --_M_ref_count;
      __gthread_mutex_unlock(&_M_ref_count_lock);
      return __tmp;
    }
  };
# 109 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_threads.h" 3
  template<int __dummy>
    struct _Swap_lock_struct
    { static __gthread_mutex_t _S_swap_lock; };

  template<int __dummy>
    __gthread_mutex_t
    _Swap_lock_struct<__dummy>::_S_swap_lock = {0, 0, 0, PTHREAD_MUTEX_TIMED_NP, { 0, 0 }};



  inline unsigned long
  _Atomic_swap(unsigned long * __p, unsigned long __q)
  {
    __gthread_mutex_lock(&_Swap_lock_struct<0>::_S_swap_lock);
    unsigned long __result = *__p;
    *__p = __q;
    __gthread_mutex_unlock(&_Swap_lock_struct<0>::_S_swap_lock);
    return __result;
  }

}
# 155 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_threads.h" 3
namespace std
{
  struct _STL_mutex_lock
  {





    __gthread_mutex_t _M_lock;

    void
    _M_initialize()
    {
# 192 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_threads.h" 3
    }

    void
    _M_acquire_lock()
    {



      __gthread_mutex_lock(&_M_lock);
    }

    void
    _M_release_lock()
    {



      __gthread_mutex_unlock(&_M_lock);
    }
  };
# 228 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_threads.h" 3
  struct _STL_auto_lock
  {
    _STL_mutex_lock& _M_lock;

    _STL_auto_lock(_STL_mutex_lock& __lock) : _M_lock(__lock)
    { _M_lock._M_acquire_lock(); }

    ~_STL_auto_lock() { _M_lock._M_release_lock(); }

  private:
    void operator=(const _STL_auto_lock&);
    _STL_auto_lock(const _STL_auto_lock&);
  };

}
# 90 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_alloc.h" 2 3



namespace std
{
# 103 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_alloc.h" 3
  class __new_alloc
  {
  public:
    static void*
    allocate(size_t __n)
    { return ::operator new(__n); }

    static void
    deallocate(void* __p, size_t)
    { ::operator delete(__p); }
  };
# 126 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_alloc.h" 3
  template<int __inst>
    class __malloc_alloc_template
    {
    private:
      static void* _S_oom_malloc(size_t);
      static void* _S_oom_realloc(void*, size_t);
      static void (* __malloc_alloc_oom_handler)();

    public:
      static void*
      allocate(size_t __n)
      {
        void* __result = malloc(__n);
        if (__builtin_expect(__result == 0, 0))
          __result = _S_oom_malloc(__n);
        return __result;
      }

      static void
      deallocate(void* __p, size_t )
      { free(__p); }

      static void*
      reallocate(void* __p, size_t , size_t __new_sz)
      {
        void* __result = realloc(__p, __new_sz);
        if (__builtin_expect(__result == 0, 0))
          __result = _S_oom_realloc(__p, __new_sz);
        return __result;
      }

      static void (* __set_malloc_handler(void (*__f)()))()
      {
        void (* __old)() = __malloc_alloc_oom_handler;
        __malloc_alloc_oom_handler = __f;
        return __old;
      }
    };


  template<int __inst>
    void (* __malloc_alloc_template<__inst>::__malloc_alloc_oom_handler)() = 0;

  template<int __inst>
    void*
    __malloc_alloc_template<__inst>::
    _S_oom_malloc(size_t __n)
    {
      void (* __my_malloc_handler)();
      void* __result;

      for (;;)
        {
          __my_malloc_handler = __malloc_alloc_oom_handler;
          if (__builtin_expect(__my_malloc_handler == 0, 0))
            __throw_bad_alloc();
          (*__my_malloc_handler)();
          __result = malloc(__n);
          if (__result)
            return __result;
        }
    }

  template<int __inst>
    void*
    __malloc_alloc_template<__inst>::
    _S_oom_realloc(void* __p, size_t __n)
    {
      void (* __my_malloc_handler)();
      void* __result;

      for (;;)
        {
          __my_malloc_handler = __malloc_alloc_oom_handler;
          if (__builtin_expect(__my_malloc_handler == 0, 0))
            __throw_bad_alloc();
          (*__my_malloc_handler)();
          __result = realloc(__p, __n);
          if (__result)
            return __result;
        }
    }


  typedef __new_alloc __mem_interface;
# 223 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_alloc.h" 3
  template<typename _Tp, typename _Alloc>
    class __simple_alloc
    {
    public:
      static _Tp*
      allocate(size_t __n)
      {
        _Tp* __ret = 0;
        if (__n)
          __ret = static_cast<_Tp*>(_Alloc::allocate(__n * sizeof(_Tp)));
        return __ret;
      }

      static _Tp*
      allocate()
      { return (_Tp*) _Alloc::allocate(sizeof (_Tp)); }

      static void
      deallocate(_Tp* __p, size_t __n)
      { if (0 != __n) _Alloc::deallocate(__p, __n * sizeof (_Tp)); }

      static void
      deallocate(_Tp* __p)
      { _Alloc::deallocate(__p, sizeof (_Tp)); }
    };
# 261 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_alloc.h" 3
  template<typename _Alloc>
    class __debug_alloc
    {
    private:


      enum {_S_extra = 8};

    public:
      static void*
      allocate(size_t __n)
      {
        char* __result = (char*)_Alloc::allocate(__n + (int) _S_extra);
        *(size_t*)__result = __n;
        return __result + (int) _S_extra;
      }

      static void
      deallocate(void* __p, size_t __n)
      {
        char* __real_p = (char*)__p - (int) _S_extra;
        if (*(size_t*)__real_p != __n)
          abort();
        _Alloc::deallocate(__real_p, __n + (int) _S_extra);
      }

      static void*
      reallocate(void* __p, size_t __old_sz, size_t __new_sz)
      {
        char* __real_p = (char*)__p - (int) _S_extra;
        if (*(size_t*)__real_p != __old_sz)
          abort();
        char* __result = (char*) _Alloc::reallocate(__real_p,
                                                    __old_sz + (int) _S_extra,
                                                    __new_sz + (int) _S_extra);
        *(size_t*)__result = __new_sz;
        return __result + (int) _S_extra;
      }
    };
# 332 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_alloc.h" 3
  template<bool __threads, int __inst>
    class __default_alloc_template
    {
    private:
      enum {_ALIGN = 8};
      enum {_MAX_BYTES = 128};
      enum {_NFREELISTS = _MAX_BYTES / _ALIGN};

      union _Obj
      {
        union _Obj* _M_free_list_link;
        char _M_client_data[1];
      };

      static _Obj* volatile _S_free_list[_NFREELISTS];


      static char* _S_start_free;
      static char* _S_end_free;
      static size_t _S_heap_size;

      static _STL_mutex_lock _S_node_allocator_lock;

      static size_t
      _S_round_up(size_t __bytes)
      { return (((__bytes) + (size_t) _ALIGN-1) & ~((size_t) _ALIGN - 1)); }

      static size_t
      _S_freelist_index(size_t __bytes)
      { return (((__bytes) + (size_t)_ALIGN - 1)/(size_t)_ALIGN - 1); }



      static void*
      _S_refill(size_t __n);



      static char*
      _S_chunk_alloc(size_t __size, int& __nobjs);



      struct _Lock
      {
        _Lock() { if (__threads) _S_node_allocator_lock._M_acquire_lock(); }
        ~_Lock() { if (__threads) _S_node_allocator_lock._M_release_lock(); }
      } __attribute__ ((__unused__));
      friend struct _Lock;

      static _Atomic_word _S_force_new;

    public:

      static void*
      allocate(size_t __n)
      {
        void* __ret = 0;




        if (_S_force_new == 0)
          {
            if (getenv("GLIBCPP_FORCE_NEW"))
              __atomic_add(&_S_force_new, 1);
            else
              __atomic_add(&_S_force_new, -1);
          }

        if ((__n > (size_t) _MAX_BYTES) || (_S_force_new > 0))
          __ret = __new_alloc::allocate(__n);
        else
          {
            _Obj* volatile* __my_free_list = _S_free_list
              + _S_freelist_index(__n);



            _Lock __lock_instance;
            _Obj* __restrict__ __result = *__my_free_list;
            if (__builtin_expect(__result == 0, 0))
              __ret = _S_refill(_S_round_up(__n));
            else
              {
                *__my_free_list = __result -> _M_free_list_link;
                __ret = __result;
              }
            if (__builtin_expect(__ret == 0, 0))
              __throw_bad_alloc();
          }
        return __ret;
      }


      static void
      deallocate(void* __p, size_t __n)
      {
        if ((__n > (size_t) _MAX_BYTES) || (_S_force_new > 0))
          __new_alloc::deallocate(__p, __n);
        else
          {
            _Obj* volatile* __my_free_list = _S_free_list
              + _S_freelist_index(__n);
            _Obj* __q = (_Obj*)__p;




            _Lock __lock_instance;
            __q -> _M_free_list_link = *__my_free_list;
            *__my_free_list = __q;
          }
      }

      static void*
      reallocate(void* __p, size_t __old_sz, size_t __new_sz);
    };

  template<bool __threads, int __inst> _Atomic_word
  __default_alloc_template<__threads, __inst>::_S_force_new = 0;

  template<bool __threads, int __inst>
    inline bool
    operator==(const __default_alloc_template<__threads,__inst>&,
               const __default_alloc_template<__threads,__inst>&)
    { return true; }

  template<bool __threads, int __inst>
    inline bool
    operator!=(const __default_alloc_template<__threads,__inst>&,
               const __default_alloc_template<__threads,__inst>&)
    { return false; }





  template<bool __threads, int __inst>
    char*
    __default_alloc_template<__threads, __inst>::
    _S_chunk_alloc(size_t __size, int& __nobjs)
    {
      char* __result;
      size_t __total_bytes = __size * __nobjs;
      size_t __bytes_left = _S_end_free - _S_start_free;

      if (__bytes_left >= __total_bytes)
        {
          __result = _S_start_free;
          _S_start_free += __total_bytes;
          return __result ;
        }
      else if (__bytes_left >= __size)
        {
          __nobjs = (int)(__bytes_left/__size);
          __total_bytes = __size * __nobjs;
          __result = _S_start_free;
          _S_start_free += __total_bytes;
          return __result;
        }
      else
        {
          size_t __bytes_to_get =
            2 * __total_bytes + _S_round_up(_S_heap_size >> 4);

          if (__bytes_left > 0)
            {
              _Obj* volatile* __my_free_list =
                _S_free_list + _S_freelist_index(__bytes_left);

              ((_Obj*)(void*)_S_start_free) -> _M_free_list_link = *__my_free_list;
              *__my_free_list = (_Obj*)(void*)_S_start_free;
            }
          _S_start_free = (char*) __new_alloc::allocate(__bytes_to_get);
          if (_S_start_free == 0)
            {
              size_t __i;
              _Obj* volatile* __my_free_list;
              _Obj* __p;



              __i = __size;
              for (; __i <= (size_t) _MAX_BYTES; __i += (size_t) _ALIGN)
                {
                  __my_free_list = _S_free_list + _S_freelist_index(__i);
                  __p = *__my_free_list;
                  if (__p != 0)
                    {
                      *__my_free_list = __p -> _M_free_list_link;
                      _S_start_free = (char*)__p;
                      _S_end_free = _S_start_free + __i;
                      return _S_chunk_alloc(__size, __nobjs);


                    }
                }
              _S_end_free = 0;
              _S_start_free = (char*)__new_alloc::allocate(__bytes_to_get);


            }
          _S_heap_size += __bytes_to_get;
          _S_end_free = _S_start_free + __bytes_to_get;
          return _S_chunk_alloc(__size, __nobjs);
        }
    }





  template<bool __threads, int __inst>
    void*
    __default_alloc_template<__threads, __inst>::_S_refill(size_t __n)
    {
      int __nobjs = 20;
      char* __chunk = _S_chunk_alloc(__n, __nobjs);
      _Obj* volatile* __my_free_list;
      _Obj* __result;
      _Obj* __current_obj;
      _Obj* __next_obj;
      int __i;

      if (1 == __nobjs)
        return __chunk;
      __my_free_list = _S_free_list + _S_freelist_index(__n);


      __result = (_Obj*)(void*)__chunk;
      *__my_free_list = __next_obj = (_Obj*)(void*)(__chunk + __n);
      for (__i = 1; ; __i++)
        {
          __current_obj = __next_obj;
          __next_obj = (_Obj*)(void*)((char*)__next_obj + __n);
          if (__nobjs - 1 == __i)
            {
              __current_obj -> _M_free_list_link = 0;
              break;
            }
          else
            __current_obj -> _M_free_list_link = __next_obj;
        }
      return __result;
    }


  template<bool threads, int inst>
    void*
    __default_alloc_template<threads, inst>::
    reallocate(void* __p, size_t __old_sz, size_t __new_sz)
    {
      void* __result;
      size_t __copy_sz;

      if (__old_sz > (size_t) _MAX_BYTES && __new_sz > (size_t) _MAX_BYTES)
        return(realloc(__p, __new_sz));
      if (_S_round_up(__old_sz) == _S_round_up(__new_sz))
        return(__p);
      __result = allocate(__new_sz);
      __copy_sz = __new_sz > __old_sz? __old_sz : __new_sz;
      memcpy(__result, __p, __copy_sz);
      deallocate(__p, __old_sz);
      return __result;
    }

  template<bool __threads, int __inst>
    _STL_mutex_lock
    __default_alloc_template<__threads,__inst>::_S_node_allocator_lock
    = { {0, 0, 0, PTHREAD_MUTEX_TIMED_NP, { 0, 0 }} };

  template<bool __threads, int __inst>
    char* __default_alloc_template<__threads,__inst>::_S_start_free = 0;

  template<bool __threads, int __inst>
    char* __default_alloc_template<__threads,__inst>::_S_end_free = 0;

  template<bool __threads, int __inst>
    size_t __default_alloc_template<__threads,__inst>::_S_heap_size = 0;

  template<bool __threads, int __inst>
    typename __default_alloc_template<__threads,__inst>::_Obj* volatile
    __default_alloc_template<__threads,__inst>::_S_free_list[_NFREELISTS];

  typedef __default_alloc_template<true,0> __alloc;
  typedef __default_alloc_template<false,0> __single_client_alloc;
# 635 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_alloc.h" 3
  template<typename _Tp>
    class allocator
    {
      typedef __alloc _Alloc;
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };

      allocator() throw() {}
      allocator(const allocator&) throw() {}
      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() {}
      ~allocator() throw() {}

      pointer
      address(reference __x) const { return &__x; }

      const_pointer
      address(const_reference __x) const { return &__x; }



      _Tp*
      allocate(size_type __n, const void* = 0)
      {
        _Tp* __ret = 0;
        if (__n)
          {
            if (__n <= this->max_size())
              __ret = static_cast<_Tp*>(_Alloc::allocate(__n * sizeof(_Tp)));
            else
              __throw_bad_alloc();
          }
        return __ret;
      }


      void
      deallocate(pointer __p, size_type __n)
      { _Alloc::deallocate(__p, __n * sizeof(_Tp)); }

      size_type
      max_size() const throw() { return size_t(-1) / sizeof(_Tp); }

      void construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); }
      void destroy(pointer __p) { __p->~_Tp(); }
    };

  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };
    };


  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }
# 731 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_alloc.h" 3
  template<typename _Tp, typename _Alloc>
    struct __allocator
    {
      _Alloc __underlying_alloc;

      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef __allocator<_Tp1, _Alloc> other; };

      __allocator() throw() {}
      __allocator(const __allocator& __a) throw()
      : __underlying_alloc(__a.__underlying_alloc) {}

      template<typename _Tp1>
        __allocator(const __allocator<_Tp1, _Alloc>& __a) throw()
        : __underlying_alloc(__a.__underlying_alloc) {}

      ~__allocator() throw() {}

      pointer
      address(reference __x) const { return &__x; }

      const_pointer
      address(const_reference __x) const { return &__x; }



      _Tp*
      allocate(size_type __n, const void* = 0)
      {
        _Tp* __ret = 0;
        if (__n)
          __ret = static_cast<_Tp*>(_Alloc::allocate(__n * sizeof(_Tp)));
        return __ret;
      }


      void
      deallocate(pointer __p, size_type __n)
      { __underlying_alloc.deallocate(__p, __n * sizeof(_Tp)); }

      size_type
      max_size() const throw() { return size_t(-1) / sizeof(_Tp); }

      void
      construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); }

      void
      destroy(pointer __p) { __p->~_Tp(); }
    };

  template<typename _Alloc>
    struct __allocator<void, _Alloc>
    {
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef __allocator<_Tp1, _Alloc> other; };
    };

  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const __allocator<_Tp,_Alloc>& __a1,
               const __allocator<_Tp,_Alloc>& __a2)
    { return __a1.__underlying_alloc == __a2.__underlying_alloc; }

  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const __allocator<_Tp, _Alloc>& __a1,
               const __allocator<_Tp, _Alloc>& __a2)
    { return __a1.__underlying_alloc != __a2.__underlying_alloc; }







  template<int inst>
    inline bool
    operator==(const __malloc_alloc_template<inst>&,
               const __malloc_alloc_template<inst>&)
    { return true; }

  template<int __inst>
    inline bool
    operator!=(const __malloc_alloc_template<__inst>&,
               const __malloc_alloc_template<__inst>&)
    { return false; }

  template<typename _Alloc>
    inline bool
    operator==(const __debug_alloc<_Alloc>&, const __debug_alloc<_Alloc>&)
    { return true; }

  template<typename _Alloc>
    inline bool
    operator!=(const __debug_alloc<_Alloc>&, const __debug_alloc<_Alloc>&)
    { return false; }
# 884 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_alloc.h" 3
  template<typename _Tp, typename _Allocator>
    struct _Alloc_traits
    {
      static const bool _S_instanceless = false;
      typedef typename _Allocator::template rebind<_Tp>::other allocator_type;
    };

  template<typename _Tp, typename _Allocator>
    const bool _Alloc_traits<_Tp, _Allocator>::_S_instanceless;


  template<typename _Tp, typename _Tp1>
    struct _Alloc_traits<_Tp, allocator<_Tp1> >
    {
      static const bool _S_instanceless = true;
      typedef __simple_alloc<_Tp, __alloc> _Alloc_type;
      typedef allocator<_Tp> allocator_type;
    };




  template<typename _Tp, int __inst>
    struct _Alloc_traits<_Tp, __malloc_alloc_template<__inst> >
    {
      static const bool _S_instanceless = true;
      typedef __simple_alloc<_Tp, __malloc_alloc_template<__inst> > _Alloc_type;
      typedef __allocator<_Tp, __malloc_alloc_template<__inst> > allocator_type;
    };

  template<typename _Tp, bool __threads, int __inst>
    struct _Alloc_traits<_Tp, __default_alloc_template<__threads, __inst> >
    {
      static const bool _S_instanceless = true;
      typedef __simple_alloc<_Tp, __default_alloc_template<__threads, __inst> >
      _Alloc_type;
      typedef __allocator<_Tp, __default_alloc_template<__threads, __inst> >
      allocator_type;
    };

  template<typename _Tp, typename _Alloc>
    struct _Alloc_traits<_Tp, __debug_alloc<_Alloc> >
    {
      static const bool _S_instanceless = true;
      typedef __simple_alloc<_Tp, __debug_alloc<_Alloc> > _Alloc_type;
      typedef __allocator<_Tp, __debug_alloc<_Alloc> > allocator_type;
    };





  template<typename _Tp, typename _Tp1, int __inst>
    struct _Alloc_traits<_Tp,
                         __allocator<_Tp1, __malloc_alloc_template<__inst> > >
    {
      static const bool _S_instanceless = true;
      typedef __simple_alloc<_Tp, __malloc_alloc_template<__inst> > _Alloc_type;
      typedef __allocator<_Tp, __malloc_alloc_template<__inst> > allocator_type;
    };

  template<typename _Tp, typename _Tp1, bool __thr, int __inst>
    struct _Alloc_traits<_Tp, __allocator<_Tp1, __default_alloc_template<__thr, __inst> > >
    {
      static const bool _S_instanceless = true;
      typedef __simple_alloc<_Tp, __default_alloc_template<__thr,__inst> >
      _Alloc_type;
      typedef __allocator<_Tp, __default_alloc_template<__thr,__inst> >
      allocator_type;
    };

  template<typename _Tp, typename _Tp1, typename _Alloc>
    struct _Alloc_traits<_Tp, __allocator<_Tp1, __debug_alloc<_Alloc> > >
    {
      static const bool _S_instanceless = true;
      typedef __simple_alloc<_Tp, __debug_alloc<_Alloc> > _Alloc_type;
      typedef __allocator<_Tp, __debug_alloc<_Alloc> > allocator_type;
    };






  extern template class allocator<char>;
  extern template class allocator<wchar_t>;
  extern template class __default_alloc_template<true,0>;

}
# 56 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/memory" 2 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_construct.h" 1 3
# 67 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_construct.h" 3
namespace std
{






  template <class _T1, class _T2>
    inline void
    _Construct(_T1* __p, const _T2& __value)
    { new (static_cast<void*>(__p)) _T1(__value); }







  template <class _T1>
    inline void
    _Construct(_T1* __p)
    { new (static_cast<void*>(__p)) _T1(); }
# 98 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_construct.h" 3
  template <class _ForwardIterator>
    inline void
    __destroy_aux(_ForwardIterator __first, _ForwardIterator __last, __false_type)
    { for ( ; __first != __last; ++__first) _Destroy(&*__first); }
# 112 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_construct.h" 3
  template <class _ForwardIterator>
    inline void
    __destroy_aux(_ForwardIterator, _ForwardIterator, __true_type)
    { }






  template <class _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }
# 134 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_construct.h" 3
  template <class _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      typedef typename __type_traits<_Value_type>::has_trivial_destructor
                       _Has_trivial_destructor;

      __destroy_aux(__first, __last, _Has_trivial_destructor());
    }
}
# 57 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/memory" 2 3

# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_uninitialized.h" 1 3
# 66 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_uninitialized.h" 3
namespace std
{



  template<typename _InputIter, typename _ForwardIter>
    inline _ForwardIter
    __uninitialized_copy_aux(_InputIter __first, _InputIter __last,
                             _ForwardIter __result,
                             __true_type)
    { return copy(__first, __last, __result); }

  template<typename _InputIter, typename _ForwardIter>
    _ForwardIter
    __uninitialized_copy_aux(_InputIter __first, _InputIter __last,
                             _ForwardIter __result,
                             __false_type)
    {
      _ForwardIter __cur = __result;
      try {
        for ( ; __first != __last; ++__first, ++__cur)
          _Construct(&*__cur, *__first);
        return __cur;
      }
      catch(...)
        {
          _Destroy(__result, __cur);
          throw;
        }
    }
# 106 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_uninitialized.h" 3
  template<typename _InputIter, typename _ForwardIter>
    inline _ForwardIter
    uninitialized_copy(_InputIter __first, _InputIter __last, _ForwardIter __result)
    {
      typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;
      typedef typename __type_traits<_ValueType>::is_POD_type _Is_POD;
      return __uninitialized_copy_aux(__first, __last, __result, _Is_POD());
    }

  inline char*
  uninitialized_copy(const char* __first, const char* __last, char* __result)
  {
    memmove(__result, __first, __last - __first);
    return __result + (__last - __first);
  }

  inline wchar_t*
  uninitialized_copy(const wchar_t* __first, const wchar_t* __last,
                     wchar_t* __result)
  {
    memmove(__result, __first, sizeof(wchar_t) * (__last - __first));
    return __result + (__last - __first);
  }



  template<typename _ForwardIter, typename _Tp>
    inline void
    __uninitialized_fill_aux(_ForwardIter __first, _ForwardIter __last,
                             const _Tp& __x, __true_type)
    { fill(__first, __last, __x); }

  template<typename _ForwardIter, typename _Tp>
    void
    __uninitialized_fill_aux(_ForwardIter __first, _ForwardIter __last,
                             const _Tp& __x, __false_type)
    {
      _ForwardIter __cur = __first;
      try {
        for ( ; __cur != __last; ++__cur)
          _Construct(&*__cur, __x);
      }
      catch(...)
        {
          _Destroy(__first, __cur);
          throw;
        }
    }
# 164 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_uninitialized.h" 3
  template<typename _ForwardIter, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIter __first, _ForwardIter __last, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;
      typedef typename __type_traits<_ValueType>::is_POD_type _Is_POD;
      __uninitialized_fill_aux(__first, __last, __x, _Is_POD());
    }



  template<typename _ForwardIter, typename _Size, typename _Tp>
    inline _ForwardIter
    __uninitialized_fill_n_aux(_ForwardIter __first, _Size __n,
                               const _Tp& __x, __true_type)
    {
      return fill_n(__first, __n, __x);
    }

  template<typename _ForwardIter, typename _Size, typename _Tp>
    _ForwardIter
    __uninitialized_fill_n_aux(_ForwardIter __first, _Size __n,
                               const _Tp& __x, __false_type)
    {
      _ForwardIter __cur = __first;
      try {
        for ( ; __n > 0; --__n, ++__cur)
          _Construct(&*__cur, __x);
        return __cur;
      }
      catch(...)
        {
          _Destroy(__first, __cur);
          throw;
        }
    }
# 210 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_uninitialized.h" 3
  template<typename _ForwardIter, typename _Size, typename _Tp>
    inline _ForwardIter
    uninitialized_fill_n(_ForwardIter __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;
      typedef typename __type_traits<_ValueType>::is_POD_type _Is_POD;
      return __uninitialized_fill_n_aux(__first, __n, __x, _Is_POD());
    }
# 227 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_uninitialized.h" 3
  template<typename _InputIter1, typename _InputIter2, typename _ForwardIter>
    inline _ForwardIter
    __uninitialized_copy_copy(_InputIter1 __first1, _InputIter1 __last1,
                              _InputIter2 __first2, _InputIter2 __last2,
                              _ForwardIter __result)
    {
      _ForwardIter __mid = uninitialized_copy(__first1, __last1, __result);
      try {
        return uninitialized_copy(__first2, __last2, __mid);
      }
      catch(...)
        {
          _Destroy(__result, __mid);
          throw;
        }
    }




  template<typename _ForwardIter, typename _Tp, typename _InputIter>
    inline _ForwardIter
    __uninitialized_fill_copy(_ForwardIter __result, _ForwardIter __mid,
                              const _Tp& __x,
                              _InputIter __first, _InputIter __last)
    {
      uninitialized_fill(__result, __mid, __x);
      try {
        return uninitialized_copy(__first, __last, __mid);
      }
      catch(...)
        {
          _Destroy(__result, __mid);
          throw;
        }
    }




  template<typename _InputIter, typename _ForwardIter, typename _Tp>
    inline void
    __uninitialized_copy_fill(_InputIter __first1, _InputIter __last1,
                              _ForwardIter __first2, _ForwardIter __last2,
                              const _Tp& __x)
    {
      _ForwardIter __mid2 = uninitialized_copy(__first1, __last1, __first2);
      try {
        uninitialized_fill(__mid2, __last2, __x);
      }
      catch(...)
        {
          _Destroy(__first2, __mid2);
          throw;
        }
    }

}
# 59 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/memory" 2 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_raw_storage_iter.h" 1 3
# 64 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_raw_storage_iter.h" 3
namespace std
{




  template <class _ForwardIterator, class _Tp>
  class raw_storage_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _ForwardIterator _M_iter;

    public:
      explicit
      raw_storage_iterator(_ForwardIterator __x) : _M_iter(__x) {}

      raw_storage_iterator&
      operator*() { return *this; }

      raw_storage_iterator&
      operator=(const _Tp& __element)
      {
        _Construct(&*_M_iter, __element);
        return *this;
      }

      raw_storage_iterator<_ForwardIterator, _Tp>&
      operator++()
      {
        ++_M_iter;
        return *this;
      }

      raw_storage_iterator<_ForwardIterator, _Tp>
      operator++(int)
      {
        raw_storage_iterator<_ForwardIterator, _Tp> __tmp = *this;
        ++_M_iter;
        return __tmp;
      }
    };
}
# 60 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/memory" 2 3

namespace std
{
# 71 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/memory" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    __get_temporary_buffer(ptrdiff_t __len, _Tp*)
    {
      if (__len > ptrdiff_t(2147483647 / sizeof(_Tp)))
        __len = 2147483647 / sizeof(_Tp);

      while (__len > 0)
        {
          _Tp* __tmp = (_Tp*) std::malloc((std::size_t)__len * sizeof(_Tp));
          if (__tmp != 0)
            return pair<_Tp*, ptrdiff_t>(__tmp, __len);
          __len /= 2;
        }
      return pair<_Tp*, ptrdiff_t>((_Tp*)0, 0);
    }
# 103 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/memory" 3
  template<typename _Tp>
    inline pair<_Tp*,ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len)
    { return __get_temporary_buffer(__len, (_Tp*) 0); }
# 115 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/memory" 3
  template<typename _Tp>
    void
    return_temporary_buffer(_Tp* __p)
    { std::free(__p); }
# 127 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/memory" 3
  template<typename _Tp1>
    struct auto_ptr_ref
    {
      _Tp1* _M_ptr;

      explicit
      auto_ptr_ref(_Tp1* __p): _M_ptr(__p) { }
    };
# 166 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/memory" 3
  template<typename _Tp>
    class auto_ptr
    {
    private:
      _Tp* _M_ptr;

    public:

      typedef _Tp element_type;







      explicit
      auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }
# 192 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/memory" 3
      auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) { }
# 203 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/memory" 3
      template<typename _Tp1>
        auto_ptr(auto_ptr<_Tp1>& __a) throw() : _M_ptr(__a.release()) { }
# 214 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/memory" 3
      auto_ptr&
      operator=(auto_ptr& __a) throw()
      {
        reset(__a.release());
        return *this;
      }
# 231 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/memory" 3
      template<typename _Tp1>
        auto_ptr&
        operator=(auto_ptr<_Tp1>& __a) throw()
        {
          reset(__a.release());
          return *this;
        }
# 251 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/memory" 3
      ~auto_ptr() { delete _M_ptr; }
# 261 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/memory" 3
      element_type&
      operator*() const throw() { return *_M_ptr; }







      element_type*
      operator->() const throw() { return _M_ptr; }
# 283 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/memory" 3
      element_type*
      get() const throw() { return _M_ptr; }
# 297 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/memory" 3
      element_type*
      release() throw()
      {
        element_type* __tmp = _M_ptr;
        _M_ptr = 0;
        return __tmp;
      }
# 312 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/memory" 3
      void
      reset(element_type* __p = 0) throw()
      {
        if (__p != _M_ptr)
          {
            delete _M_ptr;
            _M_ptr = __p;
          }
      }
# 333 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/memory" 3
      auto_ptr(auto_ptr_ref<element_type> __ref) throw()
      : _M_ptr(__ref._M_ptr) { }

      auto_ptr&
      operator=(auto_ptr_ref<element_type> __ref) throw()
      {
        if (__ref._M_ptr != this->get())
          {
            delete _M_ptr;
            _M_ptr = __ref._M_ptr;
          }
        return *this;
      }

      template<typename _Tp1>
        operator auto_ptr_ref<_Tp1>() throw()
        { return auto_ptr_ref<_Tp1>(this->release()); }

      template<typename _Tp1>
        operator auto_ptr<_Tp1>() throw()
        { return auto_ptr<_Tp1>(this->release()); }

  };
}
# 49 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/string" 2 3



# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_function.h" 1 3
# 64 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_function.h" 3
namespace std
{
# 101 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_function.h" 3
template <class _Arg, class _Result>
struct unary_function {
  typedef _Arg argument_type;
  typedef _Result result_type;
};




template <class _Arg1, class _Arg2, class _Result>
struct binary_function {
  typedef _Arg1 first_argument_type;
  typedef _Arg2 second_argument_type;
  typedef _Result result_type;
};
# 127 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_function.h" 3
template <class _Tp>
struct plus : public binary_function<_Tp,_Tp,_Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x + __y; }
};


template <class _Tp>
struct minus : public binary_function<_Tp,_Tp,_Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x - __y; }
};


template <class _Tp>
struct multiplies : public binary_function<_Tp,_Tp,_Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x * __y; }
};


template <class _Tp>
struct divides : public binary_function<_Tp,_Tp,_Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x / __y; }
};


template <class _Tp>
struct modulus : public binary_function<_Tp,_Tp,_Tp>
{
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x % __y; }
};


template <class _Tp>
struct negate : public unary_function<_Tp,_Tp>
{
  _Tp operator()(const _Tp& __x) const { return -__x; }
};
# 173 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_function.h" 3
template <class _Tp>
struct equal_to : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x == __y; }
};


template <class _Tp>
struct not_equal_to : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x != __y; }
};


template <class _Tp>
struct greater : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x > __y; }
};


template <class _Tp>
struct less : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x < __y; }
};


template <class _Tp>
struct greater_equal : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x >= __y; }
};


template <class _Tp>
struct less_equal : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x <= __y; }
};
# 222 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_function.h" 3
template <class _Tp>
struct logical_and : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x && __y; }
};


template <class _Tp>
struct logical_or : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x || __y; }
};


template <class _Tp>
struct logical_not : public unary_function<_Tp,bool>
{
  bool operator()(const _Tp& __x) const { return !__x; }
};
# 271 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_function.h" 3
template <class _Predicate>
class unary_negate
  : public unary_function<typename _Predicate::argument_type, bool> {
protected:
  _Predicate _M_pred;
public:
  explicit unary_negate(const _Predicate& __x) : _M_pred(__x) {}
  bool operator()(const typename _Predicate::argument_type& __x) const {
    return !_M_pred(__x);
  }
};


template <class _Predicate>
inline unary_negate<_Predicate>
not1(const _Predicate& __pred)
{
  return unary_negate<_Predicate>(__pred);
}


template <class _Predicate>
class binary_negate
  : public binary_function<typename _Predicate::first_argument_type,
                           typename _Predicate::second_argument_type,
                           bool> {
protected:
  _Predicate _M_pred;
public:
  explicit binary_negate(const _Predicate& __x) : _M_pred(__x) {}
  bool operator()(const typename _Predicate::first_argument_type& __x,
                  const typename _Predicate::second_argument_type& __y) const
  {
    return !_M_pred(__x, __y);
  }
};


template <class _Predicate>
inline binary_negate<_Predicate>
not2(const _Predicate& __pred)
{
  return binary_negate<_Predicate>(__pred);
}
# 349 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_function.h" 3
template <class _Operation>
class binder1st
  : public unary_function<typename _Operation::second_argument_type,
                          typename _Operation::result_type> {
protected:
  _Operation op;
  typename _Operation::first_argument_type value;
public:
  binder1st(const _Operation& __x,
            const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) {}
  typename _Operation::result_type
  operator()(const typename _Operation::second_argument_type& __x) const {
    return op(value, __x);
  }


  typename _Operation::result_type
  operator()(typename _Operation::second_argument_type& __x) const {
    return op(value, __x);
  }

};


template <class _Operation, class _Tp>
inline binder1st<_Operation>
bind1st(const _Operation& __fn, const _Tp& __x)
{
  typedef typename _Operation::first_argument_type _Arg1_type;
  return binder1st<_Operation>(__fn, _Arg1_type(__x));
}


template <class _Operation>
class binder2nd
  : public unary_function<typename _Operation::first_argument_type,
                          typename _Operation::result_type> {
protected:
  _Operation op;
  typename _Operation::second_argument_type value;
public:
  binder2nd(const _Operation& __x,
            const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) {}
  typename _Operation::result_type
  operator()(const typename _Operation::first_argument_type& __x) const {
    return op(__x, value);
  }


  typename _Operation::result_type
  operator()(typename _Operation::first_argument_type& __x) const {
    return op(__x, value);
  }

};


template <class _Operation, class _Tp>
inline binder2nd<_Operation>
bind2nd(const _Operation& __fn, const _Tp& __x)
{
  typedef typename _Operation::second_argument_type _Arg2_type;
  return binder2nd<_Operation>(__fn, _Arg2_type(__x));
}
# 438 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_function.h" 3
template <class _Arg, class _Result>
class pointer_to_unary_function : public unary_function<_Arg, _Result> {
protected:
  _Result (*_M_ptr)(_Arg);
public:
  pointer_to_unary_function() {}
  explicit pointer_to_unary_function(_Result (*__x)(_Arg)) : _M_ptr(__x) {}
  _Result operator()(_Arg __x) const { return _M_ptr(__x); }
};


template <class _Arg, class _Result>
inline pointer_to_unary_function<_Arg, _Result> ptr_fun(_Result (*__x)(_Arg))
{
  return pointer_to_unary_function<_Arg, _Result>(__x);
}


template <class _Arg1, class _Arg2, class _Result>
class pointer_to_binary_function :
  public binary_function<_Arg1,_Arg2,_Result> {
protected:
    _Result (*_M_ptr)(_Arg1, _Arg2);
public:
    pointer_to_binary_function() {}
    explicit pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) {}
    _Result operator()(_Arg1 __x, _Arg2 __y) const {
      return _M_ptr(__x, __y);
    }
};


template <class _Arg1, class _Arg2, class _Result>
inline pointer_to_binary_function<_Arg1,_Arg2,_Result>
ptr_fun(_Result (*__x)(_Arg1, _Arg2)) {
  return pointer_to_binary_function<_Arg1,_Arg2,_Result>(__x);
}


template <class _Tp>
struct _Identity : public unary_function<_Tp,_Tp> {
  _Tp& operator()(_Tp& __x) const { return __x; }
  const _Tp& operator()(const _Tp& __x) const { return __x; }
};

template <class _Pair>
struct _Select1st : public unary_function<_Pair, typename _Pair::first_type> {
  typename _Pair::first_type& operator()(_Pair& __x) const {
    return __x.first;
  }
  const typename _Pair::first_type& operator()(const _Pair& __x) const {
    return __x.first;
  }
};

template <class _Pair>
struct _Select2nd : public unary_function<_Pair, typename _Pair::second_type>
{
  typename _Pair::second_type& operator()(_Pair& __x) const {
    return __x.second;
  }
  const typename _Pair::second_type& operator()(const _Pair& __x) const {
    return __x.second;
  }
};
# 528 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_function.h" 3
template <class _Ret, class _Tp>
class mem_fun_t : public unary_function<_Tp*,_Ret> {
public:
  explicit mem_fun_t(_Ret (_Tp::*__pf)()) : _M_f(__pf) {}
  _Ret operator()(_Tp* __p) const { return (__p->*_M_f)(); }
private:
  _Ret (_Tp::*_M_f)();
};


template <class _Ret, class _Tp>
class const_mem_fun_t : public unary_function<const _Tp*,_Ret> {
public:
  explicit const_mem_fun_t(_Ret (_Tp::*__pf)() const) : _M_f(__pf) {}
  _Ret operator()(const _Tp* __p) const { return (__p->*_M_f)(); }
private:
  _Ret (_Tp::*_M_f)() const;
};


template <class _Ret, class _Tp>
class mem_fun_ref_t : public unary_function<_Tp,_Ret> {
public:
  explicit mem_fun_ref_t(_Ret (_Tp::*__pf)()) : _M_f(__pf) {}
  _Ret operator()(_Tp& __r) const { return (__r.*_M_f)(); }
private:
  _Ret (_Tp::*_M_f)();
};


template <class _Ret, class _Tp>
class const_mem_fun_ref_t : public unary_function<_Tp,_Ret> {
public:
  explicit const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const) : _M_f(__pf) {}
  _Ret operator()(const _Tp& __r) const { return (__r.*_M_f)(); }
private:
  _Ret (_Tp::*_M_f)() const;
};


template <class _Ret, class _Tp, class _Arg>
class mem_fun1_t : public binary_function<_Tp*,_Arg,_Ret> {
public:
  explicit mem_fun1_t(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf) {}
  _Ret operator()(_Tp* __p, _Arg __x) const { return (__p->*_M_f)(__x); }
private:
  _Ret (_Tp::*_M_f)(_Arg);
};


template <class _Ret, class _Tp, class _Arg>
class const_mem_fun1_t : public binary_function<const _Tp*,_Arg,_Ret> {
public:
  explicit const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf) {}
  _Ret operator()(const _Tp* __p, _Arg __x) const
    { return (__p->*_M_f)(__x); }
private:
  _Ret (_Tp::*_M_f)(_Arg) const;
};


template <class _Ret, class _Tp, class _Arg>
class mem_fun1_ref_t : public binary_function<_Tp,_Arg,_Ret> {
public:
  explicit mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf) {}
  _Ret operator()(_Tp& __r, _Arg __x) const { return (__r.*_M_f)(__x); }
private:
  _Ret (_Tp::*_M_f)(_Arg);
};


template <class _Ret, class _Tp, class _Arg>
class const_mem_fun1_ref_t : public binary_function<_Tp,_Arg,_Ret> {
public:
  explicit const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf) {}
  _Ret operator()(const _Tp& __r, _Arg __x) const { return (__r.*_M_f)(__x); }
private:
  _Ret (_Tp::*_M_f)(_Arg) const;
};


template <class _Tp>
class mem_fun_t<void, _Tp> : public unary_function<_Tp*,void> {
public:
  explicit mem_fun_t(void (_Tp::*__pf)()) : _M_f(__pf) {}
  void operator()(_Tp* __p) const { (__p->*_M_f)(); }
private:
  void (_Tp::*_M_f)();
};


template <class _Tp>
class const_mem_fun_t<void, _Tp> : public unary_function<const _Tp*,void> {
public:
  explicit const_mem_fun_t(void (_Tp::*__pf)() const) : _M_f(__pf) {}
  void operator()(const _Tp* __p) const { (__p->*_M_f)(); }
private:
  void (_Tp::*_M_f)() const;
};


template <class _Tp>
class mem_fun_ref_t<void, _Tp> : public unary_function<_Tp,void> {
public:
  explicit mem_fun_ref_t(void (_Tp::*__pf)()) : _M_f(__pf) {}
  void operator()(_Tp& __r) const { (__r.*_M_f)(); }
private:
  void (_Tp::*_M_f)();
};


template <class _Tp>
class const_mem_fun_ref_t<void, _Tp> : public unary_function<_Tp,void> {
public:
  explicit const_mem_fun_ref_t(void (_Tp::*__pf)() const) : _M_f(__pf) {}
  void operator()(const _Tp& __r) const { (__r.*_M_f)(); }
private:
  void (_Tp::*_M_f)() const;
};


template <class _Tp, class _Arg>
class mem_fun1_t<void, _Tp, _Arg> : public binary_function<_Tp*,_Arg,void> {
public:
  explicit mem_fun1_t(void (_Tp::*__pf)(_Arg)) : _M_f(__pf) {}
  void operator()(_Tp* __p, _Arg __x) const { (__p->*_M_f)(__x); }
private:
  void (_Tp::*_M_f)(_Arg);
};


template <class _Tp, class _Arg>
class const_mem_fun1_t<void, _Tp, _Arg>
  : public binary_function<const _Tp*,_Arg,void> {
public:
  explicit const_mem_fun1_t(void (_Tp::*__pf)(_Arg) const) : _M_f(__pf) {}
  void operator()(const _Tp* __p, _Arg __x) const { (__p->*_M_f)(__x); }
private:
  void (_Tp::*_M_f)(_Arg) const;
};


template <class _Tp, class _Arg>
class mem_fun1_ref_t<void, _Tp, _Arg>
  : public binary_function<_Tp,_Arg,void> {
public:
  explicit mem_fun1_ref_t(void (_Tp::*__pf)(_Arg)) : _M_f(__pf) {}
  void operator()(_Tp& __r, _Arg __x) const { (__r.*_M_f)(__x); }
private:
  void (_Tp::*_M_f)(_Arg);
};


template <class _Tp, class _Arg>
class const_mem_fun1_ref_t<void, _Tp, _Arg>
  : public binary_function<_Tp,_Arg,void> {
public:
  explicit const_mem_fun1_ref_t(void (_Tp::*__pf)(_Arg) const) : _M_f(__pf) {}
  void operator()(const _Tp& __r, _Arg __x) const { (__r.*_M_f)(__x); }
private:
  void (_Tp::*_M_f)(_Arg) const;
};





template <class _Ret, class _Tp>
inline mem_fun_t<_Ret,_Tp> mem_fun(_Ret (_Tp::*__f)())
  { return mem_fun_t<_Ret,_Tp>(__f); }

template <class _Ret, class _Tp>
inline const_mem_fun_t<_Ret,_Tp> mem_fun(_Ret (_Tp::*__f)() const)
  { return const_mem_fun_t<_Ret,_Tp>(__f); }

template <class _Ret, class _Tp>
inline mem_fun_ref_t<_Ret,_Tp> mem_fun_ref(_Ret (_Tp::*__f)())
  { return mem_fun_ref_t<_Ret,_Tp>(__f); }

template <class _Ret, class _Tp>
inline const_mem_fun_ref_t<_Ret,_Tp> mem_fun_ref(_Ret (_Tp::*__f)() const)
  { return const_mem_fun_ref_t<_Ret,_Tp>(__f); }

template <class _Ret, class _Tp, class _Arg>
inline mem_fun1_t<_Ret,_Tp,_Arg> mem_fun(_Ret (_Tp::*__f)(_Arg))
  { return mem_fun1_t<_Ret,_Tp,_Arg>(__f); }

template <class _Ret, class _Tp, class _Arg>
inline const_mem_fun1_t<_Ret,_Tp,_Arg> mem_fun(_Ret (_Tp::*__f)(_Arg) const)
  { return const_mem_fun1_t<_Ret,_Tp,_Arg>(__f); }

template <class _Ret, class _Tp, class _Arg>
inline mem_fun1_ref_t<_Ret,_Tp,_Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
  { return mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }

template <class _Ret, class _Tp, class _Arg>
inline const_mem_fun1_ref_t<_Ret,_Tp,_Arg>
mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
  { return const_mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }



}
# 53 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/string" 2 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/basic_string.h" 1 3
# 44 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/basic_string.h" 3



namespace std
{
# 108 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {

    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _Alloc::size_type size_type;
      typedef typename _Alloc::difference_type difference_type;
      typedef typename _Alloc::reference reference;
      typedef typename _Alloc::const_reference const_reference;
      typedef typename _Alloc::pointer pointer;
      typedef typename _Alloc::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;

    private:
# 143 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/basic_string.h" 3
      struct _Rep
      {

        typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
# 161 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/basic_string.h" 3
        static const size_type _S_max_size;
        static const _CharT _S_terminal;

        size_type _M_length;
        size_type _M_capacity;
        _Atomic_word _M_references;

        bool
        _M_is_leaked() const
        { return _M_references < 0; }

        bool
        _M_is_shared() const
        { return _M_references > 0; }

        void
        _M_set_leaked()
        { _M_references = -1; }

        void
        _M_set_sharable()
        { _M_references = 0; }

        _CharT*
        _M_refdata() throw()
        { return reinterpret_cast<_CharT*>(this + 1); }

        _CharT&
        operator[](size_t __s) throw()
        { return _M_refdata() [__s]; }

        _CharT*
        _M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
        {
          return (!_M_is_leaked() && __alloc1 == __alloc2)
                  ? _M_refcopy() : _M_clone(__alloc1);
        }


        static _Rep*
        _S_create(size_t, const _Alloc&);

        void
        _M_dispose(const _Alloc& __a)
        {
          if (__exchange_and_add(&_M_references, -1) <= 0)
            _M_destroy(__a);
        }

        void
        _M_destroy(const _Alloc&) throw();

        _CharT*
        _M_refcopy() throw()
        {
          __atomic_add(&_M_references, 1);
          return _M_refdata();
        }

        _CharT*
        _M_clone(const _Alloc&, size_type __res = 0);
      };


      struct _Alloc_hider : _Alloc
      {
        _Alloc_hider(_CharT* __dat, const _Alloc& __a)
        : _Alloc(__a), _M_p(__dat) { }

        _CharT* _M_p;
      };

    public:



      static const size_type npos = static_cast<size_type>(-1);

    private:

      mutable _Alloc_hider _M_dataplus;



      static size_type _S_empty_rep_storage[(sizeof(_Rep) + sizeof(_CharT) + sizeof(size_type) - 1)/sizeof(size_type)];

      _CharT*
      _M_data() const
      { return _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p)
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }



      iterator
      _M_ibegin() const { return iterator(_M_data()); }

      iterator
      _M_iend() const { return iterator(_M_data() + this->size()); }

      void
      _M_leak()
      {
        if (!_M_rep()->_M_is_leaked())
          _M_leak_hard();
      }

      iterator
      _M_check(size_type __pos) const
      {
        if (__pos > this->size())
          __throw_out_of_range("basic_string::_M_check");
        return _M_ibegin() + __pos;
      }


      iterator
      _M_fold(size_type __pos, size_type __off) const
      {
        bool __testoff = __off < this->size() - __pos;
        size_type __newoff = __testoff ? __off : this->size() - __pos;
        return (_M_ibegin() + __pos + __newoff);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
          for (; __k1 != __k2; ++__k1, ++__p)
            traits_type::assign(*__p, *__k1);
        }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)
      { traits_type::copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      { traits_type::copy(__p, __k1, __k2 - __k1); }

      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);

      void
      _M_leak_hard();

      static _Rep&
      _S_empty_rep()
      { return *reinterpret_cast<_Rep*>(&_S_empty_rep_storage); }

    public:




      inline
      basic_string();

      explicit
      basic_string(const _Alloc& __a);


      basic_string(const basic_string& __str);
      basic_string(const basic_string& __str, size_type __pos,
                   size_type __n = npos);
      basic_string(const basic_string& __str, size_type __pos,
                   size_type __n, const _Alloc& __a);

      basic_string(const _CharT* __s, size_type __n,
                   const _Alloc& __a = _Alloc());
      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());
      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());

      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
                     const _Alloc& __a = _Alloc());

      ~basic_string()
      { _M_rep()->_M_dispose(this->get_allocator()); }

      basic_string&
      operator=(const basic_string& __str) { return this->assign(__str); }

      basic_string&
      operator=(const _CharT* __s) { return this->assign(__s); }

      basic_string&
      operator=(_CharT __c) { return this->assign(1, __c); }


      iterator
      begin()
      {
        _M_leak();
        return iterator(_M_data());
      }

      const_iterator
      begin() const
      { return const_iterator(_M_data()); }

      iterator
      end()
      {
         _M_leak();
         return iterator(_M_data() + this->size());
      }

      const_iterator
      end() const
      { return const_iterator(_M_data() + this->size()); }

      reverse_iterator
      rbegin()
      { return reverse_iterator(this->end()); }

      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->end()); }

      reverse_iterator
      rend()
      { return reverse_iterator(this->begin()); }

      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->begin()); }

    public:

      size_type
      size() const { return _M_rep()->_M_length; }

      size_type
      length() const { return _M_rep()->_M_length; }

      size_type
      max_size() const { return _Rep::_S_max_size; }

      void
      resize(size_type __n, _CharT __c);

      void
      resize(size_type __n) { this->resize(__n, _CharT()); }

      size_type
      capacity() const { return _M_rep()->_M_capacity; }

      void
      reserve(size_type __res_arg = 0);

      void
      clear() { _M_mutate(0, this->size(), 0); }

      bool
      empty() const { return this->size() == 0; }


      const_reference
      operator[] (size_type __pos) const
      { return _M_data()[__pos]; }

      reference
      operator[](size_type __pos)
      {
        _M_leak();
        return _M_data()[__pos];
      }

      const_reference
      at(size_type __n) const
      {
        if (__n >= this->size())
          __throw_out_of_range("basic_string::at");
        return _M_data()[__n];
      }

      reference
      at(size_type __n)
      {
        if (__n >= size())
          __throw_out_of_range("basic_string::at");
        _M_leak();
        return _M_data()[__n];
      }


      basic_string&
      operator+=(const basic_string& __str) { return this->append(__str); }

      basic_string&
      operator+=(const _CharT* __s) { return this->append(__s); }

      basic_string&
      operator+=(_CharT __c) { return this->append(size_type(1), __c); }

      basic_string&
      append(const basic_string& __str);

      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);

      basic_string&
      append(const _CharT* __s, size_type __n);

      basic_string&
      append(const _CharT* __s)
      { return this->append(__s, traits_type::length(__s)); }

      basic_string&
      append(size_type __n, _CharT __c);

      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }

      void
      push_back(_CharT __c)
      { this->replace(_M_iend(), _M_iend(), 1, __c); }

      basic_string&
      assign(const basic_string& __str);

      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n);

      basic_string&
      assign(const _CharT* __s, size_type __n);

      basic_string&
      assign(const _CharT* __s)
      { return this->assign(__s, traits_type::length(__s)); }

      basic_string&
      assign(size_type __n, _CharT __c)
      { return this->replace(_M_ibegin(), _M_iend(), __n, __c); }

      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }

      void
      insert(iterator __p, size_type __n, _CharT __c)
      { this->replace(__p, __p, __n, __c); }

      template<class _InputIterator>
        void insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }

      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, 0, __str.size()); }

      basic_string&
      insert(size_type __pos1, const basic_string& __str,
             size_type __pos2, size_type __n);

      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n);

      basic_string&
      insert(size_type __pos, const _CharT* __s)
      { return this->insert(__pos, __s, traits_type::length(__s)); }

      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      {
        this->insert(_M_check(__pos), __n, __c);
        return *this;
      }

      iterator
      insert(iterator __p, _CharT __c = _CharT())
      {
        size_type __pos = __p - _M_ibegin();
        this->insert(_M_check(__pos), size_type(1), __c);
        _M_rep()->_M_set_leaked();
        return this->_M_ibegin() + __pos;
      }

      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
        return this->replace(_M_check(__pos), _M_fold(__pos, __n),
                             _M_data(), _M_data());
      }

      iterator
      erase(iterator __position)
      {
        size_type __i = __position - _M_ibegin();
        this->replace(__position, __position + 1, _M_data(), _M_data());
        _M_rep()->_M_set_leaked();
        return _M_ibegin() + __i;
      }

      iterator
      erase(iterator __first, iterator __last)
      {
        size_type __i = __first - _M_ibegin();
        this->replace(__first, __last, _M_data(), _M_data());
        _M_rep()->_M_set_leaked();
       return _M_ibegin() + __i;
      }

      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }

      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
              size_type __pos2, size_type __n2);

      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
              size_type __n2);

      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      { return this->replace(__pos, __n1, __s, traits_type::length(__s)); }

      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return this->replace(_M_check(__pos), _M_fold(__pos, __n1), __n2, __c); }

      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }

      basic_string&
      replace(iterator __i1, iterator __i2,
                           const _CharT* __s, size_type __n)
      { return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n); }

      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      { return this->replace(__i1, __i2, __s, traits_type::length(__s)); }

      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c);

      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
                _InputIterator __k1, _InputIterator __k2)
        { return _M_replace(__i1, __i2, __k1, __k2,
             typename iterator_traits<_InputIterator>::iterator_category()); }



      basic_string&
      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
        { return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
                               __k1, __k2 - __k1); }

      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __k1, const _CharT* __k2)
        { return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
                               __k1, __k2 - __k1); }

      basic_string&
      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
        { return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
                               __k1.base(), __k2 - __k1);
        }

      basic_string&
      replace(iterator __i1, iterator __i2, const_iterator __k1, const_iterator __k2)
        { return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
                               __k1.base(), __k2 - __k1);
        }

    private:
      template<class _InputIterator>
        basic_string&
        _M_replace(iterator __i1, iterator __i2, _InputIterator __k1,
                   _InputIterator __k2, input_iterator_tag);

      template<class _ForwardIterator>
        basic_string&
        _M_replace_safe(iterator __i1, iterator __i2, _ForwardIterator __k1,
                   _ForwardIterator __k2);



      template<class _InIter>
        static _CharT*
        _S_construct_aux(_InIter __beg, _InIter __end, const _Alloc& __a,
                         __false_type)
        {
          typedef typename iterator_traits<_InIter>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
        }

      template<class _InIter>
        static _CharT*
        _S_construct_aux(_InIter __beg, _InIter __end, const _Alloc& __a,
                         __true_type)
        {
          return _S_construct(static_cast<size_type>(__beg),
                              static_cast<value_type>(__end), __a);
        }

      template<class _InIter>
        static _CharT*
        _S_construct(_InIter __beg, _InIter __end, const _Alloc& __a)
        {
          typedef typename _Is_integer<_InIter>::_Integral _Integral;
          return _S_construct_aux(__beg, __end, __a, _Integral());
        }


      template<class _InIter>
        static _CharT*
         _S_construct(_InIter __beg, _InIter __end, const _Alloc& __a,
                      input_iterator_tag);



      template<class _FwdIter>
        static _CharT*
        _S_construct(_FwdIter __beg, _FwdIter __end, const _Alloc& __a,
                     forward_iterator_tag);

      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);

    public:

      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;

      void
      swap(basic_string<_CharT, _Traits, _Alloc>& __s);


      const _CharT*
      c_str() const
      {

        size_type __n = this->size();
        traits_type::assign(_M_data()[__n], _Rep::_S_terminal);
        return _M_data();
      }

      const _CharT*
      data() const { return _M_data(); }

      allocator_type
      get_allocator() const { return _M_dataplus; }

      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;

      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      { return this->find(__str.data(), __pos, __str.size()); }

      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      { return this->find(__s, __pos, traits_type::length(__s)); }

      size_type
      find(_CharT __c, size_type __pos = 0) const;

      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      { return this->rfind(__str.data(), __pos, __str.size()); }

      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;

      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      { return this->rfind(__s, __pos, traits_type::length(__s)); }

      size_type
      rfind(_CharT __c, size_type __pos = npos) const;

      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_of(__str.data(), __pos, __str.size()); }

      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;

      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      { return this->find_first_of(__s, __pos, traits_type::length(__s)); }

      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const
      { return this->find(__c, __pos); }

      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_of(__str.data(), __pos, __str.size()); }

      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;

      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      { return this->find_last_of(__s, __pos, traits_type::length(__s)); }

      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const
      { return this->rfind(__c, __pos); }

      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }

      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
                        size_type __n) const;

      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      { return this->find_first_not_of(__s, __pos, traits_type::length(__s)); }

      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const;

      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }

      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
                       size_type __n) const;
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      { return this->find_last_not_of(__s, __pos, traits_type::length(__s)); }

      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const;

      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      {
        if (__pos > this->size())
          __throw_out_of_range("basic_string::substr");
        return basic_string(*this, __pos, __n);
      }

      int
      compare(const basic_string& __str) const
      {
        size_type __size = this->size();
        size_type __osize = __str.size();
        size_type __len = std::min(__size, __osize);

        int __r = traits_type::compare(_M_data(), __str.data(), __len);
        if (!__r)
          __r = __size - __osize;
        return __r;
      }

      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;

      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
              size_type __pos2, size_type __n2) const;

      int
      compare(const _CharT* __s) const;



      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;

      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
              size_type __n2) const;
  };


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>::
    basic_string()
    : _M_dataplus(_S_empty_rep()._M_refcopy(), _Alloc()) { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
              const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
              const basic_string<_CharT,_Traits,_Alloc>& __rhs);

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
             const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
               const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
               const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
               const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
               const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) != 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
               const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) != 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
               const _CharT* __rhs)
    { return __lhs.compare(__rhs) != 0; }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
              const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
              const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
              const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
              const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
              const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
              const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
               const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
               const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
               const basic_string<_CharT, _Traits, _Alloc>& __rhs)
  { return __rhs.compare(__lhs) >= 0; }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
               const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
               const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
             const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
         basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
               basic_string<_CharT, _Traits, _Alloc>& __str);

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
               const basic_string<_CharT, _Traits, _Alloc>& __str);

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT,_Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
            basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT,_Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
            basic_string<_CharT, _Traits, _Alloc>& __str);
}
# 54 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/string" 2 3


# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/algorithm" 1 3
# 65 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/algorithm" 3




# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 1 3
# 64 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_heap.h" 1 3
# 63 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_heap.h" 3
namespace std
{



  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __push_heap(_RandomAccessIterator __first,
                _Distance __holeIndex, _Distance __topIndex, _Tp __value)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && *(__first + __parent) < __value) {
        *(__first + __holeIndex) = *(__first + __parent);
        __holeIndex = __parent;
        __parent = (__holeIndex - 1) / 2;
      }
      *(__first + __holeIndex) = __value;
    }

  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
          _DistanceType;


     

     

      __push_heap(__first, _DistanceType((__last - __first) - 1), _DistanceType(0),
                  _ValueType(*(__last - 1)));
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
            typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first, _Distance __holeIndex,
                _Distance __topIndex, _Tp __value, _Compare __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && __comp(*(__first + __parent), __value)) {
        *(__first + __holeIndex) = *(__first + __parent);
        __holeIndex = __parent;
        __parent = (__holeIndex - 1) / 2;
      }
      *(__first + __holeIndex) = __value;
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
              _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
          _DistanceType;


     


      __push_heap(__first, _DistanceType((__last - __first) - 1), _DistanceType(0),
                  _ValueType(*(__last - 1)), __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
                  _Distance __len, _Tp __value)
    {
      _Distance __topIndex = __holeIndex;
      _Distance __secondChild = 2 * __holeIndex + 2;
      while (__secondChild < __len) {
        if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))
          __secondChild--;
        *(__first + __holeIndex) = *(__first + __secondChild);
        __holeIndex = __secondChild;
        __secondChild = 2 * (__secondChild + 1);
      }
      if (__secondChild == __len) {
        *(__first + __holeIndex) = *(__first + (__secondChild - 1));
        __holeIndex = __secondChild - 1;
      }
      __push_heap(__first, __holeIndex, __topIndex, __value);
    }

  template<typename _RandomAccessIterator, typename _Tp>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
               _RandomAccessIterator __result, _Tp __value)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type _Distance;
      *__result = *__first;
      __adjust_heap(__first, _Distance(0), _Distance(__last - __first), __value);
    }

  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type _ValueType;


     

     

      __pop_heap(__first, __last - 1, __last - 1, _ValueType(*(__last - 1)));
    }

  template<typename _RandomAccessIterator, typename _Distance,
           typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
                  _Distance __len, _Tp __value, _Compare __comp)
    {
      _Distance __topIndex = __holeIndex;
      _Distance __secondChild = 2 * __holeIndex + 2;
      while (__secondChild < __len) {
        if (__comp(*(__first + __secondChild), *(__first + (__secondChild - 1))))
          __secondChild--;
        *(__first + __holeIndex) = *(__first + __secondChild);
        __holeIndex = __secondChild;
        __secondChild = 2 * (__secondChild + 1);
      }
      if (__secondChild == __len) {
        *(__first + __holeIndex) = *(__first + (__secondChild - 1));
        __holeIndex = __secondChild - 1;
      }
      __push_heap(__first, __holeIndex, __topIndex, __value, __comp);
    }

  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
               _RandomAccessIterator __result, _Tp __value, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type _Distance;
      *__result = *__first;
      __adjust_heap(__first, _Distance(0), _Distance(__last - __first),
                    __value, __comp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
             _RandomAccessIterator __last, _Compare __comp)
    {

     


      typedef typename iterator_traits<_RandomAccessIterator>::value_type _ValueType;
      __pop_heap(__first, __last - 1, __last - 1, _ValueType(*(__last - 1)), __comp);
    }

  template<typename _RandomAccessIterator>
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
          _DistanceType;


     

     

      if (__last - __first < 2) return;
      _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2)/2;

      while (true) {
        __adjust_heap(__first, __parent, __len, _ValueType(*(__first + __parent)));
        if (__parent == 0) return;
        __parent--;
      }
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
              _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
          _DistanceType;


     


      if (__last - __first < 2) return;
      _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2)/2;

      while (true) {
        __adjust_heap(__first, __parent, __len,
                      _ValueType(*(__first + __parent)), __comp);
        if (__parent == 0) return;
        __parent--;
      }
    }

  template<typename _RandomAccessIterator>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     


      while (__last - __first > 1)
        pop_heap(__first, __last--);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
              _Compare __comp)
    {

     


      while (__last - __first > 1)
        pop_heap(__first, __last--, __comp);
    }

}
# 65 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 2 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_tempbuf.h" 1 3
# 64 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_tempbuf.h" 3
namespace std
{
# 74 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_tempbuf.h" 3
template <class _ForwardIterator, class _Tp>
  class _Temporary_buffer
{

 

  ptrdiff_t _M_original_len;
  ptrdiff_t _M_len;
  _Tp* _M_buffer;


  void _M_allocate_buffer() {
    _M_original_len = _M_len;
    _M_buffer = 0;

    if (_M_len > (ptrdiff_t)(2147483647 / sizeof(_Tp)))
      _M_len = 2147483647 / sizeof(_Tp);

    while (_M_len > 0) {
      _M_buffer = (_Tp*) malloc(_M_len * sizeof(_Tp));
      if (_M_buffer)
        break;
      _M_len /= 2;
    }
  }

  void _M_initialize_buffer(const _Tp&, __true_type) {}
  void _M_initialize_buffer(const _Tp& val, __false_type) {
    uninitialized_fill_n(_M_buffer, _M_len, val);
  }

public:

  ptrdiff_t size() const { return _M_len; }

  ptrdiff_t requested_size() const { return _M_original_len; }

  _Tp* begin() { return _M_buffer; }

  _Tp* end() { return _M_buffer + _M_len; }

  _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last) {

    typedef typename __type_traits<_Tp>::has_trivial_default_constructor
            _Trivial;

    try {
      _M_len = distance(__first, __last);
      _M_allocate_buffer();
      if (_M_len > 0)
        _M_initialize_buffer(*__first, _Trivial());
    }
    catch(...)
      {
        free(_M_buffer);
        _M_buffer = 0;
        _M_len = 0;
        throw;
      }
  }

  ~_Temporary_buffer() {
    _Destroy(_M_buffer, _M_buffer + _M_len);
    free(_M_buffer);
  }

private:

  _Temporary_buffer(const _Temporary_buffer&) {}
  void operator=(const _Temporary_buffer&) {}
};

}
# 66 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 2 3



namespace std
{
# 84 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _Tp>
  inline const _Tp&
    __median(const _Tp& __a, const _Tp& __b, const _Tp& __c)
    {

     
      if (__a < __b)
        if (__b < __c)
          return __b;
        else if (__a < __c)
          return __c;
        else
          return __a;
      else if (__a < __c)
        return __a;
      else if (__b < __c)
        return __c;
      else
        return __b;
    }
# 118 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    __median(const _Tp& __a, const _Tp& __b, const _Tp& __c, _Compare __comp)
    {

     
      if (__comp(__a, __b))
        if (__comp(__b, __c))
          return __b;
        else if (__comp(__a, __c))
          return __c;
        else
          return __a;
      else if (__comp(__a, __c))
        return __a;
      else if (__comp(__b, __c))
        return __c;
      else
        return __b;
    }
# 150 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _InputIter, typename _Function>
    _Function
    for_each(_InputIter __first, _InputIter __last, _Function __f)
    {

     
      for ( ; __first != __last; ++__first)
        __f(*__first);
      return __f;
    }






  template<typename _InputIter, typename _Tp>
    inline _InputIter
    find(_InputIter __first, _InputIter __last,
         const _Tp& __val,
         input_iterator_tag)
    {
      while (__first != __last && !(*__first == __val))
        ++__first;
      return __first;
    }






  template<typename _InputIter, typename _Predicate>
    inline _InputIter
    find_if(_InputIter __first, _InputIter __last,
            _Predicate __pred,
            input_iterator_tag)
    {
      while (__first != __last && !__pred(*__first))
        ++__first;
      return __first;
    }






  template<typename _RandomAccessIter, typename _Tp>
    _RandomAccessIter
    find(_RandomAccessIter __first, _RandomAccessIter __last,
         const _Tp& __val,
         random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIter>::difference_type __trip_count
        = (__last - __first) >> 2;

      for ( ; __trip_count > 0 ; --__trip_count) {
        if (*__first == __val) return __first;
        ++__first;

        if (*__first == __val) return __first;
        ++__first;

        if (*__first == __val) return __first;
        ++__first;

        if (*__first == __val) return __first;
        ++__first;
      }

      switch(__last - __first) {
      case 3:
        if (*__first == __val) return __first;
        ++__first;
      case 2:
        if (*__first == __val) return __first;
        ++__first;
      case 1:
        if (*__first == __val) return __first;
        ++__first;
      case 0:
      default:
        return __last;
      }
    }






  template<typename _RandomAccessIter, typename _Predicate>
    _RandomAccessIter
    find_if(_RandomAccessIter __first, _RandomAccessIter __last,
            _Predicate __pred,
            random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIter>::difference_type __trip_count
        = (__last - __first) >> 2;

      for ( ; __trip_count > 0 ; --__trip_count) {
        if (__pred(*__first)) return __first;
        ++__first;

        if (__pred(*__first)) return __first;
        ++__first;

        if (__pred(*__first)) return __first;
        ++__first;

        if (__pred(*__first)) return __first;
        ++__first;
      }

      switch(__last - __first) {
      case 3:
        if (__pred(*__first)) return __first;
        ++__first;
      case 2:
        if (__pred(*__first)) return __first;
        ++__first;
      case 1:
        if (__pred(*__first)) return __first;
        ++__first;
      case 0:
      default:
        return __last;
      }
    }
# 289 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _InputIter, typename _Tp>
    inline _InputIter
    find(_InputIter __first, _InputIter __last,
         const _Tp& __val)
    {

     
     

      return find(__first, __last, __val, __iterator_category(__first));
    }
# 309 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _InputIter, typename _Predicate>
    inline _InputIter
    find_if(_InputIter __first, _InputIter __last,
            _Predicate __pred)
    {

     
     

      return find_if(__first, __last, __pred, __iterator_category(__first));
    }
# 329 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _ForwardIter>
    _ForwardIter
    adjacent_find(_ForwardIter __first, _ForwardIter __last)
    {

     
     

      if (__first == __last)
        return __last;
      _ForwardIter __next = __first;
      while(++__next != __last) {
        if (*__first == *__next)
          return __first;
        __first = __next;
      }
      return __last;
    }
# 358 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _BinaryPredicate>
    _ForwardIter
    adjacent_find(_ForwardIter __first, _ForwardIter __last,
                  _BinaryPredicate __binary_pred)
    {

     
     


      if (__first == __last)
        return __last;
      _ForwardIter __next = __first;
      while(++__next != __last) {
        if (__binary_pred(*__first, *__next))
          return __first;
        __first = __next;
      }
      return __last;
    }
# 387 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _InputIter, typename _Tp>
    typename iterator_traits<_InputIter>::difference_type
    count(_InputIter __first, _InputIter __last, const _Tp& __value)
    {

     
     

     
      typename iterator_traits<_InputIter>::difference_type __n = 0;
      for ( ; __first != __last; ++__first)
        if (*__first == __value)
          ++__n;
      return __n;
    }
# 411 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _InputIter, typename _Predicate>
    typename iterator_traits<_InputIter>::difference_type
    count_if(_InputIter __first, _InputIter __last, _Predicate __pred)
    {

     
     

      typename iterator_traits<_InputIter>::difference_type __n = 0;
      for ( ; __first != __last; ++__first)
        if (__pred(*__first))
          ++__n;
      return __n;
    }
# 450 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _ForwardIter1, typename _ForwardIter2>
    _ForwardIter1
    search(_ForwardIter1 __first1, _ForwardIter1 __last1,
           _ForwardIter2 __first2, _ForwardIter2 __last2)
    {

     
     
     




      if (__first1 == __last1 || __first2 == __last2)
        return __first1;


      _ForwardIter2 __tmp(__first2);
      ++__tmp;
      if (__tmp == __last2)
        return find(__first1, __last1, *__first2);



      _ForwardIter2 __p1, __p;

      __p1 = __first2; ++__p1;

      _ForwardIter1 __current = __first1;

      while (__first1 != __last1) {
        __first1 = find(__first1, __last1, *__first2);
        if (__first1 == __last1)
          return __last1;

        __p = __p1;
        __current = __first1;
        if (++__current == __last1)
          return __last1;

        while (*__current == *__p) {
          if (++__p == __last2)
            return __first1;
          if (++__current == __last1)
            return __last1;
        }

        ++__first1;
      }
      return __first1;
    }
# 522 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _ForwardIter1, typename _ForwardIter2, typename _BinaryPred>
    _ForwardIter1
    search(_ForwardIter1 __first1, _ForwardIter1 __last1,
           _ForwardIter2 __first2, _ForwardIter2 __last2,
           _BinaryPred __predicate)
    {

     
     
     




      if (__first1 == __last1 || __first2 == __last2)
        return __first1;


      _ForwardIter2 __tmp(__first2);
      ++__tmp;
      if (__tmp == __last2) {
        while (__first1 != __last1 && !__predicate(*__first1, *__first2))
          ++__first1;
        return __first1;
      }



      _ForwardIter2 __p1, __p;

      __p1 = __first2; ++__p1;

      _ForwardIter1 __current = __first1;

      while (__first1 != __last1) {
        while (__first1 != __last1) {
          if (__predicate(*__first1, *__first2))
            break;
          ++__first1;
        }
        while (__first1 != __last1 && !__predicate(*__first1, *__first2))
          ++__first1;
        if (__first1 == __last1)
          return __last1;

        __p = __p1;
        __current = __first1;
        if (++__current == __last1) return __last1;

        while (__predicate(*__current, *__p)) {
          if (++__p == __last2)
            return __first1;
          if (++__current == __last1)
            return __last1;
        }

        ++__first1;
      }
      return __first1;
    }
# 596 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Integer, typename _Tp>
    _ForwardIter
    search_n(_ForwardIter __first, _ForwardIter __last,
             _Integer __count, const _Tp& __val)
    {

     
     

     

      if (__count <= 0)
        return __first;
      else {
        __first = find(__first, __last, __val);
        while (__first != __last) {
          _Integer __n = __count - 1;
          _ForwardIter __i = __first;
          ++__i;
          while (__i != __last && __n != 0 && *__i == __val) {
            ++__i;
            --__n;
          }
          if (__n == 0)
            return __first;
          else
            __first = find(__i, __last, __val);
        }
        return __last;
      }
    }
# 643 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Integer, typename _Tp,
           typename _BinaryPred>
    _ForwardIter
    search_n(_ForwardIter __first, _ForwardIter __last,
             _Integer __count, const _Tp& __val,
             _BinaryPred __binary_pred)
    {

     
     


      if (__count <= 0)
        return __first;
      else {
        while (__first != __last) {
          if (__binary_pred(*__first, __val))
            break;
          ++__first;
        }
        while (__first != __last) {
          _Integer __n = __count - 1;
          _ForwardIter __i = __first;
          ++__i;
          while (__i != __last && __n != 0 && __binary_pred(*__i, __val)) {
            ++__i;
            --__n;
          }
          if (__n == 0)
            return __first;
          else {
            while (__i != __last) {
              if (__binary_pred(*__i, __val))
                break;
              ++__i;
            }
            __first = __i;
          }
        }
        return __last;
      }
    }
# 697 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _ForwardIter1, typename _ForwardIter2>
    _ForwardIter2
    swap_ranges(_ForwardIter1 __first1, _ForwardIter1 __last1,
                _ForwardIter2 __first2)
    {

     
     
     


     



      for ( ; __first1 != __last1; ++__first1, ++__first2)
        iter_swap(__first1, __first2);
      return __first2;
    }
# 732 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _InputIter, typename _OutputIter, typename _UnaryOperation>
    _OutputIter
    transform(_InputIter __first, _InputIter __last,
              _OutputIter __result, _UnaryOperation __unary_op)
    {

     
     



      for ( ; __first != __last; ++__first, ++__result)
        *__result = __unary_op(*__first);
      return __result;
    }
# 765 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _InputIter1, typename _InputIter2, typename _OutputIter,
           typename _BinaryOperation>
    _OutputIter
    transform(_InputIter1 __first1, _InputIter1 __last1,
              _InputIter2 __first2, _OutputIter __result,
              _BinaryOperation __binary_op)
    {

     
     
     



      for ( ; __first1 != __last1; ++__first1, ++__first2, ++__result)
        *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
# 796 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Tp>
    void
    replace(_ForwardIter __first, _ForwardIter __last,
            const _Tp& __old_value, const _Tp& __new_value)
    {

     
     

     


      for ( ; __first != __last; ++__first)
        if (*__first == __old_value)
          *__first = __new_value;
    }
# 825 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIter __first, _ForwardIter __last,
               _Predicate __pred, const _Tp& __new_value)
    {

     
     

     


      for ( ; __first != __last; ++__first)
        if (__pred(*__first))
          *__first = __new_value;
    }
# 856 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _InputIter, typename _OutputIter, typename _Tp>
    _OutputIter
    replace_copy(_InputIter __first, _InputIter __last,
                 _OutputIter __result,
                 const _Tp& __old_value, const _Tp& __new_value)
    {

     
     

     


      for ( ; __first != __last; ++__first, ++__result)
        *__result = *__first == __old_value ? __new_value : *__first;
      return __result;
    }
# 888 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _InputIter, typename _OutputIter, typename _Predicate,
           typename _Tp>
    _OutputIter
    replace_copy_if(_InputIter __first, _InputIter __last,
                    _OutputIter __result,
                    _Predicate __pred, const _Tp& __new_value)
    {

     
     

     


      for ( ; __first != __last; ++__first, ++__result)
        *__result = __pred(*__first) ? __new_value : *__first;
      return __result;
    }
# 918 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Generator>
    void
    generate(_ForwardIter __first, _ForwardIter __last, _Generator __gen)
    {

     
     


      for ( ; __first != __last; ++__first)
        *__first = __gen();
    }
# 942 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _OutputIter, typename _Size, typename _Generator>
    _OutputIter
    generate_n(_OutputIter __first, _Size __n, _Generator __gen)
    {

     



      for ( ; __n > 0; --__n, ++__first)
        *__first = __gen();
      return __first;
    }
# 969 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _InputIter, typename _OutputIter, typename _Tp>
    _OutputIter
    remove_copy(_InputIter __first, _InputIter __last,
                _OutputIter __result, const _Tp& __value)
    {

     
     

     


      for ( ; __first != __last; ++__first)
        if (!(*__first == __value)) {
          *__result = *__first;
          ++__result;
        }
      return __result;
    }
# 1003 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _InputIter, typename _OutputIter, typename _Predicate>
    _OutputIter
    remove_copy_if(_InputIter __first, _InputIter __last,
                   _OutputIter __result, _Predicate __pred)
    {

     
     

     


      for ( ; __first != __last; ++__first)
        if (!__pred(*__first)) {
          *__result = *__first;
          ++__result;
        }
      return __result;
    }
# 1039 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Tp>
    _ForwardIter
    remove(_ForwardIter __first, _ForwardIter __last,
           const _Tp& __value)
    {

     
     

     


      __first = find(__first, __last, __value);
      _ForwardIter __i = __first;
      return __first == __last ? __first
                               : remove_copy(++__i, __last, __first, __value);
    }
# 1073 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Predicate>
    _ForwardIter
    remove_if(_ForwardIter __first, _ForwardIter __last,
              _Predicate __pred)
    {

     
     


      __first = find_if(__first, __last, __pred);
      _ForwardIter __i = __first;
      return __first == __last ? __first
                               : remove_copy_if(++__i, __last, __first, __pred);
    }







  template<typename _InputIter, typename _OutputIter>
    _OutputIter
    __unique_copy(_InputIter __first, _InputIter __last,
                  _OutputIter __result,
                  output_iterator_tag)
    {

      typename iterator_traits<_InputIter>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
        if (!(__value == *__first)) {
          __value = *__first;
          *++__result = __value;
        }
      return ++__result;
    }







  template<typename _InputIter, typename _ForwardIter>
    _ForwardIter
    __unique_copy(_InputIter __first, _InputIter __last,
                  _ForwardIter __result,
                  forward_iterator_tag)
    {

      *__result = *__first;
      while (++__first != __last)
        if (!(*__result == *__first))
          *++__result = *__first;
      return ++__result;
    }
# 1145 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _InputIter, typename _OutputIter>
    inline _OutputIter
    unique_copy(_InputIter __first, _InputIter __last,
                _OutputIter __result)
    {

     
     

     


      typedef typename iterator_traits<_OutputIter>::iterator_category _IterType;

      if (__first == __last) return __result;
      return __unique_copy(__first, __last, __result, _IterType());
    }
# 1170 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _InputIter, typename _OutputIter, typename _BinaryPredicate>
    _OutputIter
    __unique_copy(_InputIter __first, _InputIter __last,
                  _OutputIter __result,
                  _BinaryPredicate __binary_pred,
                  output_iterator_tag)
    {

     



      typename iterator_traits<_InputIter>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
        if (!__binary_pred(__value, *__first)) {
          __value = *__first;
          *++__result = __value;
        }
      return ++__result;
    }
# 1199 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _InputIter, typename _ForwardIter, typename _BinaryPredicate>
    _ForwardIter
    __unique_copy(_InputIter __first, _InputIter __last,
                  _ForwardIter __result,
                  _BinaryPredicate __binary_pred,
                  forward_iterator_tag)
    {

     



      *__result = *__first;
      while (++__first != __last)
        if (!__binary_pred(*__result, *__first)) *++__result = *__first;
      return ++__result;
    }
# 1232 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _InputIter, typename _OutputIter, typename _BinaryPredicate>
    inline _OutputIter
    unique_copy(_InputIter __first, _InputIter __last,
                _OutputIter __result,
                _BinaryPredicate __binary_pred)
    {

     
     


      typedef typename iterator_traits<_OutputIter>::iterator_category _IterType;

      if (__first == __last) return __result;
      return __unique_copy(__first, __last,
__result, __binary_pred, _IterType());
    }
# 1263 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _ForwardIter>
    _ForwardIter
    unique(_ForwardIter __first, _ForwardIter __last)
    {

         
         


          __first = adjacent_find(__first, __last);
          return unique_copy(__first, __last, __first);
    }
# 1290 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _BinaryPredicate>
    _ForwardIter
    unique(_ForwardIter __first, _ForwardIter __last,
           _BinaryPredicate __binary_pred)
    {

     
     



      __first = adjacent_find(__first, __last, __binary_pred);
      return unique_copy(__first, __last, __first, __binary_pred);
    }







  template<typename _BidirectionalIter>
    void
    __reverse(_BidirectionalIter __first, _BidirectionalIter __last,
                          bidirectional_iterator_tag)
    {
          while (true)
            if (__first == __last || __first == --__last)
                  return;
            else
                  iter_swap(__first++, __last);
    }







  template<typename _RandomAccessIter>
    void
    __reverse(_RandomAccessIter __first, _RandomAccessIter __last,
                          random_access_iterator_tag)
    {
          while (__first < __last)
            iter_swap(__first++, --__last);
    }
# 1349 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIter>
    inline void
    reverse(_BidirectionalIter __first, _BidirectionalIter __last)
    {

         

          __reverse(__first, __last, __iterator_category(__first));
    }
# 1374 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIter, typename _OutputIter>
    _OutputIter
    reverse_copy(_BidirectionalIter __first, _BidirectionalIter __last,
                             _OutputIter __result)
    {

     
     


      while (__first != __last) {
        --__last;
        *__result = *__last;
        ++__result;
      }
      return __result;
    }
# 1399 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0) {
        _EuclideanRingElement __t = __m % __n;
        __m = __n;
        __n = __t;
      }
      return __m;
    }






  template<typename _ForwardIter>
    void
    __rotate(_ForwardIter __first,
             _ForwardIter __middle,
             _ForwardIter __last,
              forward_iterator_tag)
    {
      if ((__first == __middle) || (__last == __middle))
        return;

      _ForwardIter __first2 = __middle;
      do {
        swap(*__first++, *__first2++);
        if (__first == __middle)
          __middle = __first2;
      } while (__first2 != __last);

      __first2 = __middle;

      while (__first2 != __last) {
        swap(*__first++, *__first2++);
        if (__first == __middle)
          __middle = __first2;
        else if (__first2 == __last)
          __first2 = __middle;
      }
    }






  template<typename _BidirectionalIter>
    void
    __rotate(_BidirectionalIter __first,
             _BidirectionalIter __middle,
             _BidirectionalIter __last,
              bidirectional_iterator_tag)
    {

     


      if ((__first == __middle) || (__last == __middle))
        return;

      __reverse(__first, __middle, bidirectional_iterator_tag());
      __reverse(__middle, __last, bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
        swap (*__first++, *--__last);

      if (__first == __middle) {
        __reverse(__middle, __last, bidirectional_iterator_tag());
      }
      else {
        __reverse(__first, __middle, bidirectional_iterator_tag());
      }
    }






  template<typename _RandomAccessIter>
    void
    __rotate(_RandomAccessIter __first,
             _RandomAccessIter __middle,
             _RandomAccessIter __last,
             random_access_iterator_tag)
    {

     


      if ((__first == __middle) || (__last == __middle))
        return;

      typedef typename iterator_traits<_RandomAccessIter>::difference_type _Distance;
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;

      _Distance __n = __last - __first;
      _Distance __k = __middle - __first;
      _Distance __l = __n - __k;

      if (__k == __l) {
        swap_ranges(__first, __middle, __middle);
        return;
      }

      _Distance __d = __gcd(__n, __k);

      for (_Distance __i = 0; __i < __d; __i++) {
        _ValueType __tmp = *__first;
        _RandomAccessIter __p = __first;

        if (__k < __l) {
          for (_Distance __j = 0; __j < __l/__d; __j++) {
            if (__p > __first + __l) {
              *__p = *(__p - __l);
              __p -= __l;
            }

            *__p = *(__p + __k);
            __p += __k;
          }
        }

        else {
          for (_Distance __j = 0; __j < __k/__d - 1; __j ++) {
            if (__p < __last - __k) {
              *__p = *(__p + __k);
              __p += __k;
            }

            *__p = * (__p - __l);
            __p -= __l;
          }
        }

        *__p = __tmp;
        ++__first;
      }
    }
# 1561 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _ForwardIter>
    inline void
    rotate(_ForwardIter __first, _ForwardIter __middle, _ForwardIter __last)
    {

     

      typedef typename iterator_traits<_ForwardIter>::iterator_category _IterType;
      __rotate(__first, __middle, __last, _IterType());
    }
# 1589 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _OutputIter>
    _OutputIter
    rotate_copy(_ForwardIter __first, _ForwardIter __middle,
                _ForwardIter __last, _OutputIter __result)
    {

     
     


      return copy(__first, __middle, copy(__middle, __last, __result));
    }
# 1612 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _Distance>
    inline _Distance
    __random_number(_Distance __n)
    {

      return lrand48() % __n;



    }
# 1634 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIter>
    inline void
    random_shuffle(_RandomAccessIter __first, _RandomAccessIter __last)
    {

     


      if (__first == __last) return;
      for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
        iter_swap(__i, __first + __random_number((__i - __first) + 1));
    }
# 1660 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIter, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIter __first, _RandomAccessIter __last,
                   _RandomNumberGenerator& __rand)
    {

     


      if (__first == __last) return;
      for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
        iter_swap(__i, __first + __rand((__i - __first) + 1));
    }







  template<typename _ForwardIter, typename _Predicate>
    _ForwardIter
    __partition(_ForwardIter __first, _ForwardIter __last,
                _Predicate __pred,
                forward_iterator_tag)
    {
      if (__first == __last) return __first;

      while (__pred(*__first))
        if (++__first == __last) return __first;

      _ForwardIter __next = __first;

      while (++__next != __last)
        if (__pred(*__next)) {
          swap(*__first, *__next);
          ++__first;
        }

      return __first;
    }






  template<typename _BidirectionalIter, typename _Predicate>
    _BidirectionalIter
    __partition(_BidirectionalIter __first, _BidirectionalIter __last,
                _Predicate __pred,
                bidirectional_iterator_tag)
    {
      while (true) {
        while (true)
          if (__first == __last)
            return __first;
          else if (__pred(*__first))
            ++__first;
          else
            break;
        --__last;
        while (true)
          if (__first == __last)
            return __first;
          else if (!__pred(*__last))
            --__last;
          else
            break;
        iter_swap(__first, __last);
        ++__first;
      }
    }
# 1748 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Predicate>
    inline _ForwardIter
    partition(_ForwardIter __first, _ForwardIter __last,
              _Predicate __pred)
    {

     
     


      return __partition(__first, __last, __pred, __iterator_category(__first));
    }







  template<typename _ForwardIter, typename _Predicate, typename _Distance>
    _ForwardIter
    __inplace_stable_partition(_ForwardIter __first, _ForwardIter __last,
                               _Predicate __pred, _Distance __len)
    {
      if (__len == 1)
        return __pred(*__first) ? __last : __first;
      _ForwardIter __middle = __first;
      advance(__middle, __len / 2);
      _ForwardIter __begin = __inplace_stable_partition(__first, __middle,
                                                        __pred,
                                                        __len / 2);
      _ForwardIter __end = __inplace_stable_partition(__middle, __last,
                                                      __pred,
                                                      __len - __len / 2);
      rotate(__begin, __middle, __end);
      advance(__begin, distance(__middle, __end));
      return __begin;
    }






  template<typename _ForwardIter, typename _Pointer, typename _Predicate,
           typename _Distance>
    _ForwardIter
    __stable_partition_adaptive(_ForwardIter __first, _ForwardIter __last,
                                _Predicate __pred, _Distance __len,
                                _Pointer __buffer,
                                _Distance __buffer_size)
    {
      if (__len <= __buffer_size) {
        _ForwardIter __result1 = __first;
        _Pointer __result2 = __buffer;
        for ( ; __first != __last ; ++__first)
          if (__pred(*__first)) {
            *__result1 = *__first;
            ++__result1;
          }
          else {
            *__result2 = *__first;
            ++__result2;
          }
        copy(__buffer, __result2, __result1);
        return __result1;
      }
      else {
        _ForwardIter __middle = __first;
        advance(__middle, __len / 2);
        _ForwardIter __begin = __stable_partition_adaptive(__first, __middle,
                                                           __pred,
                                                           __len / 2,
                                                           __buffer, __buffer_size);
        _ForwardIter __end = __stable_partition_adaptive( __middle, __last,
                                                          __pred,
                                                          __len - __len / 2,
                                                          __buffer, __buffer_size);
        rotate(__begin, __middle, __end);
        advance(__begin, distance(__middle, __end));
        return __begin;
      }
    }
# 1848 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Predicate>
    _ForwardIter
    stable_partition(_ForwardIter __first, _ForwardIter __last,
                     _Predicate __pred)
    {

     
     


      if (__first == __last)
        return __first;
      else
      {
        typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;
        typedef typename iterator_traits<_ForwardIter>::difference_type _DistanceType;

        _Temporary_buffer<_ForwardIter, _ValueType> __buf(__first, __last);
        if (__buf.size() > 0)
          return __stable_partition_adaptive(__first, __last, __pred,
                                             _DistanceType(__buf.requested_size()),
                                             __buf.begin(), __buf.size());
        else
          return __inplace_stable_partition(__first, __last, __pred,
                                            _DistanceType(__buf.requested_size()));
      }
    }






  template<typename _RandomAccessIter, typename _Tp>
    _RandomAccessIter
    __unguarded_partition(_RandomAccessIter __first, _RandomAccessIter __last,
                          _Tp __pivot)
    {
      while (true) {
        while (*__first < __pivot)
          ++__first;
        --__last;
        while (__pivot < *__last)
          --__last;
        if (!(__first < __last))
          return __first;
        iter_swap(__first, __last);
        ++__first;
      }
    }






  template<typename _RandomAccessIter, typename _Tp, typename _Compare>
    _RandomAccessIter
    __unguarded_partition(_RandomAccessIter __first, _RandomAccessIter __last,
                          _Tp __pivot, _Compare __comp)
    {
      while (true) {
        while (__comp(*__first, __pivot))
          ++__first;
        --__last;
        while (__comp(__pivot, *__last))
          --__last;
        if (!(__first < __last))
          return __first;
        iter_swap(__first, __last);
        ++__first;
      }
    }
# 1929 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  enum { _M_threshold = 16 };






  template<typename _RandomAccessIter, typename _Tp>
    void
    __unguarded_linear_insert(_RandomAccessIter __last, _Tp __val)
    {
      _RandomAccessIter __next = __last;
      --__next;
      while (__val < *__next) {
        *__last = *__next;
        __last = __next;
        --__next;
      }
      *__last = __val;
    }






  template<typename _RandomAccessIter, typename _Tp, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIter __last, _Tp __val, _Compare __comp)
    {
      _RandomAccessIter __next = __last;
      --__next;
      while (__comp(__val, *__next)) {
        *__last = *__next;
        __last = __next;
        --__next;
      }
      *__last = __val;
    }






  template<typename _RandomAccessIter>
    void
    __insertion_sort(_RandomAccessIter __first, _RandomAccessIter __last)
    {
      if (__first == __last) return;

      for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
      {
        typename iterator_traits<_RandomAccessIter>::value_type __val = *__i;
        if (__val < *__first) {
          copy_backward(__first, __i, __i + 1);
          *__first = __val;
        }
        else
          __unguarded_linear_insert(__i, __val);
      }
    }






  template<typename _RandomAccessIter, typename _Compare>
    void
    __insertion_sort(_RandomAccessIter __first, _RandomAccessIter __last,
                     _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
      {
        typename iterator_traits<_RandomAccessIter>::value_type __val = *__i;
        if (__comp(__val, *__first)) {
          copy_backward(__first, __i, __i + 1);
          *__first = __val;
        }
        else
          __unguarded_linear_insert(__i, __val, __comp);
      }
    }






  template<typename _RandomAccessIter>
    inline void
    __unguarded_insertion_sort(_RandomAccessIter __first, _RandomAccessIter __last)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;

      for (_RandomAccessIter __i = __first; __i != __last; ++__i)
        __unguarded_linear_insert(__i, _ValueType(*__i));
    }






  template<typename _RandomAccessIter, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIter __first, _RandomAccessIter __last,
                               _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;

      for (_RandomAccessIter __i = __first; __i != __last; ++__i)
        __unguarded_linear_insert(__i, _ValueType(*__i), __comp);
    }






  template<typename _RandomAccessIter>
    void
    __final_insertion_sort(_RandomAccessIter __first, _RandomAccessIter __last)
    {
      if (__last - __first > _M_threshold) {
        __insertion_sort(__first, __first + _M_threshold);
        __unguarded_insertion_sort(__first + _M_threshold, __last);
      }
      else
        __insertion_sort(__first, __last);
    }






  template<typename _RandomAccessIter, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIter __first, _RandomAccessIter __last,
                           _Compare __comp)
    {
      if (__last - __first > _M_threshold) {
        __insertion_sort(__first, __first + _M_threshold, __comp);
        __unguarded_insertion_sort(__first + _M_threshold, __last, __comp);
      }
      else
        __insertion_sort(__first, __last, __comp);
    }






  template<typename _Size>
    inline _Size
    __lg(_Size __n)
    {
      _Size __k;
      for (__k = 0; __n != 1; __n >>= 1) ++__k;
      return __k;
    }






  template<typename _RandomAccessIter, typename _Size>
    void
    __introsort_loop(_RandomAccessIter __first, _RandomAccessIter __last,
                     _Size __depth_limit)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;

      while (__last - __first > _M_threshold) {
        if (__depth_limit == 0) {
          partial_sort(__first, __last, __last);
          return;
        }
        --__depth_limit;
        _RandomAccessIter __cut =
          __unguarded_partition(__first, __last,
                                _ValueType(__median(*__first,
                                                    *(__first + (__last - __first)/2),
                                                    *(__last - 1))));
        __introsort_loop(__cut, __last, __depth_limit);
        __last = __cut;
      }
    }






  template<typename _RandomAccessIter, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIter __first, _RandomAccessIter __last,
                     _Size __depth_limit, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;

      while (__last - __first > _M_threshold) {
        if (__depth_limit == 0) {
          partial_sort(__first, __last, __last, __comp);
          return;
        }
        --__depth_limit;
        _RandomAccessIter __cut =
          __unguarded_partition(__first, __last,
                                _ValueType(__median(*__first,
                                                    *(__first + (__last - __first)/2),
                                                    *(__last - 1), __comp)),
           __comp);
        __introsort_loop(__cut, __last, __depth_limit, __comp);
        __last = __cut;
      }
    }
# 2166 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIter>
    inline void
    sort(_RandomAccessIter __first, _RandomAccessIter __last)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;


     

     

      if (__first != __last) {
        __introsort_loop(__first, __last, __lg(__last - __first) * 2);
        __final_insertion_sort(__first, __last);
      }
    }
# 2197 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIter, typename _Compare>
    inline void
    sort(_RandomAccessIter __first, _RandomAccessIter __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;


     

     

      if (__first != __last) {
        __introsort_loop(__first, __last, __lg(__last - __first) * 2, __comp);
        __final_insertion_sort(__first, __last, __comp);
      }
    }







  template<typename _RandomAccessIter>
    void
    __inplace_stable_sort(_RandomAccessIter __first, _RandomAccessIter __last)
    {
      if (__last - __first < 15) {
        __insertion_sort(__first, __last);
        return;
      }
      _RandomAccessIter __middle = __first + (__last - __first) / 2;
      __inplace_stable_sort(__first, __middle);
      __inplace_stable_sort(__middle, __last);
      __merge_without_buffer(__first, __middle, __last,
                             __middle - __first,
                             __last - __middle);
    }






  template<typename _RandomAccessIter, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIter __first, _RandomAccessIter __last,
                          _Compare __comp)
    {
      if (__last - __first < 15) {
        __insertion_sort(__first, __last, __comp);
        return;
      }
      _RandomAccessIter __middle = __first + (__last - __first) / 2;
      __inplace_stable_sort(__first, __middle, __comp);
      __inplace_stable_sort(__middle, __last, __comp);
      __merge_without_buffer(__first, __middle, __last,
                             __middle - __first,
                             __last - __middle,
                             __comp);
    }

  template<typename _RandomAccessIter1, typename _RandomAccessIter2,
           typename _Distance>
    void
    __merge_sort_loop(_RandomAccessIter1 __first, _RandomAccessIter1 __last,
                      _RandomAccessIter2 __result, _Distance __step_size)
    {
      _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step) {
        __result = merge(__first, __first + __step_size,
                         __first + __step_size, __first + __two_step,
                         __result);
        __first += __two_step;
      }

      __step_size = min(_Distance(__last - __first), __step_size);
      merge(__first, __first + __step_size, __first + __step_size, __last,
            __result);
    }

  template<typename _RandomAccessIter1, typename _RandomAccessIter2,
           typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIter1 __first, _RandomAccessIter1 __last,
                      _RandomAccessIter2 __result, _Distance __step_size,
                      _Compare __comp)
    {
      _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step) {
        __result = merge(__first, __first + __step_size,
                         __first + __step_size, __first + __two_step,
                         __result,
                         __comp);
        __first += __two_step;
      }
      __step_size = min(_Distance(__last - __first), __step_size);

      merge(__first, __first + __step_size,
            __first + __step_size, __last,
            __result,
            __comp);
    }

  enum { _M_chunk_size = 7 };

  template<typename _RandomAccessIter, typename _Distance>
    void
    __chunk_insertion_sort(_RandomAccessIter __first, _RandomAccessIter __last,
                           _Distance __chunk_size)
    {
      while (__last - __first >= __chunk_size) {
        __insertion_sort(__first, __first + __chunk_size);
        __first += __chunk_size;
      }
      __insertion_sort(__first, __last);
    }

  template<typename _RandomAccessIter, typename _Distance, typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIter __first, _RandomAccessIter __last,
                           _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size) {
        __insertion_sort(__first, __first + __chunk_size, __comp);
        __first += __chunk_size;
      }
      __insertion_sort(__first, __last, __comp);
    }

  template<typename _RandomAccessIter, typename _Pointer>
    void
    __merge_sort_with_buffer(_RandomAccessIter __first, _RandomAccessIter __last,
                             _Pointer __buffer)
    {
      typedef typename iterator_traits<_RandomAccessIter>::difference_type _Distance;

      _Distance __len = __last - __first;
      _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _M_chunk_size;
      __chunk_insertion_sort(__first, __last, __step_size);

      while (__step_size < __len) {
        __merge_sort_loop(__first, __last, __buffer, __step_size);
        __step_size *= 2;
        __merge_sort_loop(__buffer, __buffer_last, __first, __step_size);
        __step_size *= 2;
      }
    }

  template<typename _RandomAccessIter, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIter __first, _RandomAccessIter __last,
                             _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIter>::difference_type _Distance;

      _Distance __len = __last - __first;
      _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _M_chunk_size;
      __chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len) {
        __merge_sort_loop(__first, __last, __buffer, __step_size, __comp);
        __step_size *= 2;
        __merge_sort_loop(__buffer, __buffer_last, __first, __step_size, __comp);
        __step_size *= 2;
      }
    }

  template<typename _RandomAccessIter, typename _Pointer, typename _Distance>
    void
    __stable_sort_adaptive(_RandomAccessIter __first, _RandomAccessIter __last,
                           _Pointer __buffer, _Distance __buffer_size)
    {
      _Distance __len = (__last - __first + 1) / 2;
      _RandomAccessIter __middle = __first + __len;
      if (__len > __buffer_size) {
        __stable_sort_adaptive(__first, __middle, __buffer, __buffer_size);
        __stable_sort_adaptive(__middle, __last, __buffer, __buffer_size);
      }
      else {
        __merge_sort_with_buffer(__first, __middle, __buffer);
        __merge_sort_with_buffer(__middle, __last, __buffer);
      }
      __merge_adaptive(__first, __middle, __last, _Distance(__middle - __first),
                       _Distance(__last - __middle), __buffer, __buffer_size);
    }

  template<typename _RandomAccessIter, typename _Pointer, typename _Distance,
           typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIter __first, _RandomAccessIter __last,
                           _Pointer __buffer, _Distance __buffer_size,
                           _Compare __comp)
    {
      _Distance __len = (__last - __first + 1) / 2;
      _RandomAccessIter __middle = __first + __len;
      if (__len > __buffer_size) {
        __stable_sort_adaptive(__first, __middle, __buffer, __buffer_size,
                               __comp);
        __stable_sort_adaptive(__middle, __last, __buffer, __buffer_size,
                               __comp);
      }
      else {
        __merge_sort_with_buffer(__first, __middle, __buffer, __comp);
        __merge_sort_with_buffer(__middle, __last, __buffer, __comp);
      }
      __merge_adaptive(__first, __middle, __last, _Distance(__middle - __first),
                       _Distance(__last - __middle), __buffer, __buffer_size,
                       __comp);
    }
# 2430 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIter>
    inline void
    stable_sort(_RandomAccessIter __first, _RandomAccessIter __last)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;
      typedef typename iterator_traits<_RandomAccessIter>::difference_type _DistanceType;


     

     

      _Temporary_buffer<_RandomAccessIter, _ValueType> buf(__first, __last);
      if (buf.begin() == 0)
        __inplace_stable_sort(__first, __last);
      else
        __stable_sort_adaptive(__first, __last, buf.begin(), _DistanceType(buf.size()));
    }
# 2466 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIter, typename _Compare>
    inline void
    stable_sort(_RandomAccessIter __first, _RandomAccessIter __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;
      typedef typename iterator_traits<_RandomAccessIter>::difference_type _DistanceType;


     

     


      _Temporary_buffer<_RandomAccessIter, _ValueType> buf(__first, __last);
      if (buf.begin() == 0)
        __inplace_stable_sort(__first, __last, __comp);
      else
        __stable_sort_adaptive(__first, __last, buf.begin(), _DistanceType(buf.size()),
                               __comp);
    }
# 2502 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIter>
    void
    partial_sort(_RandomAccessIter __first,
                 _RandomAccessIter __middle,
                 _RandomAccessIter __last)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;


     

     

      make_heap(__first, __middle);
      for (_RandomAccessIter __i = __middle; __i < __last; ++__i)
        if (*__i < *__first)
          __pop_heap(__first, __middle, __i, _ValueType(*__i));
      sort_heap(__first, __middle);
    }
# 2540 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIter, typename _Compare>
    void
    partial_sort(_RandomAccessIter __first,
                 _RandomAccessIter __middle,
                 _RandomAccessIter __last,
                 _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;


     

     


      make_heap(__first, __middle, __comp);
      for (_RandomAccessIter __i = __middle; __i < __last; ++__i)
        if (__comp(*__i, *__first))
          __pop_heap(__first, __middle, __i, _ValueType(*__i), __comp);
      sort_heap(__first, __middle, __comp);
    }
# 2579 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _InputIter, typename _RandomAccessIter>
    _RandomAccessIter
    partial_sort_copy(_InputIter __first, _InputIter __last,
                      _RandomAccessIter __result_first,
                      _RandomAccessIter __result_last)
    {
      typedef typename iterator_traits<_InputIter>::value_type _InputValueType;
      typedef typename iterator_traits<_RandomAccessIter>::value_type _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIter>::difference_type _DistanceType;


     
     
     
     

      if (__result_first == __result_last) return __result_last;
      _RandomAccessIter __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last) {
        *__result_real_last = *__first;
        ++__result_real_last;
        ++__first;
      }
      make_heap(__result_first, __result_real_last);
      while (__first != __last) {
        if (*__first < *__result_first)
          __adjust_heap(__result_first, _DistanceType(0),
                        _DistanceType(__result_real_last - __result_first),
                        _InputValueType(*__first));
        ++__first;
      }
      sort_heap(__result_first, __result_real_last);
      return __result_real_last;
    }
# 2633 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _InputIter, typename _RandomAccessIter, typename _Compare>
    _RandomAccessIter
    partial_sort_copy(_InputIter __first, _InputIter __last,
                      _RandomAccessIter __result_first,
                      _RandomAccessIter __result_last,
                      _Compare __comp)
    {
      typedef typename iterator_traits<_InputIter>::value_type _InputValueType;
      typedef typename iterator_traits<_RandomAccessIter>::value_type _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIter>::difference_type _DistanceType;


     
     
     
     


      if (__result_first == __result_last) return __result_last;
      _RandomAccessIter __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last) {
        *__result_real_last = *__first;
        ++__result_real_last;
        ++__first;
      }
      make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last) {
        if (__comp(*__first, *__result_first))
          __adjust_heap(__result_first, _DistanceType(0),
                        _DistanceType(__result_real_last - __result_first),
                        _InputValueType(*__first),
                        __comp);
        ++__first;
      }
      sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }
# 2686 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIter>
    void
    nth_element(_RandomAccessIter __first,
                _RandomAccessIter __nth,
                _RandomAccessIter __last)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;


     
     

      while (__last - __first > 3) {
        _RandomAccessIter __cut =
          __unguarded_partition(__first, __last,
                                _ValueType(__median(*__first,
                                                    *(__first + (__last - __first)/2),
                                                    *(__last - 1))));
        if (__cut <= __nth)
          __first = __cut;
        else
          __last = __cut;
      }
      __insertion_sort(__first, __last);
    }
# 2728 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIter, typename _Compare>
    void
    nth_element(_RandomAccessIter __first,
                _RandomAccessIter __nth,
                _RandomAccessIter __last,
                            _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;


     
     


      while (__last - __first > 3) {
        _RandomAccessIter __cut =
          __unguarded_partition(__first, __last,
                                _ValueType(__median(*__first,
                                                    *(__first + (__last - __first)/2),
                                                    *(__last - 1),
                                                    __comp)),
                                __comp);
        if (__cut <= __nth)
          __first = __cut;
        else
          __last = __cut;
      }
      __insertion_sort(__first, __last, __comp);
    }
# 2768 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Tp>
    _ForwardIter
    lower_bound(_ForwardIter __first, _ForwardIter __last, const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;
      typedef typename iterator_traits<_ForwardIter>::difference_type _DistanceType;






     
     
     

      _DistanceType __len = distance(__first, __last);
      _DistanceType __half;
      _ForwardIter __middle;

      while (__len > 0) {
        __half = __len >> 1;
        __middle = __first;
        advance(__middle, __half);
        if (*__middle < __val) {
          __first = __middle;
          ++__first;
          __len = __len - __half - 1;
        }
        else
          __len = __half;
      }
      return __first;
    }
# 2816 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Tp, typename _Compare>
    _ForwardIter
    lower_bound(_ForwardIter __first, _ForwardIter __last,
                const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;
      typedef typename iterator_traits<_ForwardIter>::difference_type _DistanceType;


     
     

      _DistanceType __len = distance(__first, __last);
      _DistanceType __half;
      _ForwardIter __middle;

      while (__len > 0) {
        __half = __len >> 1;
        __middle = __first;
        advance(__middle, __half);
        if (__comp(*__middle, __val)) {
          __first = __middle;
          ++__first;
          __len = __len - __half - 1;
        }
        else
          __len = __half;
      }
      return __first;
    }
# 2856 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Tp>
    _ForwardIter
    upper_bound(_ForwardIter __first, _ForwardIter __last, const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;
      typedef typename iterator_traits<_ForwardIter>::difference_type _DistanceType;



     
     
     

      _DistanceType __len = distance(__first, __last);
      _DistanceType __half;
      _ForwardIter __middle;

      while (__len > 0) {
        __half = __len >> 1;
        __middle = __first;
        advance(__middle, __half);
        if (__val < *__middle)
          __len = __half;
        else {
          __first = __middle;
          ++__first;
          __len = __len - __half - 1;
        }
      }
      return __first;
    }
# 2901 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Tp, typename _Compare>
    _ForwardIter
    upper_bound(_ForwardIter __first, _ForwardIter __last,
                const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;
      typedef typename iterator_traits<_ForwardIter>::difference_type _DistanceType;


     
     

      _DistanceType __len = distance(__first, __last);
      _DistanceType __half;
      _ForwardIter __middle;

      while (__len > 0) {
        __half = __len >> 1;
        __middle = __first;
        advance(__middle, __half);
        if (__comp(__val, *__middle))
          __len = __half;
        else {
          __first = __middle;
          ++__first;
          __len = __len - __half - 1;
        }
      }
      return __first;
    }
# 2948 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Tp>
    pair<_ForwardIter, _ForwardIter>
    equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;
      typedef typename iterator_traits<_ForwardIter>::difference_type _DistanceType;



     
     
     

      _DistanceType __len = distance(__first, __last);
      _DistanceType __half;
      _ForwardIter __middle, __left, __right;

      while (__len > 0) {
        __half = __len >> 1;
        __middle = __first;
        advance(__middle, __half);
        if (*__middle < __val) {
          __first = __middle;
          ++__first;
          __len = __len - __half - 1;
        }
        else if (__val < *__middle)
          __len = __half;
        else {
          __left = lower_bound(__first, __middle, __val);
          advance(__first, __len);
          __right = upper_bound(++__middle, __first, __val);
          return pair<_ForwardIter, _ForwardIter>(__left, __right);
        }
      }
      return pair<_ForwardIter, _ForwardIter>(__first, __first);
    }
# 3003 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Tp, typename _Compare>
    pair<_ForwardIter, _ForwardIter>
    equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val,
                _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;
      typedef typename iterator_traits<_ForwardIter>::difference_type _DistanceType;


     
     
     

      _DistanceType __len = distance(__first, __last);
      _DistanceType __half;
      _ForwardIter __middle, __left, __right;

      while (__len > 0) {
        __half = __len >> 1;
        __middle = __first;
        advance(__middle, __half);
        if (__comp(*__middle, __val)) {
          __first = __middle;
          ++__first;
          __len = __len - __half - 1;
        }
        else if (__comp(__val, *__middle))
          __len = __half;
        else {
          __left = lower_bound(__first, __middle, __val, __comp);
          advance(__first, __len);
          __right = upper_bound(++__middle, __first, __val, __comp);
          return pair<_ForwardIter, _ForwardIter>(__left, __right);
        }
      }
      return pair<_ForwardIter, _ForwardIter>(__first, __first);
    }
# 3052 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Tp>
    bool
    binary_search(_ForwardIter __first, _ForwardIter __last,
                  const _Tp& __val)
    {


     
     

     

      _ForwardIter __i = lower_bound(__first, __last, __val);
      return __i != __last && !(__val < *__i);
    }
# 3083 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIter __first, _ForwardIter __last,
                  const _Tp& __val, _Compare __comp)
    {

     
     

     


      _ForwardIter __i = lower_bound(__first, __last, __val, __comp);
      return __i != __last && !__comp(__val, *__i);
    }
# 3115 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _InputIter1, typename _InputIter2, typename _OutputIter>
    _OutputIter
    merge(_InputIter1 __first1, _InputIter1 __last1,
          _InputIter2 __first2, _InputIter2 __last2,
          _OutputIter __result)
    {

     
     
     

     


     


      while (__first1 != __last1 && __first2 != __last2) {
        if (*__first2 < *__first1) {
          *__result = *__first2;
          ++__first2;
        }
        else {
          *__result = *__first1;
          ++__first1;
        }
        ++__result;
      }
      return copy(__first2, __last2, copy(__first1, __last1, __result));
    }
# 3166 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _InputIter1, typename _InputIter2, typename _OutputIter,
           typename _Compare>
    _OutputIter
    merge(_InputIter1 __first1, _InputIter1 __last1,
          _InputIter2 __first2, _InputIter2 __last2,
          _OutputIter __result, _Compare __comp)
    {

     
     
     


     

     



      while (__first1 != __last1 && __first2 != __last2) {
        if (__comp(*__first2, *__first1)) {
          *__result = *__first2;
          ++__first2;
        }
        else {
          *__result = *__first1;
          ++__first1;
        }
        ++__result;
      }
      return copy(__first2, __last2, copy(__first1, __last1, __result));
    }






  template<typename _BidirectionalIter, typename _Distance>
    void
    __merge_without_buffer(_BidirectionalIter __first,
                           _BidirectionalIter __middle,
                           _BidirectionalIter __last,
                           _Distance __len1, _Distance __len2)
    {
      if (__len1 == 0 || __len2 == 0)
        return;
      if (__len1 + __len2 == 2) {
        if (*__middle < *__first)
              iter_swap(__first, __middle);
        return;
      }
      _BidirectionalIter __first_cut = __first;
      _BidirectionalIter __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2) {
        __len11 = __len1 / 2;
        advance(__first_cut, __len11);
        __second_cut = lower_bound(__middle, __last, *__first_cut);
        __len22 = distance(__middle, __second_cut);
      }
      else {
        __len22 = __len2 / 2;
        advance(__second_cut, __len22);
        __first_cut = upper_bound(__first, __middle, *__second_cut);
        __len11 = distance(__first, __first_cut);
      }
      rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIter __new_middle = __first_cut;
      advance(__new_middle, distance(__middle, __second_cut));
      __merge_without_buffer(__first, __first_cut, __new_middle,
                             __len11, __len22);
      __merge_without_buffer(__new_middle, __second_cut, __last,
                             __len1 - __len11, __len2 - __len22);
    }






  template<typename _BidirectionalIter, typename _Distance, typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIter __first,
                           _BidirectionalIter __middle,
                           _BidirectionalIter __last,
                           _Distance __len1, _Distance __len2,
                           _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
        return;
      if (__len1 + __len2 == 2) {
        if (__comp(*__middle, *__first))
              iter_swap(__first, __middle);
        return;
      }
      _BidirectionalIter __first_cut = __first;
      _BidirectionalIter __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2) {
        __len11 = __len1 / 2;
        advance(__first_cut, __len11);
        __second_cut = lower_bound(__middle, __last, *__first_cut, __comp);
        __len22 = distance(__middle, __second_cut);
      }
      else {
        __len22 = __len2 / 2;
        advance(__second_cut, __len22);
        __first_cut = upper_bound(__first, __middle, *__second_cut, __comp);
        __len11 = distance(__first, __first_cut);
      }
      rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIter __new_middle = __first_cut;
      advance(__new_middle, distance(__middle, __second_cut));
      __merge_without_buffer(__first, __first_cut, __new_middle,
                             __len11, __len22, __comp);
      __merge_without_buffer(__new_middle, __second_cut, __last,
                             __len1 - __len11, __len2 - __len22, __comp);
    }






  template<typename _BidirectionalIter1, typename _BidirectionalIter2,
           typename _Distance>
    _BidirectionalIter1
    __rotate_adaptive(_BidirectionalIter1 __first,
                      _BidirectionalIter1 __middle,
                      _BidirectionalIter1 __last,
                      _Distance __len1, _Distance __len2,
                      _BidirectionalIter2 __buffer,
                      _Distance __buffer_size)
    {
      _BidirectionalIter2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size) {
        __buffer_end = copy(__middle, __last, __buffer);
        copy_backward(__first, __middle, __last);
        return copy(__buffer, __buffer_end, __first);
      }
      else if (__len1 <= __buffer_size) {
        __buffer_end = copy(__first, __middle, __buffer);
        copy(__middle, __last, __first);
        return copy_backward(__buffer, __buffer_end, __last);
      }
      else {
        rotate(__first, __middle, __last);
        advance(__first, distance(__middle, __last));
        return __first;
      }
    }






  template<typename _BidirectionalIter1, typename _BidirectionalIter2,
           typename _BidirectionalIter3>
    _BidirectionalIter3
    __merge_backward(_BidirectionalIter1 __first1, _BidirectionalIter1 __last1,
                     _BidirectionalIter2 __first2, _BidirectionalIter2 __last2,
                     _BidirectionalIter3 __result)
    {
      if (__first1 == __last1)
        return copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
        return copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true) {
        if (*__last2 < *__last1) {
          *--__result = *__last1;
          if (__first1 == __last1)
            return copy_backward(__first2, ++__last2, __result);
          --__last1;
        }
        else {
          *--__result = *__last2;
          if (__first2 == __last2)
            return copy_backward(__first1, ++__last1, __result);
          --__last2;
        }
      }
    }






  template<typename _BidirectionalIter1, typename _BidirectionalIter2,
           typename _BidirectionalIter3, typename _Compare>
    _BidirectionalIter3
    __merge_backward(_BidirectionalIter1 __first1, _BidirectionalIter1 __last1,
                     _BidirectionalIter2 __first2, _BidirectionalIter2 __last2,
                     _BidirectionalIter3 __result,
                     _Compare __comp)
    {
      if (__first1 == __last1)
        return copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
        return copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true) {
        if (__comp(*__last2, *__last1)) {
          *--__result = *__last1;
          if (__first1 == __last1)
            return copy_backward(__first2, ++__last2, __result);
          --__last1;
        }
        else {
          *--__result = *__last2;
          if (__first2 == __last2)
            return copy_backward(__first1, ++__last1, __result);
          --__last2;
        }
      }
    }






  template<typename _BidirectionalIter, typename _Distance, typename _Pointer>
    void
    __merge_adaptive(_BidirectionalIter __first,
                     _BidirectionalIter __middle,
                     _BidirectionalIter __last,
                     _Distance __len1, _Distance __len2,
                     _Pointer __buffer, _Distance __buffer_size)
    {
          if (__len1 <= __len2 && __len1 <= __buffer_size) {
            _Pointer __buffer_end = copy(__first, __middle, __buffer);
            merge(__buffer, __buffer_end, __middle, __last, __first);
          }
          else if (__len2 <= __buffer_size) {
            _Pointer __buffer_end = copy(__middle, __last, __buffer);
            __merge_backward(__first, __middle, __buffer, __buffer_end, __last);
          }
          else {
            _BidirectionalIter __first_cut = __first;
            _BidirectionalIter __second_cut = __middle;
            _Distance __len11 = 0;
            _Distance __len22 = 0;
            if (__len1 > __len2) {
                  __len11 = __len1 / 2;
                  advance(__first_cut, __len11);
                  __second_cut = lower_bound(__middle, __last, *__first_cut);
                  __len22 = distance(__middle, __second_cut);
            }
            else {
                  __len22 = __len2 / 2;
                  advance(__second_cut, __len22);
                  __first_cut = upper_bound(__first, __middle, *__second_cut);
                  __len11 = distance(__first, __first_cut);
            }
            _BidirectionalIter __new_middle =
                  __rotate_adaptive(__first_cut, __middle, __second_cut,
                                    __len1 - __len11, __len22, __buffer,
                                    __buffer_size);
            __merge_adaptive(__first, __first_cut, __new_middle, __len11,
                             __len22, __buffer, __buffer_size);
            __merge_adaptive(__new_middle, __second_cut, __last, __len1 - __len11,
                             __len2 - __len22, __buffer, __buffer_size);
          }
    }






  template<typename _BidirectionalIter, typename _Distance, typename _Pointer,
           typename _Compare>
    void
    __merge_adaptive(_BidirectionalIter __first,
                     _BidirectionalIter __middle,
                     _BidirectionalIter __last,
                     _Distance __len1, _Distance __len2,
                     _Pointer __buffer, _Distance __buffer_size,
                     _Compare __comp)
    {
          if (__len1 <= __len2 && __len1 <= __buffer_size) {
            _Pointer __buffer_end = copy(__first, __middle, __buffer);
            merge(__buffer, __buffer_end, __middle, __last, __first, __comp);
          }
          else if (__len2 <= __buffer_size) {
            _Pointer __buffer_end = copy(__middle, __last, __buffer);
            __merge_backward(__first, __middle, __buffer, __buffer_end, __last,
                                             __comp);
          }
          else {
            _BidirectionalIter __first_cut = __first;
            _BidirectionalIter __second_cut = __middle;
            _Distance __len11 = 0;
            _Distance __len22 = 0;
            if (__len1 > __len2) {
                  __len11 = __len1 / 2;
                  advance(__first_cut, __len11);
                  __second_cut = lower_bound(__middle, __last, *__first_cut, __comp);
                  __len22 = distance(__middle, __second_cut);
            }
            else {
                  __len22 = __len2 / 2;
                  advance(__second_cut, __len22);
                  __first_cut = upper_bound(__first, __middle, *__second_cut, __comp);
                  __len11 = distance(__first, __first_cut);
            }
            _BidirectionalIter __new_middle =
                  __rotate_adaptive(__first_cut, __middle, __second_cut,
                                    __len1 - __len11, __len22, __buffer,
                                    __buffer_size);
            __merge_adaptive(__first, __first_cut, __new_middle, __len11,
                             __len22, __buffer, __buffer_size, __comp);
            __merge_adaptive(__new_middle, __second_cut, __last, __len1 - __len11,
                             __len2 - __len22, __buffer, __buffer_size, __comp);
          }
    }
# 3508 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIter>
    void
    inplace_merge(_BidirectionalIter __first,
                  _BidirectionalIter __middle,
                  _BidirectionalIter __last)
    {
      typedef typename iterator_traits<_BidirectionalIter>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIter>::difference_type
          _DistanceType;


     

     

      if (__first == __middle || __middle == __last)
        return;

      _DistanceType __len1 = distance(__first, __middle);
      _DistanceType __len2 = distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIter, _ValueType> __buf(__first, __last);
      if (__buf.begin() == 0)
        __merge_without_buffer(__first, __middle, __last, __len1, __len2);
      else
        __merge_adaptive(__first, __middle, __last, __len1, __len2,
                         __buf.begin(), _DistanceType(__buf.size()));
    }
# 3559 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _BidirectionalIter, typename _Compare>
    void
    inplace_merge(_BidirectionalIter __first,
                  _BidirectionalIter __middle,
                  _BidirectionalIter __last,
                  _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIter>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIter>::difference_type
          _DistanceType;


     

     


      if (__first == __middle || __middle == __last)
        return;

      _DistanceType __len1 = distance(__first, __middle);
      _DistanceType __len2 = distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIter, _ValueType> __buf(__first, __last);
      if (__buf.begin() == 0)
        __merge_without_buffer(__first, __middle, __last, __len1, __len2, __comp);
      else
        __merge_adaptive(__first, __middle, __last, __len1, __len2,
                         __buf.begin(), _DistanceType(__buf.size()),
                         __comp);
    }






  template<typename _InputIter1, typename _InputIter2>
    bool
    includes(_InputIter1 __first1, _InputIter1 __last1,
             _InputIter2 __first2, _InputIter2 __last2)
    {

     
     
     


     


      while (__first1 != __last1 && __first2 != __last2)
        if (*__first2 < *__first1)
          return false;
        else if(*__first1 < *__first2)
          ++__first1;
        else
          ++__first1, ++__first2;

      return __first2 == __last2;
    }

  template<typename _InputIter1, typename _InputIter2, typename _Compare>
    bool
    includes(_InputIter1 __first1, _InputIter1 __last1,
             _InputIter2 __first2, _InputIter2 __last2, _Compare __comp)
    {

     
     
     


     



      while (__first1 != __last1 && __first2 != __last2)
        if (__comp(*__first2, *__first1))
          return false;
        else if(__comp(*__first1, *__first2))
          ++__first1;
        else
          ++__first1, ++__first2;

      return __first2 == __last2;
    }

  template<typename _InputIter1, typename _InputIter2, typename _OutputIter>
    _OutputIter
    set_union(_InputIter1 __first1, _InputIter1 __last1,
              _InputIter2 __first2, _InputIter2 __last2,
              _OutputIter __result)
    {

     
     
     

     


     


      while (__first1 != __last1 && __first2 != __last2) {
        if (*__first1 < *__first2) {
          *__result = *__first1;
          ++__first1;
        }
        else if (*__first2 < *__first1) {
          *__result = *__first2;
          ++__first2;
        }
        else {
          *__result = *__first1;
          ++__first1;
          ++__first2;
        }
        ++__result;
      }
      return copy(__first2, __last2, copy(__first1, __last1, __result));
    }

  template<typename _InputIter1, typename _InputIter2, typename _OutputIter,
           typename _Compare>
    _OutputIter
    set_union(_InputIter1 __first1, _InputIter1 __last1,
              _InputIter2 __first2, _InputIter2 __last2,
              _OutputIter __result, _Compare __comp)
    {

     
     
     


     

     



      while (__first1 != __last1 && __first2 != __last2) {
        if (__comp(*__first1, *__first2)) {
          *__result = *__first1;
          ++__first1;
        }
        else if (__comp(*__first2, *__first1)) {
          *__result = *__first2;
          ++__first2;
        }
        else {
          *__result = *__first1;
          ++__first1;
          ++__first2;
        }
        ++__result;
      }
      return copy(__first2, __last2, copy(__first1, __last1, __result));
    }

  template<typename _InputIter1, typename _InputIter2, typename _OutputIter>
    _OutputIter
    set_intersection(_InputIter1 __first1, _InputIter1 __last1,
                     _InputIter2 __first2, _InputIter2 __last2,
                     _OutputIter __result)
    {

     
     
     

     


     


      while (__first1 != __last1 && __first2 != __last2)
        if (*__first1 < *__first2)
          ++__first1;
        else if (*__first2 < *__first1)
          ++__first2;
        else {
          *__result = *__first1;
          ++__first1;
          ++__first2;
          ++__result;
        }
      return __result;
    }

  template<typename _InputIter1, typename _InputIter2, typename _OutputIter,
           typename _Compare>
    _OutputIter
    set_intersection(_InputIter1 __first1, _InputIter1 __last1,
                     _InputIter2 __first2, _InputIter2 __last2,
                     _OutputIter __result, _Compare __comp)
    {

     
     
     


     

     



      while (__first1 != __last1 && __first2 != __last2)
        if (__comp(*__first1, *__first2))
          ++__first1;
        else if (__comp(*__first2, *__first1))
          ++__first2;
        else {
          *__result = *__first1;
          ++__first1;
          ++__first2;
          ++__result;
        }
      return __result;
    }

  template<typename _InputIter1, typename _InputIter2, typename _OutputIter>
    _OutputIter
    set_difference(_InputIter1 __first1, _InputIter1 __last1,
                   _InputIter2 __first2, _InputIter2 __last2,
                   _OutputIter __result)
    {

     
     
     

     


     


      while (__first1 != __last1 && __first2 != __last2)
        if (*__first1 < *__first2) {
          *__result = *__first1;
          ++__first1;
          ++__result;
        }
        else if (*__first2 < *__first1)
          ++__first2;
        else {
          ++__first1;
          ++__first2;
        }
      return copy(__first1, __last1, __result);
    }

  template<typename _InputIter1, typename _InputIter2, typename _OutputIter,
           typename _Compare>
    _OutputIter
    set_difference(_InputIter1 __first1, _InputIter1 __last1,
                   _InputIter2 __first2, _InputIter2 __last2,
                   _OutputIter __result, _Compare __comp)
    {

     
     
     


     

     



      while (__first1 != __last1 && __first2 != __last2)
        if (__comp(*__first1, *__first2)) {
          *__result = *__first1;
          ++__first1;
          ++__result;
        }
        else if (__comp(*__first2, *__first1))
          ++__first2;
        else {
          ++__first1;
          ++__first2;
        }
      return copy(__first1, __last1, __result);
    }

  template<typename _InputIter1, typename _InputIter2, typename _OutputIter>
    _OutputIter
    set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _OutputIter __result)
    {

     
     
     

     


     


      while (__first1 != __last1 && __first2 != __last2)
        if (*__first1 < *__first2) {
          *__result = *__first1;
          ++__first1;
          ++__result;
        }
        else if (*__first2 < *__first1) {
          *__result = *__first2;
          ++__first2;
          ++__result;
        }
        else {
          ++__first1;
          ++__first2;
        }
      return copy(__first2, __last2, copy(__first1, __last1, __result));
    }

  template<typename _InputIter1, typename _InputIter2, typename _OutputIter,
           typename _Compare>
    _OutputIter
    set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _OutputIter __result,
                             _Compare __comp)
    {

     
     
     


     

     



      while (__first1 != __last1 && __first2 != __last2)
        if (__comp(*__first1, *__first2)) {
          *__result = *__first1;
          ++__first1;
          ++__result;
        }
        else if (__comp(*__first2, *__first1)) {
          *__result = *__first2;
          ++__first2;
          ++__result;
        }
        else {
          ++__first1;
          ++__first2;
        }
      return copy(__first2, __last2, copy(__first1, __last1, __result));
    }




  template<typename _ForwardIter>
    _ForwardIter
    max_element(_ForwardIter __first, _ForwardIter __last)
    {

     
     


      if (__first == __last) return __first;
      _ForwardIter __result = __first;
      while (++__first != __last)
        if (*__result < *__first)
          __result = __first;
      return __result;
    }

  template<typename _ForwardIter, typename _Compare>
    _ForwardIter
    max_element(_ForwardIter __first, _ForwardIter __last,
                _Compare __comp)
    {

     
     



      if (__first == __last) return __first;
      _ForwardIter __result = __first;
      while (++__first != __last)
        if (__comp(*__result, *__first)) __result = __first;
      return __result;
    }

  template<typename _ForwardIter>
    _ForwardIter
    min_element(_ForwardIter __first, _ForwardIter __last)
    {

     
     


      if (__first == __last) return __first;
      _ForwardIter __result = __first;
      while (++__first != __last)
        if (*__first < *__result)
          __result = __first;
      return __result;
    }

  template<typename _ForwardIter, typename _Compare>
    _ForwardIter
    min_element(_ForwardIter __first, _ForwardIter __last,
                _Compare __comp)
    {

     
     



      if (__first == __last) return __first;
      _ForwardIter __result = __first;
      while (++__first != __last)
        if (__comp(*__first, *__result))
          __result = __first;
      return __result;
    }




  template<typename _BidirectionalIter>
    bool
    next_permutation(_BidirectionalIter __first, _BidirectionalIter __last)
    {

     
     


      if (__first == __last)
        return false;
      _BidirectionalIter __i = __first;
      ++__i;
      if (__i == __last)
        return false;
      __i = __last;
      --__i;

      for(;;) {
        _BidirectionalIter __ii = __i;
        --__i;
        if (*__i < *__ii) {
          _BidirectionalIter __j = __last;
          while (!(*__i < *--__j))
            {}
          iter_swap(__i, __j);
          reverse(__ii, __last);
          return true;
        }
        if (__i == __first) {
          reverse(__first, __last);
          return false;
        }
      }
    }

  template<typename _BidirectionalIter, typename _Compare>
    bool
    next_permutation(_BidirectionalIter __first, _BidirectionalIter __last,
                     _Compare __comp)
    {

     
     



      if (__first == __last)
        return false;
      _BidirectionalIter __i = __first;
      ++__i;
      if (__i == __last)
        return false;
      __i = __last;
      --__i;

      for(;;) {
        _BidirectionalIter __ii = __i;
        --__i;
        if (__comp(*__i, *__ii)) {
          _BidirectionalIter __j = __last;
          while (!__comp(*__i, *--__j))
            {}
          iter_swap(__i, __j);
          reverse(__ii, __last);
          return true;
        }
        if (__i == __first) {
          reverse(__first, __last);
          return false;
        }
      }
    }

  template<typename _BidirectionalIter>
    bool
    prev_permutation(_BidirectionalIter __first, _BidirectionalIter __last)
    {

     
     


      if (__first == __last)
        return false;
      _BidirectionalIter __i = __first;
      ++__i;
      if (__i == __last)
        return false;
      __i = __last;
      --__i;

      for(;;) {
        _BidirectionalIter __ii = __i;
        --__i;
        if (*__ii < *__i) {
          _BidirectionalIter __j = __last;
          while (!(*--__j < *__i))
            {}
          iter_swap(__i, __j);
          reverse(__ii, __last);
          return true;
        }
        if (__i == __first) {
          reverse(__first, __last);
          return false;
        }
      }
    }

  template<typename _BidirectionalIter, typename _Compare>
    bool
    prev_permutation(_BidirectionalIter __first, _BidirectionalIter __last,
                     _Compare __comp)
    {

     
     



      if (__first == __last)
        return false;
      _BidirectionalIter __i = __first;
      ++__i;
      if (__i == __last)
        return false;
      __i = __last;
      --__i;

      for(;;) {
        _BidirectionalIter __ii = __i;
        --__i;
        if (__comp(*__ii, *__i)) {
          _BidirectionalIter __j = __last;
          while (!__comp(*--__j, *__i))
            {}
          iter_swap(__i, __j);
          reverse(__ii, __last);
          return true;
        }
        if (__i == __first) {
          reverse(__first, __last);
          return false;
        }
      }
    }



  template<typename _InputIter, typename _ForwardIter>
    _InputIter
    find_first_of(_InputIter __first1, _InputIter __last1,
                  _ForwardIter __first2, _ForwardIter __last2)
    {

     
     
     



      for ( ; __first1 != __last1; ++__first1)
        for (_ForwardIter __iter = __first2; __iter != __last2; ++__iter)
          if (*__first1 == *__iter)
            return __first1;
      return __last1;
    }

  template<typename _InputIter, typename _ForwardIter, typename _BinaryPredicate>
    _InputIter
    find_first_of(_InputIter __first1, _InputIter __last1,
                  _ForwardIter __first2, _ForwardIter __last2,
                  _BinaryPredicate __comp)
    {

     
     
     


     



      for ( ; __first1 != __last1; ++__first1)
        for (_ForwardIter __iter = __first2; __iter != __last2; ++__iter)
          if (__comp(*__first1, *__iter))
            return __first1;
      return __last1;
    }
# 4201 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_algo.h" 3
  template<typename _ForwardIter1, typename _ForwardIter2>
    _ForwardIter1
    __find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
               _ForwardIter2 __first2, _ForwardIter2 __last2,
               forward_iterator_tag, forward_iterator_tag)
    {
      if (__first2 == __last2)
        return __last1;
      else {
        _ForwardIter1 __result = __last1;
        while (1) {
          _ForwardIter1 __new_result
            = search(__first1, __last1, __first2, __last2);
          if (__new_result == __last1)
            return __result;
          else {
            __result = __new_result;
            __first1 = __new_result;
            ++__first1;
          }
        }
      }
    }

  template<typename _ForwardIter1, typename _ForwardIter2,
           typename _BinaryPredicate>
    _ForwardIter1
    __find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
               _ForwardIter2 __first2, _ForwardIter2 __last2,
               forward_iterator_tag, forward_iterator_tag,
               _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
        return __last1;
      else {
        _ForwardIter1 __result = __last1;
        while (1) {
          _ForwardIter1 __new_result
            = search(__first1, __last1, __first2, __last2, __comp);
          if (__new_result == __last1)
            return __result;
          else {
            __result = __new_result;
            __first1 = __new_result;
            ++__first1;
          }
        }
      }
    }


  template<typename _BidirectionalIter1, typename _BidirectionalIter2>
    _BidirectionalIter1
    __find_end(_BidirectionalIter1 __first1, _BidirectionalIter1 __last1,
               _BidirectionalIter2 __first2, _BidirectionalIter2 __last2,
               bidirectional_iterator_tag, bidirectional_iterator_tag)
    {

     
     

      typedef reverse_iterator<_BidirectionalIter1> _RevIter1;
      typedef reverse_iterator<_BidirectionalIter2> _RevIter2;

      _RevIter1 __rlast1(__first1);
      _RevIter2 __rlast2(__first2);
      _RevIter1 __rresult = search(_RevIter1(__last1), __rlast1,
                                   _RevIter2(__last2), __rlast2);

      if (__rresult == __rlast1)
        return __last1;
      else {
        _BidirectionalIter1 __result = __rresult.base();
        advance(__result, -distance(__first2, __last2));
        return __result;
      }
    }

  template<typename _BidirectionalIter1, typename _BidirectionalIter2,
           typename _BinaryPredicate>
    _BidirectionalIter1
    __find_end(_BidirectionalIter1 __first1, _BidirectionalIter1 __last1,
               _BidirectionalIter2 __first2, _BidirectionalIter2 __last2,
               bidirectional_iterator_tag, bidirectional_iterator_tag,
               _BinaryPredicate __comp)
    {

     
     

      typedef reverse_iterator<_BidirectionalIter1> _RevIter1;
      typedef reverse_iterator<_BidirectionalIter2> _RevIter2;

      _RevIter1 __rlast1(__first1);
      _RevIter2 __rlast2(__first2);
      _RevIter1 __rresult = search(_RevIter1(__last1), __rlast1,
                                   _RevIter2(__last2), __rlast2,
                                   __comp);

      if (__rresult == __rlast1)
        return __last1;
      else {
        _BidirectionalIter1 __result = __rresult.base();
        advance(__result, -distance(__first2, __last2));
        return __result;
      }
    }



  template<typename _ForwardIter1, typename _ForwardIter2>
    inline _ForwardIter1
    find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
             _ForwardIter2 __first2, _ForwardIter2 __last2)
    {

     
     
     



      return __find_end(__first1, __last1, __first2, __last2,
                        __iterator_category(__first1),
                        __iterator_category(__first2));
    }

  template<typename _ForwardIter1, typename _ForwardIter2,
           typename _BinaryPredicate>
    inline _ForwardIter1
    find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
             _ForwardIter2 __first2, _ForwardIter2 __last2,
             _BinaryPredicate __comp)
    {

     
     
     



      return __find_end(__first1, __last1, __first2, __last2,
                        __iterator_category(__first1),
                        __iterator_category(__first2),
                        __comp);
    }

}
# 70 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/algorithm" 2 3
# 57 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/string" 2 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/basic_string.tcc" 1 3
# 45 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/basic_string.tcc" 3

namespace std
{
  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep))/sizeof(_CharT)) - 1) / 4;

  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;



  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_S_empty_rep_storage[
    (sizeof(_Rep) + sizeof(_CharT) + sizeof(size_type) - 1)/sizeof(size_type)];





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIter>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIter __beg, _InIter __end, const _Alloc& __a,
                   input_iterator_tag)
      {
        if (__beg == __end && __a == _Alloc())
          return _S_empty_rep()._M_refcopy();

        _CharT __buf[100];
        size_type __i = 0;
        while (__beg != __end && __i < sizeof(__buf) / sizeof(_CharT))
          {
            __buf[__i++] = *__beg;
            ++__beg;
          }
        _Rep* __r = _Rep::_S_create(__i, __a);
        traits_type::copy(__r->_M_refdata(), __buf, __i);
        __r->_M_length = __i;
        try
          {



            for (;;)
              {
                _CharT* __p = __r->_M_refdata() + __r->_M_length;
                _CharT* __last = __r->_M_refdata() + __r->_M_capacity;
                for (;;)
                  {
                    if (__beg == __end)
                      {
                        __r->_M_length = __p - __r->_M_refdata();
                        *__p = _Rep::_S_terminal;
                        return __r->_M_refdata();
                      }
                    if (__p == __last)
                      break;
                    *__p++ = *__beg;
                    ++__beg;
                  }

                size_type __len = __p - __r->_M_refdata();
                _Rep* __another = _Rep::_S_create(__len + 1, __a);
                traits_type::copy(__another->_M_refdata(),
                                  __r->_M_refdata(), __len);
                __r->_M_destroy(__a);
                __r = __another;
                __r->_M_length = __len;
              }
          }
        catch(...)
          {
            __r->_M_destroy(__a);
            throw;
          }
        return 0;
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template <class _InIter>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIter __beg, _InIter __end, const _Alloc& __a,
                   forward_iterator_tag)
      {
        if (__beg == __end && __a == _Alloc())
          return _S_empty_rep()._M_refcopy();


        if (__builtin_expect(__beg == _InIter(), 0))
          __throw_logic_error("attempt to create string with null pointer");

        size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));


        _Rep* __r = _Rep::_S_create(__dnew, __a);
        try
          { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
        catch(...)
          {
            __r->_M_destroy(__a);
            throw;
          }
        __r->_M_length = __dnew;

        __r->_M_refdata()[__dnew] = _Rep::_S_terminal;
        return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {
      if (__n == 0 && __a == _Alloc())
        return _S_empty_rep()._M_refcopy();


      _Rep* __r = _Rep::_S_create(__n, __a);
      try
        {
          if (__n)
            traits_type::assign(__r->_M_refdata(), __n, __c);
        }
      catch(...)
        {
          __r->_M_destroy(__a);
          throw;
        }
      __r->_M_length = __n;
      __r->_M_refdata()[__n] = _Rep::_S_terminal;
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(), __str.get_allocator()),
                 __str.get_allocator())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_check(__pos),
                               __str._M_fold(__pos, __n), _Alloc()), _Alloc())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
                 size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_check(__pos),
                               __str._M_fold(__pos, __n), __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
                               __s + npos, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIter>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIter __beg, _InputIter __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
        {

          allocator_type __a = this->get_allocator();
          _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
          _M_rep()->_M_dispose(__a);
          _M_data(__tmp);
        }
      return *this;
    }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     assign(const basic_string& __str, size_type __pos, size_type __n)
     {
       const size_type __strsize = __str.size();
       if (__pos > __strsize)
         __throw_out_of_range("basic_string::assign");
       const bool __testn = __n < __strsize - __pos;
       const size_type __newsize = __testn ? __n : __strsize - __pos;
       return this->assign(__str._M_data() + __pos, __newsize);
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     assign(const _CharT* __s, size_type __n)
     {
       if (__n > this->max_size())
         __throw_length_error("basic_string::assign");
       if (_M_rep()->_M_is_shared() || less<const _CharT*>()(__s, _M_data())
           || less<const _CharT*>()(_M_data() + this->size(), __s))
         return _M_replace_safe(_M_ibegin(), _M_iend(), __s, __s + __n);
       else
         {

           const size_type __pos = __s - _M_data();
           if (__pos >= __n)
             traits_type::copy(_M_data(), __s, __n);
           else if (__pos)
             traits_type::move(_M_data(), __s, __n);
           _M_rep()->_M_length = __n;
           _M_data()[__n] = _Rep::_S_terminal;
           return *this;
         }
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos1, const basic_string& __str,
            size_type __pos2, size_type __n)
     {
       const size_type __strsize = __str.size();
       if (__pos2 > __strsize)
         __throw_out_of_range("basic_string::insert");
       const bool __testn = __n < __strsize - __pos2;
       const size_type __newsize = __testn ? __n : __strsize - __pos2;
       return this->insert(__pos1, __str._M_data() + __pos2, __newsize);
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos, const _CharT* __s, size_type __n)
     {
       const size_type __size = this->size();
       if (__pos > __size)
         __throw_out_of_range("basic_string::insert");
       if (__size > this->max_size() - __n)
         __throw_length_error("basic_string::insert");
       if (_M_rep()->_M_is_shared() || less<const _CharT*>()(__s, _M_data())
           || less<const _CharT*>()(_M_data() + __size, __s))
         return _M_replace_safe(_M_ibegin() + __pos, _M_ibegin() + __pos,
                                __s, __s + __n);
       else
         {



           const size_type __off = __s - _M_data();
           _M_mutate(__pos, 0, __n);
           __s = _M_data() + __off;
           _CharT* __p = _M_data() + __pos;
           if (__s + __n <= __p)
             traits_type::copy(__p, __s, __n);
           else if (__s >= __p)
             traits_type::copy(__p, __s + __n, __n);
           else
             {
               traits_type::copy(__p, __s, __p - __s);
               traits_type::copy(__p + (__p-__s), __p + __n, __n - (__p-__s));
             }
           return *this;
         }
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     replace(size_type __pos, size_type __n1, const _CharT* __s,
             size_type __n2)
     {
       const size_type __size = this->size();
       if (__pos > __size)
         __throw_out_of_range("basic_string::replace");
       const bool __testn1 = __n1 < __size - __pos;
       const size_type __foldn1 = __testn1 ? __n1 : __size - __pos;
       if (__size - __foldn1 > this->max_size() - __n2)
         __throw_length_error("basic_string::replace");
       if (_M_rep()->_M_is_shared() || less<const _CharT*>()(__s, _M_data())
           || less<const _CharT*>()(_M_data() + __size, __s))
         return _M_replace_safe(_M_ibegin() + __pos,
                                _M_ibegin() + __pos + __foldn1, __s, __s + __n2);

       else
         return _M_replace(_M_ibegin() + __pos, _M_ibegin() + __pos + __foldn1,
                           __s, __s + __n2,
                           typename iterator_traits<const _CharT*>::iterator_category());
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a) throw ()
    {
      size_type __size = sizeof(_Rep) + (_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_M_leak_hard()
    {
      if (_M_rep()->_M_is_shared())
        _M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const _CharT* __src = _M_data() + __pos + __len1;
      const size_type __how_much = __old_size - __pos - __len1;

      if (_M_rep()->_M_is_shared() || __new_size > capacity())
        {

          allocator_type __a = get_allocator();


          const size_type __pagesize = 4096;
          const size_type __malloc_header_size = 4 * sizeof (void*);

          const size_type __page_capacity = (__pagesize - __malloc_header_size
                                             - sizeof(_Rep) - sizeof(_CharT))
                                             / sizeof(_CharT);
          _Rep* __r;
          if (__new_size > capacity() && __new_size > __page_capacity)

            __r = _Rep::_S_create(__new_size > 2*capacity() ?
                                  __new_size : 2*capacity(), __a);
          else
            __r = _Rep::_S_create(__new_size, __a);
          try
            {
              if (__pos)
                traits_type::copy(__r->_M_refdata(), _M_data(), __pos);
              if (__how_much)
                traits_type::copy(__r->_M_refdata() + __pos + __len2,
                                  __src, __how_much);
            }
          catch(...)
            {
              __r->_M_dispose(get_allocator());
              throw;
            }
          _M_rep()->_M_dispose(__a);
          _M_data(__r->_M_refdata());
      }
      else if (__how_much && __len1 != __len2)
        {

          traits_type::move(_M_data() + __pos + __len2, __src, __how_much);
        }
      _M_rep()->_M_set_sharable();
      _M_rep()->_M_length = __new_size;
      _M_data()[__new_size] = _Rep::_S_terminal;

    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::reserve(size_type __res)
    {
      if (__res > this->capacity() || _M_rep()->_M_is_shared())
        {
          if (__res > this->max_size())
            __throw_length_error("basic_string::reserve");

          if (__res < this->size())
            __res = this->size();
          allocator_type __a = get_allocator();
          _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
          _M_rep()->_M_dispose(__a);
          _M_data(__tmp);
        }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void basic_string<_CharT, _Traits, _Alloc>::swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
        _M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
        __s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
        {
          _CharT* __tmp = _M_data();
          _M_data(__s._M_data());
          __s._M_data(__tmp);
        }

      else
        {
          basic_string __tmp1(_M_ibegin(), _M_iend(), __s.get_allocator());
          basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
                              this->get_allocator());
          *this = __tmp2;
          __s = __tmp1;
        }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_t __capacity, const _Alloc& __alloc)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;


      if (__capacity > _S_max_size)



        __throw_length_error("basic_string::_S_create");




      size_t __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
# 532 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/basic_string.tcc" 3
      const size_t __pagesize = 4096;
      const size_t __subpagesize = 128;
      const size_t __malloc_header_size = 4 * sizeof (void*);
      if ((__size + __malloc_header_size) > __pagesize)
        {
          size_t __extra =
            (__pagesize - ((__size + __malloc_header_size) % __pagesize))
            % __pagesize;
          __capacity += __extra / sizeof(_CharT);
          __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
        }
      else if (__size > __subpagesize)
        {
          size_t __extra =
            (__subpagesize - ((__size + __malloc_header_size) % __subpagesize))
            % __subpagesize;
          __capacity += __extra / sizeof(_CharT);
          __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
        }



      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;
      __p->_M_set_sharable();
      __p->_M_length = 0;
      return __p;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {

      const size_type __requested_cap = _M_length + __res;

      const size_type __pagesize = 4096;
      const size_type __malloc_header_size = 4 * sizeof (void*);

      const size_type __page_capacity =
        (__pagesize - __malloc_header_size - sizeof(_Rep) - sizeof(_CharT))
        / sizeof(_CharT);
      _Rep* __r;
      if (__requested_cap > _M_capacity && __requested_cap > __page_capacity)

        __r = _Rep::_S_create(__requested_cap > 2*_M_capacity ?
                              __requested_cap : 2*_M_capacity, __alloc);
      else
        __r = _Rep::_S_create(__requested_cap, __alloc);

      if (_M_length)
        {
          try
            { traits_type::copy(__r->_M_refdata(), _M_refdata(), _M_length); }
          catch(...)
            {
              __r->_M_destroy(__alloc);
              throw;
            }
        }
      __r->_M_length = _M_length;
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::resize(size_type __n, _CharT __c)
    {
      if (__n > max_size())
        __throw_length_error("basic_string::resize");
      size_type __size = this->size();
      if (__size < __n)
        this->append(__n - __size, __c);
      else if (__n < __size)
        this->erase(__n);

    }




  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIter>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace(iterator __i1, iterator __i2, _InputIter __k1,
                 _InputIter __k2, input_iterator_tag)
      {

        basic_string __s(__k1, __k2);
        return _M_replace_safe(__i1, __i2, __s._M_ibegin(), __s._M_iend());
      }




  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _ForwardIter>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_safe(iterator __i1, iterator __i2, _ForwardIter __k1,
                      _ForwardIter __k2)
      {
        size_type __dnew = static_cast<size_type>(std::distance(__k1, __k2));
        size_type __dold = __i2 - __i1;
        size_type __dmax = this->max_size();

        if (__dmax <= __dnew)
          __throw_length_error("basic_string::_M_replace");
        size_type __off = __i1 - _M_ibegin();
        _M_mutate(__off, __dold, __dnew);


        if (__dnew)
          _S_copy_chars(_M_data() + __off, __k1, __k2);

        return *this;
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    replace(size_type __pos1, size_type __n1, const basic_string& __str,
            size_type __pos2, size_type __n2)
    {
      const size_type __strsize = __str.size();
      if (__pos2 > __strsize)
        __throw_out_of_range("basic_string::replace");
      const bool __testn2 = __n2 < __strsize - __pos2;
      const size_type __foldn2 = __testn2 ? __n2 : __strsize - __pos2;
      return this->replace(__pos1, __n1,
                           __str._M_data() + __pos2, __foldn2);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {



      size_type __size = __str.size();
      size_type __len = __size + this->size();
      if (__len > this->capacity())
        this->reserve(__len);
      return _M_replace_safe(_M_iend(), _M_iend(), __str._M_ibegin(),
                             __str._M_iend());
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {



      size_type __len = std::min(size_type(__str.size() - __pos),
                                 __n) + this->size();
      if (__len > this->capacity())
        this->reserve(__len);
      return _M_replace_safe(_M_iend(), _M_iend(), __str._M_check(__pos),
                             __str._M_fold(__pos, __n));
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
      size_type __len = __n + this->size();
      if (__len > this->capacity())
        this->reserve(__len);
      return _M_replace_safe(_M_iend(), _M_iend(), __s, __s + __n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(size_type __n, _CharT __c)
    {
      size_type __len = __n + this->size();
      if (__len > this->capacity())
        this->reserve(__len);
       return this->replace(_M_iend(), _M_iend(), __n, __c);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
              const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __lhs + __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    replace(iterator __i1, iterator __i2, size_type __n2, _CharT __c)
    {
      size_type __n1 = __i2 - __i1;
      size_type __off1 = __i1 - _M_ibegin();
      if (max_size() - (this->size() - __n1) <= __n2)
        __throw_length_error("basic_string::replace");
      _M_mutate (__off1, __n1, __n2);

      if (__n2)
        traits_type::assign(_M_data() + __off1, __n2, __c);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      if (__pos > this->size())
        __throw_out_of_range("basic_string::copy");

      if (__n > this->size() - __pos)
        __n = this->size() - __pos;

      traits_type::copy(__s, _M_data() + __pos, __n);

      return __n;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
      size_type __size = this->size();
      size_t __xpos = __pos;
      const _CharT* __data = _M_data();
      for (; __xpos + __n <= __size; ++__xpos)
        if (traits_type::compare(__data + __xpos, __s, __n) == 0)
          return __xpos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      size_type __ret = npos;
      if (__pos < __size)
        {
          const _CharT* __data = _M_data();
          size_type __n = __size - __pos;
          const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
          if (__p)
            __ret = __p - __data;
        }
      return __ret;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
      size_type __size = this->size();
      if (__n <= __size)
        {
          __pos = std::min(size_type(__size - __n), __pos);
          const _CharT* __data = _M_data();
          do
            {
              if (traits_type::compare(__data + __pos, __s, __n) == 0)
                return __pos;
            }
          while (__pos-- > 0);
        }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
        {
          size_t __xpos = __size - 1;
          if (__xpos > __pos)
            __xpos = __pos;

          for (++__xpos; __xpos-- > 0; )
            if (traits_type::eq(_M_data()[__xpos], __c))
              return __xpos;
        }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      for (; __n && __pos < this->size(); ++__pos)
        {
          const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
          if (__p)
            return __pos;
        }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      size_type __size = this->size();
      if (__size && __n)
        {
          if (--__size > __pos)
            __size = __pos;
          do
            {
              if (traits_type::find(__s, __n, _M_data()[__size]))
                return __size;
            }
          while (__size-- != 0);
        }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      size_t __xpos = __pos;
      for (; __xpos < this->size(); ++__xpos)
        if (!traits_type::find(__s, __n, _M_data()[__xpos]))
          return __xpos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const
    {
      size_t __xpos = __pos;
      for (; __xpos < this->size(); ++__xpos)
        if (!traits_type::eq(_M_data()[__xpos], __c))
          return __xpos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      size_type __size = this->size();
      if (__size)
        {
          if (--__size > __pos)
            __size = __pos;
          do
            {
              if (!traits_type::find(__s, __n, _M_data()[__size]))
                return __size;
            }
          while (__size--);
        }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
        {
          if (--__size > __pos)
            __size = __pos;
          do
            {
              if (!traits_type::eq(_M_data()[__size], __c))
                return __size;
            }
          while (__size--);
        }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      size_type __size = this->size();
      size_type __osize = __str.size();
      if (__pos > __size)
        __throw_out_of_range("basic_string::compare");

      size_type __rsize= std::min(size_type(__size - __pos), __n);
      size_type __len = std::min(__rsize, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
        __r = __rsize - __osize;
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
            size_type __pos2, size_type __n2) const
    {
      size_type __size = this->size();
      size_type __osize = __str.size();
      if (__pos1 > __size || __pos2 > __osize)
        __throw_out_of_range("basic_string::compare");

      size_type __rsize = std::min(size_type(__size - __pos1), __n1);
      size_type __rosize = std::min(size_type(__osize - __pos2), __n2);
      size_type __len = std::min(__rsize, __rosize);
      int __r = traits_type::compare(_M_data() + __pos1,
                                     __str.data() + __pos2, __len);
      if (!__r)
        __r = __rsize - __rosize;
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
      size_type __size = this->size();
      size_type __osize = traits_type::length(__s);
      size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
        __r = __size - __osize;
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      size_type __size = this->size();
      if (__pos > __size)
        __throw_out_of_range("basic_string::compare");

      size_type __osize = traits_type::length(__s);
      size_type __rsize = std::min(size_type(__size - __pos), __n1);
      size_type __len = std::min(__rsize, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
        __r = __rsize - __osize;
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
            size_type __n2) const
    {
      size_type __size = this->size();
      if (__pos > __size)
        __throw_out_of_range("basic_string::compare");

      size_type __osize = std::min(traits_type::length(__s), __n2);
      size_type __rsize = std::min(size_type(__size - __pos), __n1);
      size_type __len = std::min(__rsize, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
        __r = __rsize - __osize;
      return __r;
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    _S_string_copy(const basic_string<_CharT, _Traits, _Alloc>& __str,
                   _CharT* __buf, typename _Alloc::size_type __bufsiz)
    {
      typedef typename _Alloc::size_type size_type;
      size_type __strsize = __str.size();
      size_type __bytes = std::min(__strsize, __bufsiz - 1);
      _Traits::copy(__buf, __str.data(), __bytes);
      __buf[__bytes] = _CharT();
    }





  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);


  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);


}
# 58 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/string" 2 3
# 48 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/locale_classes.h" 2 3


namespace std
{
  class __locale_cache_base;
  template<typename _Facet> class __locale_cache;


  class locale
  {
  public:

    typedef unsigned int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const __locale_cache<_Facet>&
      __use_cache(const locale&);



    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
                                           time | monetary | messages);


    locale() throw();

    locale(const locale& __other) throw();

    explicit
    locale(const char* __s);

    locale(const locale& __base, const char* __s, category __cat);

    locale(const locale& __base, const locale& __add, category __cat);

    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);

    ~locale() throw();

    const locale&
    operator=(const locale& __other) throw();

    template<typename _Facet>
      locale
      combine(const locale& __other) const;


    string
    name() const;

    bool
    operator==(const locale& __other) const throw ();

    inline bool
    operator!=(const locale& __other) const throw ()
    { return !(this->operator==(__other)); }

    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
                 const basic_string<_Char, _Traits, _Alloc>& __s2) const;


    static locale
    global(const locale&);

    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;






    static const size_t _S_categories_size = 6;






    static const size_t _S_extra_categories_size = 6;





    static const char* _S_categories[_S_categories_size
                                      + _S_extra_categories_size];

    explicit
    locale(_Impl*) throw();

    static inline void
    _S_initialize()
    {
      if (!_S_classic)
        classic();
    }

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const __locale_cache<_Facet>&
      __use_cache(const locale&);

  private:

    _Atomic_word _M_references;
    facet** _M_facets;
    size_t _M_facets_size;

    char* _M_names[_S_categories_size
                                                 + _S_extra_categories_size];
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    inline void
    _M_add_reference() throw()
    { __atomic_add(&_M_references, 1); }

    inline void
    _M_remove_reference() throw()
    {
      if (__exchange_and_add(&_M_references, -1) == 1)
        {
          try
            { delete this; }
          catch(...)
            { }
        }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(facet**, size_t, bool);

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    inline bool
    _M_check_same_name()
    {
      bool __ret = true;
      for (size_t __i = 0;
           __ret && __i < _S_categories_size + _S_extra_categories_size - 1;
           ++__i)
        __ret &= (strcmp(_M_names[__i], _M_names[__i + 1]) == 0);
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, facet*);

    template<typename _Facet>
      inline void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }




    inline __locale_cache_base*
      _M_get_cache(size_t __index)
      {
        return (__locale_cache_base*)_M_facets[__index + _M_facets_size];
      }



    void
    _M_install_cache(__locale_cache_base* __cache, int __id)
    {
      _M_facets[__id + _M_facets_size] =
        reinterpret_cast<locale::facet*>(__cache);
    }

  };

  template<typename _Facet>
    locale::locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);
      _M_impl->_M_install_facet(&_Facet::id, __f);
      for (size_t __i = 0;
           __i < _S_categories_size + _S_extra_categories_size; ++__i)
        {
          delete [] _M_impl->_M_names[__i];
          char* __new = new char[2];
          strcpy(__new, "*");
          _M_impl->_M_names[__i] = __new;
        }
    }



  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    _Atomic_word _M_references;

  protected:

    static __c_locale _S_c_locale;


    static char _S_c_name[2];

    explicit
    facet(size_t __refs = 0) throw();

    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
                       __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc);

    static void
    _S_destroy_c_locale(__c_locale& __cloc);

  private:
    void
    _M_add_reference() throw();

    void
    _M_remove_reference() throw();

    facet(const facet&);

    void
    operator=(const facet&);
  };



  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;
    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);
    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw ();




    mutable size_t _M_index;


    static _Atomic_word _S_highwater;

    void
    operator=(const id&);

    id(const id&);

  public:


    id();

    inline size_t
    _M_id() const
    {
      if (!_M_index)
        _M_index = 1 + __exchange_and_add(&_S_highwater, 1);
      return _M_index - 1;
    }
  };
}
# 48 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/ios_base.h" 2 3

namespace std
{




  enum _Ios_Fmtflags { _M_ios_fmtflags_end = 1L << 16 };

  inline _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline _Ios_Fmtflags
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline _Ios_Fmtflags
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }

  inline _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }


  enum _Ios_Openmode { _M_ios_openmode_end = 1L << 16 };

  inline _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline _Ios_Openmode
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline _Ios_Openmode
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }

  inline _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }


  enum _Ios_Iostate { _M_ios_iostate_end = 1L << 16 };

  inline _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline _Ios_Iostate
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline _Ios_Iostate
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }

  inline _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  enum _Ios_Seekdir { _M_ios_seekdir_end = 1L << 16 };
# 158 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/ios_base.h" 3
  class ios_base
  {
  public:



    class failure : public exception
    {
    public:


      explicit
      failure(const string& __str) throw();



      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();

    private:
      enum { _M_bufsize = 256 };
      char _M_name[_M_bufsize];

    };
# 212 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;

    static const fmtflags boolalpha = fmtflags(__ios_flags::_S_boolalpha);

    static const fmtflags dec = fmtflags(__ios_flags::_S_dec);

    static const fmtflags fixed = fmtflags(__ios_flags::_S_fixed);

    static const fmtflags hex = fmtflags(__ios_flags::_S_hex);



    static const fmtflags internal = fmtflags(__ios_flags::_S_internal);


    static const fmtflags left = fmtflags(__ios_flags::_S_left);

    static const fmtflags oct = fmtflags(__ios_flags::_S_oct);


    static const fmtflags right = fmtflags(__ios_flags::_S_right);

    static const fmtflags scientific = fmtflags(__ios_flags::_S_scientific);


    static const fmtflags showbase = fmtflags(__ios_flags::_S_showbase);


    static const fmtflags showpoint = fmtflags(__ios_flags::_S_showpoint);

    static const fmtflags showpos = fmtflags(__ios_flags::_S_showpos);

    static const fmtflags skipws = fmtflags(__ios_flags::_S_skipws);

    static const fmtflags unitbuf = fmtflags(__ios_flags::_S_unitbuf);


    static const fmtflags uppercase = fmtflags(__ios_flags::_S_uppercase);

    static const fmtflags adjustfield = fmtflags(__ios_flags::_S_adjustfield);

    static const fmtflags basefield = fmtflags(__ios_flags::_S_basefield);

    static const fmtflags floatfield = fmtflags(__ios_flags::_S_floatfield);
# 269 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;


    static const iostate badbit = iostate(__ios_flags::_S_badbit);

    static const iostate eofbit = iostate(__ios_flags::_S_eofbit);



    static const iostate failbit = iostate(__ios_flags::_S_failbit);

    static const iostate goodbit = iostate(0);
# 296 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;

    static const openmode app = openmode(__ios_flags::_S_app);

    static const openmode ate = openmode(__ios_flags::_S_ate);




    static const openmode binary = openmode(__ios_flags::_S_bin);

    static const openmode in = openmode(__ios_flags::_S_in);

    static const openmode out = openmode(__ios_flags::_S_out);

    static const openmode trunc = openmode(__ios_flags::_S_trunc);
# 323 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;

    static const seekdir beg = seekdir(0);

    static const seekdir cur = seekdir(1);

    static const seekdir end = seekdir(2);
# 345 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };




    typedef void (*event_callback) (event, ios_base&, int);




    void
    register_callback(event_callback __fn, int __index);

  protected:






    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;




    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
                     _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __atomic_add(&_M_refcount, 1); }


      int
      _M_remove_reference() { return __exchange_and_add(&_M_refcount, -1); }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void);


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    static const int _S_local_word_size = 8;
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index);


    locale _M_ios_locale;

    void
    _M_init();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

      static void
      _S_ios_create(bool __sync);

      static void
      _S_ios_destroy();




      static bool
      _S_initialized() { return _S_ios_base_init; }

    private:
      static int _S_ios_base_init;
      static bool _S_synced_with_stdio;
    };






    inline fmtflags
    flags() const { return _M_flags; }
# 481 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/ios_base.h" 3
    inline fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 497 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/ios_base.h" 3
    inline fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 514 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/ios_base.h" 3
    inline fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    inline void
    unsetf(fmtflags __mask) { _M_flags &= ~__mask; }
# 541 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/ios_base.h" 3
    inline streamsize
    precision() const { return _M_precision; }






    inline streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    inline streamsize
    width() const { return _M_width; }






    inline streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 590 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 602 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc);
# 613 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/ios_base.h" 3
    inline locale
    getloc() const { return _M_ios_locale; }
# 623 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/ios_base.h" 3
    inline const locale&
    _M_getloc() const { return _M_ios_locale; }





    static int
    xalloc() throw();




    inline long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
                        ? _M_word[__ix] : _M_grow_words(__ix);
      return __word._M_iword;
    }




    inline void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
                        ? _M_word[__ix] : _M_grow_words(__ix);
      return __word._M_pword;
    }






    ~ios_base();

  protected:
    ios_base();



  private:
    ios_base(const ios_base&);

    ios_base&
    operator=(const ios_base&);

  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }

}
# 50 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ios" 2 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 1 3
# 44 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3







namespace std
{





  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs(basic_ios<_CharT, _Traits>& _ios,
                      basic_streambuf<_CharT, _Traits>* __sbin,
                      basic_streambuf<_CharT, _Traits>* __sbout);
# 124 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;
# 147 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      typedef ctype<char_type> __ctype_type;
      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef typename traits_type::state_type __state_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs<>(basic_ios<char_type, traits_type>& __ios,
                          __streambuf_type* __sbin,__streambuf_type* __sbout);

    protected:
# 171 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      char_type* _M_buf;






      size_t _M_buf_size;






      size_t _M_buf_size_opt;







      bool _M_buf_unified;
# 205 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;







      ios_base::openmode _M_mode;






      locale _M_buf_locale;






      bool _M_buf_locale_init;
# 245 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      static const size_t _S_pback_size = 1;
      char_type _M_pback[_S_pback_size];
      char_type* _M_pback_cur_save;
      char_type* _M_pback_end_save;
      bool _M_pback_init;







      fpos<__state_type> _M_pos;




      void
      _M_pback_create()
      {
        if (!_M_pback_init)
          {
            size_t __dist = _M_in_end - _M_in_cur;
            size_t __len = min(_S_pback_size, __dist);
            traits_type::copy(_M_pback, _M_in_cur, __len);
            _M_pback_cur_save = _M_in_cur;
            _M_pback_end_save = _M_in_end;
            this->setg(_M_pback, _M_pback, _M_pback + __len);
            _M_pback_init = true;
          }
      }




      void
      _M_pback_destroy() throw()
      {
        if (_M_pback_init)
          {

            size_t __off_cur = _M_in_cur - _M_pback;


            size_t __off_end = 0;
            size_t __pback_len = _M_in_end - _M_pback;
            size_t __save_len = _M_pback_end_save - _M_buf;
            if (__pback_len > __save_len)
              __off_end = __pback_len - __save_len;

            this->setg(_M_buf, _M_pback_cur_save + __off_cur,
                       _M_pback_end_save + __off_end);
            _M_pback_cur_save = __null;
            _M_pback_end_save = __null;
            _M_pback_init = false;
          }
      }



      void
      _M_in_cur_move(off_type __n)
      {
        bool __testout = _M_out_cur;
        _M_in_cur += __n;
        if (__testout && _M_buf_unified)
          _M_out_cur += __n;
      }
# 322 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      void
      _M_out_cur_move(off_type __n)
      {
        bool __testin = _M_in_cur;

        _M_out_cur += __n;
        if (__testin && _M_buf_unified)
          _M_in_cur += __n;
        if (_M_out_cur > _M_out_end)
          {
            _M_out_end = _M_out_cur;

            if (__testin)
              _M_in_end += __n;
          }
      }




      off_type
      _M_out_buf_size()
      {
        off_type __ret = 0;
        if (_M_out_cur)
          {

            if (_M_out_beg == _M_buf)
              __ret = _M_out_beg + _M_buf_size - _M_out_cur;

            else
              __ret = _M_out_end - _M_out_cur;
          }
        return __ret;
      }

  public:

      virtual
      ~basic_streambuf()
      {
        _M_buf_unified = false;
        _M_buf_size = 0;
        _M_buf_size_opt = 0;
        _M_mode = ios_base::openmode(0);
      }
# 377 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      locale
      pubimbue(const locale &__loc)
      {
        locale __tmp(this->getloc());
        this->imbue(__loc);
        return __tmp;
      }
# 393 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 406 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      __streambuf_type*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }

      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
                 ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }

      pos_type
      pubseekpos(pos_type __sp,
                 ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }

      int
      pubsync() { return this->sync(); }
# 433 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      streamsize
      in_avail()
      {
        streamsize __ret;
        if (_M_in_cur && _M_in_cur < _M_in_end)
          {
            if (_M_pback_init)
              {
                size_t __save_len = _M_pback_end_save - _M_pback_cur_save;
                size_t __pback_len = _M_in_cur - _M_pback;
                __ret = __save_len - __pback_len;
              }
            else
              __ret = this->egptr() - this->gptr();
          }
        else
          __ret = this->showmanyc();
        return __ret;
      }
# 460 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      int_type
      snextc()
      {
        int_type __eof = traits_type::eof();
        return (traits_type::eq_int_type(this->sbumpc(), __eof)
                ? __eof : this->sgetc());
      }
# 476 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      int_type
      sbumpc();
# 487 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      int_type
      sgetc()
      {
        int_type __ret;
        if (_M_in_cur && _M_in_cur < _M_in_end)
          __ret = traits_type::to_int_type(*(this->gptr()));
        else
          __ret = this->underflow();
        return __ret;
      }
# 506 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 520 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      int_type
      sputbackc(char_type __c);
# 532 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      int_type
      sungetc();
# 548 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      int_type
      sputc(char_type __c);
# 562 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 576 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      basic_streambuf()
      : _M_buf(__null), _M_buf_size(0), _M_buf_size_opt(8192),
      _M_buf_unified(false), _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_mode(ios_base::openmode(0)), _M_buf_locale(locale()),
      _M_pback_cur_save(0), _M_pback_end_save(0),
      _M_pback_init(false)
      { }
# 597 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 613 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 624 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
        _M_in_beg = __gbeg;
        _M_in_cur = __gnext;
        _M_in_end = __gend;
        if (!(_M_mode & ios_base::in) && __gbeg && __gnext && __gend)
          _M_mode = _M_mode | ios_base::in;
      }
# 646 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 662 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 672 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
        _M_out_beg = _M_out_cur = __pbeg;
        _M_out_end = __pend;
        if (!(_M_mode & ios_base::out) && __pbeg && __pend)
          _M_mode = _M_mode | ios_base::out;
      }
# 694 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      virtual void
      imbue(const locale& __loc)
      {
        if (_M_buf_locale != __loc)
          _M_buf_locale = __loc;
      }
# 712 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 723 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
              ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 735 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
              ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 748 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      virtual int
      sync() { return 0; }
# 770 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 786 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 808 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 821 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      virtual int_type
      uflow()
      {
        int_type __ret = traits_type::eof();
        bool __testeof = traits_type::eq_int_type(this->underflow(), __ret);
        bool __testpending = _M_in_cur && _M_in_cur < _M_in_end;
        if (!__testeof && __testpending)
          {
            __ret = traits_type::to_int_type(*_M_in_cur);
            ++_M_in_cur;
            if (_M_buf_unified && _M_mode & ios_base::out)
              ++_M_out_cur;
          }
        return __ret;
      }
# 847 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      virtual int_type
      pbackfail(int_type = traits_type::eof())
      { return traits_type::eof(); }
# 865 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 890 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
      virtual int_type
      overflow(int_type = traits_type::eof())
      { return traits_type::eof(); }
# 921 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 3
    private:
      basic_streambuf(const __streambuf_type&) { };

      __streambuf_type&
      operator=(const __streambuf_type&) { return *this; };

    };
}





# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/streambuf.tcc" 1 3
# 39 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/streambuf.tcc" 3

namespace std
{
  template<typename _CharT, typename _Traits>
    const size_t
    basic_streambuf<_CharT, _Traits>::_S_pback_size;

  template<typename _CharT, typename _Traits>
    typename basic_streambuf<_CharT, _Traits>::int_type
    basic_streambuf<_CharT, _Traits>::
    sbumpc()
    {
      int_type __ret;
      if (_M_in_cur && _M_in_cur < _M_in_end)
        {
          char_type __c = *(this->gptr());
          _M_in_cur_move(1);
          __ret = traits_type::to_int_type(__c);
        }
      else
        __ret = this->uflow();
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_streambuf<_CharT, _Traits>::int_type
    basic_streambuf<_CharT, _Traits>::
    sputbackc(char_type __c)
    {
      int_type __ret;
      bool __testpos = _M_in_cur && _M_in_beg < _M_in_cur;
      if (!__testpos || !traits_type::eq(__c, this->gptr()[-1]))
        __ret = this->pbackfail(traits_type::to_int_type(__c));
      else
        {
          _M_in_cur_move(-1);
          __ret = traits_type::to_int_type(*this->gptr());
        }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_streambuf<_CharT, _Traits>::int_type
    basic_streambuf<_CharT, _Traits>::
    sungetc()
    {
      int_type __ret;
      if (_M_in_cur && _M_in_beg < _M_in_cur)
        {
          _M_in_cur_move(-1);
          __ret = traits_type::to_int_type(*_M_in_cur);
        }
      else
        __ret = this->pbackfail();
      return __ret;
    }






  template<typename _CharT, typename _Traits>
    typename basic_streambuf<_CharT, _Traits>::int_type
    basic_streambuf<_CharT, _Traits>::
    sputc(char_type __c)
    {
      int_type __ret;
      if (_M_out_buf_size())
        {
          *_M_out_cur = __c;
          _M_out_cur_move(1);
          __ret = traits_type::to_int_type(__c);
        }
      else
        __ret = this->overflow(traits_type::to_int_type(__c));
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
        {
          size_t __buf_len = _M_in_end - _M_in_cur;
          if (__buf_len > 0)
            {
              size_t __remaining = __n - __ret;
              size_t __len = min(__buf_len, __remaining);
              traits_type::copy(__s, _M_in_cur, __len);
              __ret += __len;
              __s += __len;
              _M_in_cur_move(__len);
            }

          if (__ret < __n)
            {
              int_type __c = this->uflow();
              if (!traits_type::eq_int_type(__c, traits_type::eof()))
                {
                  traits_type::assign(*__s++, traits_type::to_char_type(__c));
                  ++__ret;
                }
              else
                break;
            }
        }
      return __ret;
    }






  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
        {
          off_type __buf_len = _M_out_buf_size();
          if (__buf_len > 0)
            {
              off_type __remaining = __n - __ret;
              off_type __len = min(__buf_len, __remaining);
              traits_type::copy(_M_out_cur, __s, __len);
              __ret += __len;
              __s += __len;
              _M_out_cur_move(__len);
            }

          if (__ret < __n)
            {
              int_type __c = this->overflow(traits_type::to_int_type(*__s));
              if (!traits_type::eq_int_type(__c, traits_type::eof()))
                {
                  ++__ret;
                  ++__s;
                }
              else
                break;
            }
        }
      return __ret;
    }





  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs(basic_ios<_CharT, _Traits>& __ios,
                      basic_streambuf<_CharT, _Traits>* __sbin,
                      basic_streambuf<_CharT, _Traits>* __sbout)
  {
    streamsize __ret = 0;
    try
      {
        typename _Traits::int_type __c = __sbin->sgetc();
        while (!_Traits::eq_int_type(__c, _Traits::eof()))
          {
            const size_t __n = __sbin->_M_in_end - __sbin->_M_in_cur;
            if (__n > 1)
              {
                const size_t __wrote = __sbout->sputn(__sbin->_M_in_cur,
                                                      __n);
                __sbin->_M_in_cur_move(__wrote);
                __ret += __wrote;
                if (__wrote < __n)
                  break;
                __c = __sbin->underflow();
              }
            else
              {
                __c = __sbout->sputc(_Traits::to_char_type(__c));
                if (_Traits::eq_int_type(__c, _Traits::eof()))
                  break;
                ++__ret;
                __c = __sbin->snextc();
              }
          }
      }
    catch(exception& __fail)
      {
        __ios.setstate(ios_base::failbit);
        if ((__ios.exceptions() & ios_base::failbit) != 0)
          throw;
      }
    return __ret;
  }





  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_ios<char>&, basic_streambuf<char>*,
                      basic_streambuf<char>*);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_ios<wchar_t>&, basic_streambuf<wchar_t>*,
                      basic_streambuf<wchar_t>*);


}
# 935 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/streambuf" 2 3
# 51 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ios" 2 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/basic_ios.h" 1 3
# 40 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/basic_ios.h" 3

# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/streambuf_iterator.h" 1 3
# 40 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/streambuf_iterator.h" 3





namespace std
{

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
                      _CharT*, _CharT&>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;

    private:







      mutable streambuf_type* _M_sbuf;
      int_type _M_c;

    public:
      istreambuf_iterator() throw()
      : _M_sbuf(0), _M_c(traits_type::eof()) { }

      istreambuf_iterator(istream_type& __s) throw()
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }

      istreambuf_iterator(streambuf_type* __s) throw()
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }


      char_type
      operator*() const
      { return traits_type::to_char_type(_M_get()); }

      istreambuf_iterator&
      operator++()
      {
        const int_type __eof = traits_type::eof();
        if (_M_sbuf && traits_type::eq_int_type(_M_sbuf->sbumpc(), __eof))
          _M_sbuf = 0;
        else
          _M_c = __eof;
        return *this;
      }

      istreambuf_iterator
      operator++(int)
      {
        const int_type __eof = traits_type::eof();
        istreambuf_iterator __old = *this;
        if (_M_sbuf
            && traits_type::eq_int_type((__old._M_c = _M_sbuf->sbumpc()),
                                        __eof))
          _M_sbuf = 0;
        else
          _M_c = __eof;
        return __old;
      }




      bool
      equal(const istreambuf_iterator& __b) const
      {
        const int_type __eof = traits_type::eof();
        bool __thiseof = traits_type::eq_int_type(_M_get(), __eof);
        bool __beof = traits_type::eq_int_type(__b._M_get(), __eof);
        return (__thiseof && __beof || (!__thiseof && !__beof));
      }


    private:
      int_type
      _M_get() const
      {
        const int_type __eof = traits_type::eof();
        int_type __ret = __eof;
        if (_M_sbuf)
          {
            if (!traits_type::eq_int_type(_M_c, __eof))
              __ret = _M_c;
            else
              if (traits_type::eq_int_type((__ret = _M_sbuf->sgetc()), __eof))
                _M_sbuf = 0;
          }
        return __ret;
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
               const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
               const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:
      ostreambuf_iterator(ostream_type& __s) throw ()
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }

      ostreambuf_iterator(streambuf_type* __s) throw ()
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }

      ostreambuf_iterator&
      operator=(_CharT __c)
      {
        if (!_M_failed &&
            _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
          _M_failed = true;
        return *this;
      }

      ostreambuf_iterator&
      operator*() throw()
      { return *this; }

      ostreambuf_iterator&
      operator++(int) throw()
      { return *this; }

      ostreambuf_iterator&
      operator++() throw()
      { return *this; }

      bool
      failed() const throw()
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
        if (__builtin_expect(!_M_failed, true) &&
            __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len, false))
          _M_failed = true;
        return *this;
      }
    };
}
# 42 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/basic_ios.h" 2 3


# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/locale_facets.h" 1 3
# 44 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/locale_facets.h" 3


# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cwctype" 1 3
# 48 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cwctype" 3




# 1 "/usr/include/wctype.h" 1 3 4
# 35 "/usr/include/wctype.h" 3 4
# 1 "/s/gcc-3.3.1/i386_rh72/lib/gcc-lib/i686-pc-linux-gnu/3.3.1/include/stddef.h" 1 3 4
# 36 "/usr/include/wctype.h" 2 3 4
# 45 "/usr/include/wctype.h" 3 4

# 63 "/usr/include/wctype.h" 3 4



typedef unsigned long int wctype_t;

# 85 "/usr/include/wctype.h" 3 4
enum
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};



extern "C" {








extern int iswalnum (wint_t __wc) throw ();





extern int iswalpha (wint_t __wc) throw ();


extern int iswcntrl (wint_t __wc) throw ();



extern int iswdigit (wint_t __wc) throw ();



extern int iswgraph (wint_t __wc) throw ();




extern int iswlower (wint_t __wc) throw ();


extern int iswprint (wint_t __wc) throw ();




extern int iswpunct (wint_t __wc) throw ();




extern int iswspace (wint_t __wc) throw ();




extern int iswupper (wint_t __wc) throw ();




extern int iswxdigit (wint_t __wc) throw ();





extern int iswblank (wint_t __wc) throw ();
# 185 "/usr/include/wctype.h" 3 4
extern wctype_t wctype (__const char *__property) throw ();



extern int iswctype (wint_t __wc, wctype_t __desc) throw ();










typedef __const __int32_t *wctrans_t;







extern wint_t towlower (wint_t __wc) throw ();


extern wint_t towupper (wint_t __wc) throw ();


}
# 227 "/usr/include/wctype.h" 3 4
extern "C" {




extern wctrans_t wctrans (__const char *__property) throw ();


extern wint_t towctrans (wint_t __wc, wctrans_t __desc) throw ();








extern int iswalnum_l (wint_t __wc, __locale_t __locale) throw ();





extern int iswalpha_l (wint_t __wc, __locale_t __locale) throw ();


extern int iswcntrl_l (wint_t __wc, __locale_t __locale) throw ();



extern int iswdigit_l (wint_t __wc, __locale_t __locale) throw ();



extern int iswgraph_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswlower_l (wint_t __wc, __locale_t __locale) throw ();


extern int iswprint_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswpunct_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswspace_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswupper_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswxdigit_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswblank_l (wint_t __wc, __locale_t __locale) throw ();



extern wctype_t wctype_l (__const char *__property, __locale_t __locale)
     throw ();



extern int iswctype_l (wint_t __wc, wctype_t __desc, __locale_t __locale)
     throw ();







extern wint_t towlower_l (wint_t __wc, __locale_t __locale) throw ();


extern wint_t towupper_l (wint_t __wc, __locale_t __locale) throw ();



extern wctrans_t wctrans_l (__const char *__property, __locale_t __locale)
     throw ();


extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
                           __locale_t __locale) throw ();



}
# 53 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cwctype" 2 3
# 77 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cwctype" 3
namespace std
{
  using ::wint_t;

  using ::wctype_t;
  using ::wctrans_t;

  using ::iswalnum;
  using ::iswalpha;
  using ::iswblank;
  using ::iswcntrl;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::iswctype;
  using ::towlower;
  using ::towupper;
  using ::towctrans;
  using ::wctrans;
  using ::wctype;
}
# 47 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/locale_facets.h" 2 3




namespace std
{
# 63 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/locale_facets.h" 3
  template<typename _Tv>
    void
    __convert_to_v(const char* __in, _Tv& __out, ios_base::iostate& __err,
                   const __c_locale& __cloc, int __base = 10);


  template<>
    void
    __convert_to_v(const char*, long&, ios_base::iostate&,
                   const __c_locale&, int);

  template<>
    void
    __convert_to_v(const char*, unsigned long&, ios_base::iostate&,
                   const __c_locale&, int);


  template<>
    void
    __convert_to_v(const char*, long long&, ios_base::iostate&,
                   const __c_locale&, int);

  template<>
    void
    __convert_to_v(const char*, unsigned long long&, ios_base::iostate&,
                   const __c_locale&, int);


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
                   const __c_locale&, int);

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
                   const __c_locale&, int);

 template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
                   const __c_locale&, int);



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
             const _CharT* __olds, const streamsize __newlen,
             const streamsize __oldlen, const bool __num);
    };
# 125 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/locale_facets.h" 3
  template<typename _CharT>
    bool
    __verify_grouping(const basic_string<_CharT>& __grouping,
                      basic_string<_CharT>& __grouping_tmp);






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
                   const char* __gbeg, const char* __gend,
                   const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
        *__s = __ws[__j];
      return __s;
    }



# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/ctype_base.h" 1 3
# 36 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/ctype_base.h" 3
  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = _ISupper;
    static const mask lower = _ISlower;
    static const mask alpha = _ISalpha;
    static const mask digit = _ISdigit;
    static const mask xdigit = _ISxdigit;
    static const mask space = _ISspace;
    static const mask print = _ISprint;
    static const mask graph = _ISgraph;
    static const mask cntrl = _IScntrl;
    static const mask punct = _ISpunct;
    static const mask alnum = _ISalnum;
  };
# 167 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/locale_facets.h" 2 3


  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:

      typedef _CharT char_type;

      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }

      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }

      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }

      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }

      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }

      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }

      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }

      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }

      char_type
      widen(char __c) const
      { return this->do_widen(__c); }

      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }

      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }

      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
              char __dfault, char *__to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): locale::facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }

      virtual bool
      do_is(mask __m, char_type __c) const = 0;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
            mask* __vec) const = 0;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
                 const char_type* __hi) const = 0;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
                  const char_type* __hi) const = 0;

      virtual char_type
      do_toupper(char_type) const = 0;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;

      virtual char_type
      do_tolower(char_type) const = 0;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;

      virtual char_type
      do_widen(char) const = 0;

      virtual const char*
      do_widen(const char* __lo, const char* __hi,
               char_type* __dest) const = 0;

      virtual char
      do_narrow(char_type, char __dfault) const = 0;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
                 char __dfault, char* __dest) const = 0;
    };


  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename ctype::mask mask;

      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
                  const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
                char __dfault, char* __dest) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;


  template<>
    class ctype<char> : public __ctype_abstract_base<char>
    {
    public:

      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;

    public:
      static locale::id id;
      static const size_t table_size = 1 + static_cast<unsigned char>(-1);

      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);

      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
            size_t __refs = 0);

      inline bool
      is(mask __m, char __c) const;

      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;

      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;

      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;

    protected:
      const mask*
      table() const throw()
      { return _M_table; }

      static const mask*
      classic_table() throw();

      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
                  const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
                char __dfault, char* __dest) const;
    };

  template<>
    const ctype<char>&
    use_facet<ctype<char> >(const locale& __loc);



  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:

      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;

    public:

      static locale::id id;

      explicit
      ctype(size_t __refs = 0);

      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const;

      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
                  const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
                char __dfault, char* __dest) const;

    };

  template<>
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale& __loc);



# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/ctype_inline.h" 1 3
# 37 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/ctype_inline.h" 3
  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return _M_table[static_cast<unsigned char>(__c)] & __m; }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
           && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
           && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      ++__low;
    return __low;
  }
# 504 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/locale_facets.h" 2 3


  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef _CharT char_type;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname() { };
    };


  template<>
    ctype_byname<char>::ctype_byname(const char*, size_t refs);

  template<>
    ctype_byname<wchar_t>::ctype_byname(const char*, size_t refs);


# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/codecvt.h" 1 3
# 45 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/codecvt.h" 3


  class codecvt_base
  {
  public:
    enum result
    {
      ok,
      partial,
      error,
      noconv
    };
  };





  template<typename _InternT, typename _ExternT, typename _StateT>
    class __codecvt_abstract_base
    : public locale::facet, public codecvt_base
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;


      result
      out(state_type& __state, const intern_type* __from,
          const intern_type* __from_end, const intern_type*& __from_next,
          extern_type* __to, extern_type* __to_end,
          extern_type*& __to_next) const
      {
        return this->do_out(__state, __from, __from_end, __from_next,
                            __to, __to_end, __to_next);
      }

      result
      unshift(state_type& __state, extern_type* __to, extern_type* __to_end,
              extern_type*& __to_next) const
      { return this->do_unshift(__state, __to,__to_end,__to_next); }

      result
      in(state_type& __state, const extern_type* __from,
         const extern_type* __from_end, const extern_type*& __from_next,
         intern_type* __to, intern_type* __to_end,
         intern_type*& __to_next) const
      {
        return this->do_in(__state, __from, __from_end, __from_next,
                           __to, __to_end, __to_next);
      }

      int
      encoding() const throw()
      { return this->do_encoding(); }

      bool
      always_noconv() const throw()
      { return this->do_always_noconv(); }

      int
      length(const state_type& __state, const extern_type* __from,
             const extern_type* __end, size_t __max) const
      { return this->do_length(__state, __from, __end, __max); }

      int
      max_length() const throw()
      { return this->do_max_length(); }

    protected:
      explicit
      __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }

      virtual
      ~__codecvt_abstract_base() { }

      virtual result
      do_out(state_type& __state, const intern_type* __from,
             const intern_type* __from_end, const intern_type*& __from_next,
             extern_type* __to, extern_type* __to_end,
             extern_type*& __to_next) const = 0;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
                 extern_type* __to_end, extern_type*& __to_next) const = 0;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
            const extern_type* __from_end, const extern_type*& __from_next,
            intern_type* __to, intern_type* __to_end,
            intern_type*& __to_next) const = 0;

      virtual int
      do_encoding() const throw() = 0;

      virtual bool
      do_always_noconv() const throw() = 0;

      virtual int
      do_length(const state_type&, const extern_type* __from,
                const extern_type* __end, size_t __max) const = 0;

      virtual int
      do_max_length() const throw() = 0;
    };



  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt
    : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<_InternT, _ExternT, _StateT> (__refs) { }

    protected:
      virtual
      ~codecvt() { }

      virtual result
      do_out(state_type& __state, const intern_type* __from,
             const intern_type* __from_end, const intern_type*& __from_next,
             extern_type* __to, extern_type* __to_end,
             extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
                 extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
            const extern_type* __from_end, const extern_type*& __from_next,
            intern_type* __to, intern_type* __to_end,
            intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(const state_type&, const extern_type* __from,
                const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };

  template<typename _InternT, typename _ExternT, typename _StateT>
    locale::id codecvt<_InternT, _ExternT, _StateT>::id;


  template<>
    class codecvt<char, char, mbstate_t>
    : public __codecvt_abstract_base<char, char, mbstate_t>
    {
    public:

      typedef char intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
             const intern_type* __from_end, const intern_type*& __from_next,
             extern_type* __to, extern_type* __to_end,
             extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
                 extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
            const extern_type* __from_end, const extern_type*& __from_next,
            intern_type* __to, intern_type* __to_end,
            intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(const state_type&, const extern_type* __from,
                const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
  };



  template<>
    class codecvt<wchar_t, char, mbstate_t>
    : public __codecvt_abstract_base<wchar_t, char, mbstate_t>
    {
    public:

      typedef wchar_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
             const intern_type* __from_end, const intern_type*& __from_next,
             extern_type* __to, extern_type* __to_end,
             extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
                 extern_type* __to, extern_type* __to_end,
                 extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
             const extern_type* __from, const extern_type* __from_end,
             const extern_type*& __from_next,
             intern_type* __to, intern_type* __to_end,
             intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(const state_type&, const extern_type* __from,
                    const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };



  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>
    {
    public:
      explicit
      codecvt_byname(const char*, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__refs) { }

    protected:
      virtual
      ~codecvt_byname() { }
    };




# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/codecvt_specializations.h" 1 3
# 46 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/codecvt_specializations.h" 3
  class __enc_traits
  {
  public:



    typedef iconv_t __desc_type;

  protected:


    static const int _S_max_size = 32;

    char _M_int_enc[_S_max_size];

    char _M_ext_enc[_S_max_size];


    __desc_type _M_in_desc;

    __desc_type _M_out_desc;


    int _M_ext_bom;


    int _M_int_bom;

  public:
    explicit __enc_traits()
    : _M_in_desc(0), _M_out_desc(0), _M_ext_bom(0), _M_int_bom(0)
    {
      memset(_M_int_enc, 0, _S_max_size);
      memset(_M_ext_enc, 0, _S_max_size);
    }

    explicit __enc_traits(const char* __int, const char* __ext,
                          int __ibom = 0, int __ebom = 0)
    : _M_in_desc(0), _M_out_desc(0), _M_ext_bom(0), _M_int_bom(0)
    {
      strncpy(_M_int_enc, __int, _S_max_size);
      strncpy(_M_ext_enc, __ext, _S_max_size);
    }






    __enc_traits(const __enc_traits& __obj): _M_in_desc(0), _M_out_desc(0)
    {
      strncpy(_M_int_enc, __obj._M_int_enc, _S_max_size);
      strncpy(_M_ext_enc, __obj._M_ext_enc, _S_max_size);
      _M_ext_bom = __obj._M_ext_bom;
      _M_int_bom = __obj._M_int_bom;
    }


    __enc_traits&
    operator=(const __enc_traits& __obj)
    {
      strncpy(_M_int_enc, __obj._M_int_enc, _S_max_size);
      strncpy(_M_ext_enc, __obj._M_ext_enc, _S_max_size);
      _M_in_desc = 0;
      _M_out_desc = 0;
      _M_ext_bom = __obj._M_ext_bom;
      _M_int_bom = __obj._M_int_bom;
      return *this;
    }

    ~__enc_traits()
    {
      __desc_type __err = reinterpret_cast<iconv_t>(-1);
      if (_M_in_desc && _M_in_desc != __err)
        iconv_close(_M_in_desc);
      if (_M_out_desc && _M_out_desc != __err)
        iconv_close(_M_out_desc);
    }

    void
    _M_init()
    {
      const __desc_type __err = reinterpret_cast<iconv_t>(-1);
      if (!_M_in_desc)
        {
          _M_in_desc = iconv_open(_M_int_enc, _M_ext_enc);
          if (_M_in_desc == __err)
            __throw_runtime_error("creating iconv input descriptor failed.");
        }
      if (!_M_out_desc)
        {
          _M_out_desc = iconv_open(_M_ext_enc, _M_int_enc);
          if (_M_out_desc == __err)
            __throw_runtime_error("creating iconv output descriptor failed.");
        }
    }

    bool
    _M_good()
    {
      const __desc_type __err = reinterpret_cast<iconv_t>(-1);
      bool __test = _M_in_desc && _M_in_desc != __err;
      __test &= _M_out_desc && _M_out_desc != __err;
      return __test;
    }

    const __desc_type*
    _M_get_in_descriptor()
    { return &_M_in_desc; }

    const __desc_type*
    _M_get_out_descriptor()
    { return &_M_out_desc; }

    int
    _M_get_external_bom()
    { return _M_ext_bom; }

    int
    _M_get_internal_bom()
    { return _M_int_bom; }

    const char*
    _M_get_internal_enc()
    { return _M_int_enc; }

    const char*
    _M_get_external_enc()
    { return _M_ext_enc; }
  };




  template<typename _InternT, typename _ExternT>
    class codecvt<_InternT, _ExternT, __enc_traits>
    : public __codecvt_abstract_base<_InternT, _ExternT, __enc_traits>
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef __enc_traits state_type;
      typedef __enc_traits::__desc_type __desc_type;
      typedef __enc_traits __enc_type;


      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<intern_type, extern_type, state_type>(__refs)
      { }

      explicit
      codecvt(__enc_type* __enc, size_t __refs = 0)
      : __codecvt_abstract_base<intern_type, extern_type, state_type>(__refs)
      { }

    protected:
      virtual
      ~codecvt() { }

      virtual result
      do_out(state_type& __state, const intern_type* __from,
             const intern_type* __from_end, const intern_type*& __from_next,
             extern_type* __to, extern_type* __to_end,
             extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
                 extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
            const extern_type* __from_end, const extern_type*& __from_next,
            intern_type* __to, intern_type* __to_end,
            intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(const state_type&, const extern_type* __from,
                const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };

  template<typename _InternT, typename _ExternT>
    locale::id
    codecvt<_InternT, _ExternT, __enc_traits>::id;





  template<typename _T>
    inline size_t
    __iconv_adaptor(size_t(*__func)(iconv_t, _T, size_t*, char**, size_t*),
                    iconv_t __cd, char** __inbuf, size_t* __inbytes,
                    char** __outbuf, size_t* __outbytes)
    { return __func(__cd, (_T)__inbuf, __inbytes, __outbuf, __outbytes); }

  template<typename _InternT, typename _ExternT>
    codecvt_base::result
    codecvt<_InternT, _ExternT, __enc_traits>::
    do_out(state_type& __state, const intern_type* __from,
           const intern_type* __from_end, const intern_type*& __from_next,
           extern_type* __to, extern_type* __to_end,
           extern_type*& __to_next) const
    {
      result __ret = codecvt_base::error;
      if (__state._M_good())
        {
          typedef state_type::__desc_type __desc_type;
          const __desc_type* __desc = __state._M_get_out_descriptor();
          const size_t __fmultiple = sizeof(intern_type);
          size_t __fbytes = __fmultiple * (__from_end - __from);
          const size_t __tmultiple = sizeof(extern_type);
          size_t __tbytes = __tmultiple * (__to_end - __to);



          char* __cto = reinterpret_cast<char*>(__to);
          char* __cfrom;
          size_t __conv;






          int __int_bom = __state._M_get_internal_bom();
          if (__int_bom)
            {
              size_t __size = __from_end - __from;
              intern_type* __cfixed = static_cast<intern_type*>(__builtin_alloca(sizeof(intern_type) * (__size + 1)));
              __cfixed[0] = static_cast<intern_type>(__int_bom);
              char_traits<intern_type>::copy(__cfixed + 1, __from, __size);
              __cfrom = reinterpret_cast<char*>(__cfixed);
              __conv = __iconv_adaptor(iconv, *__desc, &__cfrom,
                                        &__fbytes, &__cto, &__tbytes);
            }
          else
            {
              intern_type* __cfixed = const_cast<intern_type*>(__from);
              __cfrom = reinterpret_cast<char*>(__cfixed);
              __conv = __iconv_adaptor(iconv, *__desc, &__cfrom, &__fbytes,
                                       &__cto, &__tbytes);
            }

          if (__conv != size_t(-1))
            {
              __from_next = reinterpret_cast<const intern_type*>(__cfrom);
              __to_next = reinterpret_cast<extern_type*>(__cto);
              __ret = codecvt_base::ok;
            }
          else
            {
              if (__fbytes < __fmultiple * (__from_end - __from))
                {
                  __from_next = reinterpret_cast<const intern_type*>(__cfrom);
                  __to_next = reinterpret_cast<extern_type*>(__cto);
                  __ret = codecvt_base::partial;
                }
              else
                __ret = codecvt_base::error;
            }
        }
      return __ret;
    }

  template<typename _InternT, typename _ExternT>
    codecvt_base::result
    codecvt<_InternT, _ExternT, __enc_traits>::
    do_unshift(state_type& __state, extern_type* __to,
               extern_type* __to_end, extern_type*& __to_next) const
    {
      result __ret = codecvt_base::error;
      if (__state._M_good())
        {
          typedef state_type::__desc_type __desc_type;
          const __desc_type* __desc = __state._M_get_in_descriptor();
          const size_t __tmultiple = sizeof(intern_type);
          size_t __tlen = __tmultiple * (__to_end - __to);



          char* __cto = reinterpret_cast<char*>(__to);
          size_t __conv = __iconv_adaptor(iconv,*__desc, __null, __null,
                                          &__cto, &__tlen);

          if (__conv != size_t(-1))
            {
              __to_next = reinterpret_cast<extern_type*>(__cto);
              if (__tlen == __tmultiple * (__to_end - __to))
                __ret = codecvt_base::noconv;
              else if (__tlen == 0)
                __ret = codecvt_base::ok;
              else
                __ret = codecvt_base::partial;
            }
          else
            __ret = codecvt_base::error;
        }
      return __ret;
    }

  template<typename _InternT, typename _ExternT>
    codecvt_base::result
    codecvt<_InternT, _ExternT, __enc_traits>::
    do_in(state_type& __state, const extern_type* __from,
          const extern_type* __from_end, const extern_type*& __from_next,
          intern_type* __to, intern_type* __to_end,
          intern_type*& __to_next) const
    {
      result __ret = codecvt_base::error;
      if (__state._M_good())
        {
          typedef state_type::__desc_type __desc_type;
          const __desc_type* __desc = __state._M_get_in_descriptor();
          const size_t __fmultiple = sizeof(extern_type);
          size_t __flen = __fmultiple * (__from_end - __from);
          const size_t __tmultiple = sizeof(intern_type);
          size_t __tlen = __tmultiple * (__to_end - __to);



          char* __cto = reinterpret_cast<char*>(__to);
          char* __cfrom;
          size_t __conv;






          int __ext_bom = __state._M_get_external_bom();
          if (__ext_bom)
            {
              size_t __size = __from_end - __from;
              extern_type* __cfixed = static_cast<extern_type*>(__builtin_alloca(sizeof(extern_type) * (__size + 1)));
              __cfixed[0] = static_cast<extern_type>(__ext_bom);
              char_traits<extern_type>::copy(__cfixed + 1, __from, __size);
              __cfrom = reinterpret_cast<char*>(__cfixed);
              __conv = __iconv_adaptor(iconv, *__desc, &__cfrom,
                                       &__flen, &__cto, &__tlen);
            }
          else
            {
              extern_type* __cfixed = const_cast<extern_type*>(__from);
              __cfrom = reinterpret_cast<char*>(__cfixed);
              __conv = __iconv_adaptor(iconv, *__desc, &__cfrom,
                                       &__flen, &__cto, &__tlen);
            }


          if (__conv != size_t(-1))
            {
              __from_next = reinterpret_cast<const extern_type*>(__cfrom);
              __to_next = reinterpret_cast<intern_type*>(__cto);
              __ret = codecvt_base::ok;
            }
          else
            {
              if (__flen < static_cast<size_t>(__from_end - __from))
                {
                  __from_next = reinterpret_cast<const extern_type*>(__cfrom);
                  __to_next = reinterpret_cast<intern_type*>(__cto);
                  __ret = codecvt_base::partial;
                }
              else
                __ret = codecvt_base::error;
            }
        }
      return __ret;
    }

  template<typename _InternT, typename _ExternT>
    int
    codecvt<_InternT, _ExternT, __enc_traits>::
    do_encoding() const throw()
    {
      int __ret = 0;
      if (sizeof(_ExternT) <= sizeof(_InternT))
        __ret = sizeof(_InternT)/sizeof(_ExternT);
      return __ret;
    }

  template<typename _InternT, typename _ExternT>
    bool
    codecvt<_InternT, _ExternT, __enc_traits>::
    do_always_noconv() const throw()
    { return false; }

  template<typename _InternT, typename _ExternT>
    int
    codecvt<_InternT, _ExternT, __enc_traits>::
    do_length(const state_type&, const extern_type* __from,
              const extern_type* __end, size_t __max) const
    { return min(__max, static_cast<size_t>(__end - __from)); }



  template<typename _InternT, typename _ExternT>
    int
    codecvt<_InternT, _ExternT, __enc_traits>::
    do_max_length() const throw()
    { return 1; }
# 335 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/codecvt.h" 2 3
# 529 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/locale_facets.h" 2 3


  class __num_base
  {
  public:


    enum
      {
        _S_minus,
        _S_plus,
        _S_x,
        _S_X,
        _S_digits,
        _S_digits_end = _S_digits + 16,
        _S_udigits = _S_digits_end,
        _S_udigits_end = _S_udigits + 16,
        _S_e = _S_digits + 14,
        _S_E = _S_udigits + 14,
        _S_end = _S_udigits_end
      };






    static const char* _S_atoms_out;

  protected:


    static const char* _S_atoms_in;

    enum
    {
      _M_zero,
      _M_e = _M_zero + 10,
      _M_E = _M_zero + 11,
      _M_size = 21 + 1
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod,
                    streamsize __prec);


    static void
    _S_format_int(const ios_base& __io, char* __fptr, char __mod, char __modl);
  };


  template<typename _CharT>
    class __locale_cache;

  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:

      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      friend class __locale_cache<numpunct<_CharT> >;

      static locale::id id;

    private:
      char_type _M_decimal_point;
      char_type _M_thousands_sep;
      const char* _M_grouping;
      const char_type* _M_truename;
      const char_type* _M_falsename;

    public:
      explicit
      numpunct(size_t __refs = 0) : locale::facet(__refs)
      { _M_initialize_numpunct(); }

      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0) : locale::facet(__refs)
      { _M_initialize_numpunct(__cloc); }

      char_type
      decimal_point() const
      { return this->do_decimal_point(); }

      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }

      string
      grouping() const
      { return this->do_grouping(); }

      string_type
      truename() const
      { return this->do_truename(); }

      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:
      virtual
      ~numpunct();

      virtual char_type
      do_decimal_point() const
      { return _M_decimal_point; }

      virtual char_type
      do_thousands_sep() const
      { return _M_thousands_sep; }

      virtual string
      do_grouping() const
      { return _M_grouping; }

      virtual string_type
      do_truename() const
      { return _M_truename; }

      virtual string_type
      do_falsename() const
      { return _M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = __null);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);


  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {

      __c_locale _M_c_locale_numpunct;

    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
        _S_create_c_locale(_M_c_locale_numpunct, __s);
        _M_initialize_numpunct(_M_c_locale_numpunct);
      }

    protected:
      virtual
      ~numpunct_byname()
      { _S_destroy_c_locale(_M_c_locale_numpunct); }
    };

  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet, public __num_base
    {
    public:

      typedef _CharT char_type;
      typedef _InIter iter_type;

      static locale::id id;

      explicit
      num_get(size_t __refs = 0) : locale::facet(__refs) { }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
          ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
          ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
          ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
          ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
          ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
          ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
          ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
          ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
          ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
          ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
          ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:
      virtual ~num_get() { }

      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
                       string& __xtrc) const;

      iter_type
      _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
                     string& __xtrc, int& __base) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, long&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
              unsigned short&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
             unsigned int&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
             unsigned long&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
             long long&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
             unsigned long long&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
             float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
             double&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
             long double&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
             void*&) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 853 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet, public __num_base
    {
    public:

      typedef _CharT char_type;
      typedef _OutIter iter_type;
      static locale::id id;

      explicit
      num_put(size_t __refs = 0) : locale::facet(__refs) { }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, bool __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
          unsigned long __v) const
      { return this->do_put(__s, __f, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
          unsigned long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, double __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
          long double __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
          const void* __v) const
      { return this->do_put(__s, __f, __fill, __v); }

    protected:
      template<typename _ValueT>
        iter_type
        _M_convert_float(iter_type, ios_base& __io, char_type __fill,
                         char __mod, _ValueT __v) const;

      void
      _M_group_float(const string& __grouping, char_type __sep,
                     const char_type* __p, char_type* __new, char_type* __cs,
                     int& __len) const;

      template<typename _ValueT>
        iter_type
        _M_convert_int(iter_type, ios_base& __io, char_type __fill,
                       _ValueT __v) const;

      void
      _M_group_int(const string& __grouping, char_type __sep,
                   ios_base& __io, char_type* __new, char_type* __cs,
                   int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
             char_type* __new, const char_type* __cs, int& __len) const;



      template<typename _ValueT>
        iter_type
        _M_convert_int(iter_type, ios_base& __io, char_type __fill,
                       char __mod, char __modl, _ValueT __v) const;

      iter_type
      _M_widen_float(iter_type, ios_base& __io, char_type __fill, char* __cs,
                     int __len) const;

      iter_type
      _M_widen_int(iter_type, ios_base& __io, char_type __fill, char* __cs,
                   int __len) const;

      iter_type
      _M_insert(iter_type, ios_base& __io, char_type __fill,
                const char_type* __ws, int __len) const;


     virtual
      ~num_put() { };

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, unsigned long) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long long __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, unsigned long long) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, double __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long double __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, const void* __v) const;
    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;


  template<typename _CharT>
    class collate : public locale::facet
    {
    public:

      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

    protected:


      __c_locale _M_c_locale_collate;

    public:
      static locale::id id;

      explicit
      collate(size_t __refs = 0)
      : locale::facet(__refs)
      { _M_c_locale_collate = _S_c_locale; }

      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : locale::facet(__refs)
      { _M_c_locale_collate = _S_clone_c_locale(__cloc); }

      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
              const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }

      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }

      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const;

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const;

  protected:
      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }

      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
                 const _CharT* __lo2, const _CharT* __hi2) const;

      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;

      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const;

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const;


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const;

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const;


  template<typename _CharT>
    class collate_byname : public collate<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
        _S_destroy_c_locale(_M_c_locale_collate);
        _S_create_c_locale(_M_c_locale_collate, __s);
      }

    protected:
      virtual
      ~collate_byname() { }
    };


  class time_base
  {
  public:
    enum dateorder { no_order, dmy, mdy, ymd, ydm };
  };

  template<typename _CharT>
    class __timepunct : public locale::facet
    {
    public:

      typedef _CharT __char_type;
      typedef basic_string<_CharT> __string_type;

      static locale::id id;


      static const _CharT* _S_timezones[14];

    protected:
      __c_locale _M_c_locale_timepunct;
      char* _M_name_timepunct;
      const _CharT* _M_date_format;
      const _CharT* _M_date_era_format;
      const _CharT* _M_time_format;
      const _CharT* _M_time_era_format;
      const _CharT* _M_date_time_format;
      const _CharT* _M_date_time_era_format;
      const _CharT* _M_am;
      const _CharT* _M_pm;
      const _CharT* _M_am_pm_format;


      const _CharT* _M_day1;
      const _CharT* _M_day2;
      const _CharT* _M_day3;
      const _CharT* _M_day4;
      const _CharT* _M_day5;
      const _CharT* _M_day6;
      const _CharT* _M_day7;


      const _CharT* _M_day_a1;
      const _CharT* _M_day_a2;
      const _CharT* _M_day_a3;
      const _CharT* _M_day_a4;
      const _CharT* _M_day_a5;
      const _CharT* _M_day_a6;
      const _CharT* _M_day_a7;


      const _CharT* _M_month01;
      const _CharT* _M_month02;
      const _CharT* _M_month03;
      const _CharT* _M_month04;
      const _CharT* _M_month05;
      const _CharT* _M_month06;
      const _CharT* _M_month07;
      const _CharT* _M_month08;
      const _CharT* _M_month09;
      const _CharT* _M_month10;
      const _CharT* _M_month11;
      const _CharT* _M_month12;


      const _CharT* _M_month_a01;
      const _CharT* _M_month_a02;
      const _CharT* _M_month_a03;
      const _CharT* _M_month_a04;
      const _CharT* _M_month_a05;
      const _CharT* _M_month_a06;
      const _CharT* _M_month_a07;
      const _CharT* _M_month_a08;
      const _CharT* _M_month_a09;
      const _CharT* _M_month_a10;
      const _CharT* _M_month_a11;
      const _CharT* _M_month_a12;

    public:
      explicit
      __timepunct(size_t __refs = 0);

      explicit
      __timepunct(__c_locale __cloc, const char* __s, size_t __refs = 0);

      void
      _M_put(_CharT* __s, size_t __maxlen, const _CharT* __format,
             const tm* __tm) const;

      void
      _M_date_formats(const _CharT** __date) const
      {

        __date[0] = _M_date_format;
        __date[1] = _M_date_era_format;
      }

      void
      _M_time_formats(const _CharT** __time) const
      {

        __time[0] = _M_time_format;
        __time[1] = _M_time_era_format;
      }

      void
      _M_ampm(const _CharT** __ampm) const
      {
        __ampm[0] = _M_am;
        __ampm[1] = _M_pm;
      }

      void
      _M_date_time_formats(const _CharT** __dt) const
      {

        __dt[0] = _M_date_time_format;
        __dt[1] = _M_date_time_era_format;
      }

      void
      _M_days(const _CharT** __days) const
      {
        __days[0] = _M_day1;
        __days[1] = _M_day2;
        __days[2] = _M_day3;
        __days[3] = _M_day4;
        __days[4] = _M_day5;
        __days[5] = _M_day6;
        __days[6] = _M_day7;
      }

      void
      _M_days_abbreviated(const _CharT** __days) const
      {
        __days[0] = _M_day_a1;
        __days[1] = _M_day_a2;
        __days[2] = _M_day_a3;
        __days[3] = _M_day_a4;
        __days[4] = _M_day_a5;
        __days[5] = _M_day_a6;
        __days[6] = _M_day_a7;
      }

      void
      _M_months(const _CharT** __months) const
      {
        __months[0] = _M_month01;
        __months[1] = _M_month02;
        __months[2] = _M_month03;
        __months[3] = _M_month04;
        __months[4] = _M_month05;
        __months[5] = _M_month06;
        __months[6] = _M_month07;
        __months[7] = _M_month08;
        __months[8] = _M_month09;
        __months[9] = _M_month10;
        __months[10] = _M_month11;
        __months[11] = _M_month12;
      }

      void
      _M_months_abbreviated(const _CharT** __months) const
      {
        __months[0] = _M_month_a01;
        __months[1] = _M_month_a02;
        __months[2] = _M_month_a03;
        __months[3] = _M_month_a04;
        __months[4] = _M_month_a05;
        __months[5] = _M_month_a06;
        __months[6] = _M_month_a07;
        __months[7] = _M_month_a08;
        __months[8] = _M_month_a09;
        __months[9] = _M_month_a10;
        __months[10] = _M_month_a11;
        __months[11] = _M_month_a12;
      }

    protected:
      virtual
      ~__timepunct();


      void
      _M_initialize_timepunct(__c_locale __cloc = __null);
    };

  template<typename _CharT>
    locale::id __timepunct<_CharT>::id;


  template<>
    const char*
    __timepunct<char>::_S_timezones[14];

  template<>
    void
    __timepunct<char>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<char>::_M_put(char*, size_t, const char*, const tm*) const;


  template<>
    const wchar_t*
    __timepunct<wchar_t>::_S_timezones[14];

  template<>
    void
    __timepunct<wchar_t>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<wchar_t>::_M_put(wchar_t*, size_t, const wchar_t*,
                                 const tm*) const;



  template<typename _CharT>
    const _CharT* __timepunct<_CharT>::_S_timezones[14];


# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/time_members.h" 1 3
# 37 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/time_members.h" 3
  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(size_t __refs)
    : locale::facet(__refs)
    {



      _M_initialize_timepunct();
    }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__c_locale __cloc,
                                     const char* __s,
                                     size_t __refs)
    : locale::facet(__refs)
    {




      _M_initialize_timepunct(__cloc);
    }

  template<typename _CharT>
    __timepunct<_CharT>::~__timepunct()
    {




      _S_destroy_c_locale(_M_c_locale_timepunct);
    }
# 1311 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/locale_facets.h" 2 3

  template<typename _CharT, typename _InIter>
    class time_get : public locale::facet, public time_base
    {
    public:

      typedef _CharT char_type;
      typedef _InIter iter_type;
      typedef basic_string<_CharT> __string_type;

      static locale::id id;

      explicit
      time_get(size_t __refs = 0)
      : locale::facet (__refs) { }

      dateorder
      date_order() const
      { return this->do_date_order(); }

      iter_type
      get_time(iter_type __beg, iter_type __end, ios_base& __io,
               ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_time(__beg, __end, __io, __err, __tm); }

      iter_type
      get_date(iter_type __beg, iter_type __end, ios_base& __io,
               ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_date(__beg, __end, __io, __err, __tm); }

      iter_type
      get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
                  ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_weekday(__beg, __end, __io, __err, __tm); }

      iter_type
      get_monthname(iter_type __beg, iter_type __end, ios_base& __io,
                    ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_monthname(__beg, __end, __io, __err, __tm); }

      iter_type
      get_year(iter_type __beg, iter_type __end, ios_base& __io,
               ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_year(__beg, __end, __io, __err, __tm); }

    protected:
      virtual
      ~time_get() { }

      virtual dateorder
      do_date_order() const;

      virtual iter_type
      do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
                  ios_base::iostate& __err, tm* __tm) const;

      virtual iter_type
      do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
                  ios_base::iostate& __err, tm* __tm) const;

      virtual iter_type
      do_get_weekday(iter_type __beg, iter_type __end, ios_base&,
                     ios_base::iostate& __err, tm* __tm) const;

      virtual iter_type
      do_get_monthname(iter_type __beg, iter_type __end, ios_base&,
                       ios_base::iostate& __err, tm* __tm) const;

      virtual iter_type
      do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
                  ios_base::iostate& __err, tm* __tm) const;


      void
      _M_extract_num(iter_type& __beg, iter_type& __end, int& __member,
                     int __min, int __max, size_t __len,
                     const ctype<_CharT>& __ctype,
                     ios_base::iostate& __err) const;



      void
      _M_extract_name(iter_type& __beg, iter_type& __end, int& __member,
                      const _CharT** __names, size_t __indexlen,
                      ios_base::iostate& __err) const;


      void
      _M_extract_via_format(iter_type& __beg, iter_type& __end, ios_base& __io,
                            ios_base::iostate& __err, tm* __tm,
                            const _CharT* __format) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id time_get<_CharT, _InIter>::id;

  template<typename _CharT, typename _InIter>
    class time_get_byname : public time_get<_CharT, _InIter>
    {
    public:

      typedef _CharT char_type;
      typedef _InIter iter_type;

      explicit
      time_get_byname(const char*, size_t __refs = 0)
      : time_get<_CharT, _InIter>(__refs) { }

    protected:
      virtual
      ~time_get_byname() { }
    };

  template<typename _CharT, typename _OutIter>
    class time_put : public locale::facet, public time_base
    {
    public:

      typedef _CharT char_type;
      typedef _OutIter iter_type;

      static locale::id id;

      explicit
      time_put(size_t __refs = 0)
      : locale::facet(__refs) { }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
          const _CharT* __beg, const _CharT* __end) const;

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
          const tm* __tm, char __format, char __mod = 0) const
      { return this->do_put(__s, __io, __fill, __tm, __format, __mod); }

    protected:
      virtual
      ~time_put()
      { }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
             char __format, char __mod) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id time_put<_CharT, _OutIter>::id;

  template<typename _CharT, typename _OutIter>
    class time_put_byname : public time_put<_CharT, _OutIter>
    {
    public:

      typedef _CharT char_type;
      typedef _OutIter iter_type;

      explicit
      time_put_byname(const char* , size_t __refs = 0)
      : time_put<_CharT, _OutIter>(__refs)
      { };

    protected:
      virtual
      ~time_put_byname() { }
    };


  class money_base
  {
  public:
    enum part { none, space, symbol, sign, value };
    struct pattern { char field[4]; };

    static const pattern _S_default_pattern;



    static pattern
    _S_construct_pattern(char __precedes, char __space, char __posn);
  };

  template<typename _CharT, bool _Intl>
    class moneypunct : public locale::facet, public money_base
    {
    public:

      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      static const bool intl = _Intl;
      static locale::id id;

    private:
      const char* _M_grouping;
      char_type _M_decimal_point;
      char_type _M_thousands_sep;
      const char_type* _M_curr_symbol;
      const char_type* _M_positive_sign;
      const char_type* _M_negative_sign;
      int _M_frac_digits;
      pattern _M_pos_format;
      pattern _M_neg_format;

    public:
      explicit
      moneypunct(size_t __refs = 0) : locale::facet(__refs)
      { _M_initialize_moneypunct(); }

      explicit
      moneypunct(__c_locale __cloc, const char* __s, size_t __refs = 0)
      : locale::facet(__refs)
      { _M_initialize_moneypunct(__cloc, __s); }

      char_type
      decimal_point() const
      { return this->do_decimal_point(); }

      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }

      string
      grouping() const
      { return this->do_grouping(); }

      string_type
      curr_symbol() const
      { return this->do_curr_symbol(); }

      string_type
      positive_sign() const
      { return this->do_positive_sign(); }

      string_type
      negative_sign() const
      { return this->do_negative_sign(); }

      int
      frac_digits() const
      { return this->do_frac_digits(); }

      pattern
      pos_format() const
      { return this->do_pos_format(); }

      pattern
      neg_format() const
      { return this->do_neg_format(); }

    protected:
      virtual
      ~moneypunct();

      virtual char_type
      do_decimal_point() const
      { return _M_decimal_point; }

      virtual char_type
      do_thousands_sep() const
      { return _M_thousands_sep; }

      virtual string
      do_grouping() const
      { return _M_grouping; }

      virtual string_type
      do_curr_symbol() const
      { return _M_curr_symbol; }

      virtual string_type
      do_positive_sign() const
      { return _M_positive_sign; }

      virtual string_type
      do_negative_sign() const
      { return _M_negative_sign; }

      virtual int
      do_frac_digits() const
      { return _M_frac_digits; }

      virtual pattern
      do_pos_format() const
      { return _M_pos_format; }

      virtual pattern
      do_neg_format() const
      { return _M_neg_format; }


       void
       _M_initialize_moneypunct(__c_locale __cloc = __null,
                                const char* __name = __null);
    };

  template<typename _CharT, bool _Intl>
    locale::id moneypunct<_CharT, _Intl>::id;

  template<typename _CharT, bool _Intl>
    const bool moneypunct<_CharT, _Intl>::intl;

  template<>
    moneypunct<char, true>::~moneypunct();

  template<>
    moneypunct<char, false>::~moneypunct();

  template<>
    void
    moneypunct<char, true>::_M_initialize_moneypunct(__c_locale, const char*);

  template<>
    void
    moneypunct<char, false>::_M_initialize_moneypunct(__c_locale, const char*);


  template<>
    moneypunct<wchar_t, true>::~moneypunct();

  template<>
    moneypunct<wchar_t, false>::~moneypunct();

  template<>
    void
    moneypunct<wchar_t, true>::_M_initialize_moneypunct(__c_locale,
                                                        const char*);

  template<>
    void
    moneypunct<wchar_t, false>::_M_initialize_moneypunct(__c_locale,
                                                         const char*);


  template<typename _CharT, bool _Intl>
    class moneypunct_byname : public moneypunct<_CharT, _Intl>
    {
      __c_locale _M_c_locale_moneypunct;

    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      static const bool intl = _Intl;

      explicit
      moneypunct_byname(const char* __s, size_t __refs = 0)
      : moneypunct<_CharT, _Intl>(__refs)
      {
        _S_create_c_locale(_M_c_locale_moneypunct, __s);
        _M_initialize_moneypunct(_M_c_locale_moneypunct);
      }

    protected:
      virtual
      ~moneypunct_byname()
      { _S_destroy_c_locale(_M_c_locale_moneypunct); }
    };

  template<typename _CharT, bool _Intl>
    const bool moneypunct_byname<_CharT, _Intl>::intl;

  template<typename _CharT, typename _InIter>
    class money_get : public locale::facet
    {
    public:

      typedef _CharT char_type;
      typedef _InIter iter_type;
      typedef basic_string<_CharT> string_type;

      static locale::id id;

      explicit
      money_get(size_t __refs = 0) : locale::facet(__refs) { }

      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
          ios_base::iostate& __err, long double& __units) const
      { return this->do_get(__s, __end, __intl, __io, __err, __units); }

      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
          ios_base::iostate& __err, string_type& __digits) const
      { return this->do_get(__s, __end, __intl, __io, __err, __digits); }

    protected:
      virtual
      ~money_get() { }

      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
             ios_base::iostate& __err, long double& __units) const;

      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
             ios_base::iostate& __err, string_type& __digits) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id money_get<_CharT, _InIter>::id;

  template<typename _CharT, typename _OutIter>
    class money_put : public locale::facet
    {
    public:
      typedef _CharT char_type;
      typedef _OutIter iter_type;
      typedef basic_string<_CharT> string_type;

      static locale::id id;

      explicit
      money_put(size_t __refs = 0) : locale::facet(__refs) { }

      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
          char_type __fill, long double __units) const
      { return this->do_put(__s, __intl, __io, __fill, __units); }

      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
          char_type __fill, const string_type& __digits) const
      { return this->do_put(__s, __intl, __io, __fill, __digits); }

    protected:
      virtual
      ~money_put() { }

      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
             long double __units) const;

      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
             const string_type& __digits) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id money_put<_CharT, _OutIter>::id;


  struct messages_base
  {
    typedef int catalog;
  };

  template<typename _CharT>
    class messages : public locale::facet, public messages_base
    {
    public:

      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

    protected:


      __c_locale _M_c_locale_messages;
      char* _M_name_messages;

    public:
      static locale::id id;

      explicit
      messages(size_t __refs = 0);


      explicit
      messages(__c_locale __cloc, const char* __s, size_t __refs = 0);

      catalog
      open(const basic_string<char>& __s, const locale& __loc) const
      { return this->do_open(__s, __loc); }


      catalog
      open(const basic_string<char>&, const locale&, const char*) const;

      string_type
      get(catalog __c, int __set, int __msgid, const string_type& __s) const
      { return this->do_get(__c, __set, __msgid, __s); }

      void
      close(catalog __c) const
      { return this->do_close(__c); }

    protected:
      virtual
      ~messages();

      virtual catalog
      do_open(const basic_string<char>&, const locale&) const;

      virtual string_type
      do_get(catalog, int, int, const string_type& __dfault) const;

      virtual void
      do_close(catalog) const;


      char*
      _M_convert_to_char(const string_type& __msg) const
      {

        return reinterpret_cast<char*>(const_cast<_CharT*>(__msg.c_str()));
      }


      string_type
      _M_convert_from_char(char* __msg) const
      {

        size_t __len = char_traits<char>::length(__msg) - 1;
# 1856 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/locale_facets.h" 3
        return string_type();
      }
     };

  template<typename _CharT>
    locale::id messages<_CharT>::id;


  template<>
    string
    messages<char>::do_get(catalog, int, int, const string&) const;


  template<>
    wstring
    messages<wchar_t>::do_get(catalog, int, int, const wstring&) const;


  template<typename _CharT>
    class messages_byname : public messages<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      messages_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~messages_byname()
      { }
    };


# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/messages_members.h" 1 3
# 37 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/messages_members.h" 3
  template<typename _CharT>
     messages<_CharT>::messages(size_t __refs)
     : locale::facet(__refs)
     {



       _M_c_locale_messages = _S_c_locale;
     }

  template<typename _CharT>
     messages<_CharT>::messages(__c_locale __cloc,
                                const char* __s, size_t __refs)
     : locale::facet(__refs)
     {




       _M_c_locale_messages = _S_clone_c_locale(__cloc);
     }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::open(const basic_string<char>& __s, const locale& __loc,
                           const char* __dir) const
    {
      bindtextdomain(__s.c_str(), __dir);
      return this->do_open(__s, __loc);
    }


  template<typename _CharT>
    messages<_CharT>::~messages()
    {




      _S_destroy_c_locale(_M_c_locale_messages);
    }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::do_open(const basic_string<char>& __s,
                              const locale&) const
    {


      textdomain(__s.c_str());
      return 0;
    }

  template<typename _CharT>
    void
    messages<_CharT>::do_close(catalog) const
    { }


   template<typename _CharT>
     messages_byname<_CharT>::messages_byname(const char* __s, size_t __refs)
     : messages<_CharT>(__refs)
     {






       _S_destroy_c_locale(_M_c_locale_messages);
       _S_create_c_locale(_M_c_locale_messages, __s);
     }
# 1892 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/locale_facets.h" 2 3






  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }

  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }

  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }

  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }

  template<typename _CharT>
    inline bool islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }

  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }

  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }

  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }

  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }

  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }

  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }

  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }

  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }
# 1973 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/locale_facets.h" 3
  class __locale_cache_base
  {
    friend class std::locale::_Impl;
    friend class locale;

  public:
    virtual
    ~__locale_cache_base() { }

  };



  template<typename _Facet>
    class __locale_cache : public __locale_cache_base
    {

      __locale_cache(const locale&) {}
    };

  template<typename _CharT>
    class __locale_cache<numpunct<_CharT> > : public __locale_cache_base
    {

      typedef _CharT char_type;
      typedef char_traits<_CharT> traits_type;
      typedef basic_string<_CharT> string_type;

    public:





      _CharT _M_decimal_point;





      _CharT _M_thousands_sep;



      const _CharT* _M_truename;
      const _CharT* _M_falsename;



      bool _M_use_grouping;



      const char* _M_grouping;
# 2035 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/locale_facets.h" 3
      _CharT _M_atoms_out[__num_base::_S_end];


      __locale_cache(const locale& __loc);
      __locale_cache(const locale& __loc, bool);

      ~__locale_cache()
      {
        delete [] _M_truename;
        delete [] _M_falsename;
        delete [] _M_grouping;
      }
    };
}
# 45 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/basic_ios.h" 2 3

namespace std
{







  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
# 78 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/basic_ios.h" 3
      typedef ctype<_CharT> __ctype_type;
      typedef ostreambuf_iterator<_CharT, _Traits> __ostreambuf_iter;
      typedef num_put<_CharT, __ostreambuf_iter> __numput_type;
      typedef istreambuf_iterator<_CharT, _Traits> __istreambuf_iter;
      typedef num_get<_CharT, __istreambuf_iter> __numget_type;


      friend void ios_base::Init::_S_ios_create(bool);


    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_fctype;

      const __numput_type* _M_fnumput;

      const __numget_type* _M_fnumget;

    public:







      operator void*() const
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }

      bool
      operator!() const
      { return this->fail(); }
# 124 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 135 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 175 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 196 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 231 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb) : ios_base()
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 267 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 279 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 312 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);




      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
        if (!_M_fill_init)
          {
            _M_fill = this->widen(' ');
            _M_fill_init = true;
          }
        return _M_fill;
      }
# 347 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
        char_type __old = this->fill();
        _M_fill = __ch;
        return __old;
      }
# 367 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 387 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const;
# 405 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/basic_ios.h" 3
      char_type
      widen(char __c) const;

    protected:







      basic_ios() : ios_base()
      { }
# 427 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/basic_ios.h" 3
      void
      init(basic_streambuf<_CharT, _Traits>* __sb);

      bool
      _M_check_facet(const locale::facet* __f) const
      {
        if (!__f)
          __throw_bad_cast();
        return true;
      }

      void
      _M_cache_locale(const locale& __loc);



      void
      _M_cache_facets(const locale& __loc);




       void
       _M_setstate(iostate __state) { _M_streambuf_state |= __state; }
    };
}



# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/basic_ios.tcc" 1 3
# 34 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/basic_ios.tcc" 3

namespace std
{
  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
        _M_streambuf_state = __state;
      else
          _M_streambuf_state = __state | badbit;
      if ((this->rdstate() & this->exceptions()))
        __throw_ios_failure("basic_ios::clear(iostate) caused exception");
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {




      _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
        _M_local_word : new _Words[__rhs._M_word_size];


      _Callback_list* __cb = __rhs._M_callbacks;
      if (__cb)
        __cb->_M_add_reference();
      _M_call_callbacks(erase_event);
      if (_M_word != _M_local_word)
        {
          delete [] _M_word;
          _M_word = 0;
        }
      _M_dispose_callbacks();

      _M_callbacks = __cb;
      for (int __i = 0; __i < __rhs._M_word_size; ++__i)
        __words[__i] = __rhs._M_word[__i];
      if (_M_word != _M_local_word)
        {
          delete [] _M_word;
          _M_word = 0;
        }
      _M_word = __words;
      _M_word_size = __rhs._M_word_size;

      this->flags(__rhs.flags());
      this->width(__rhs.width());
      this->precision(__rhs.precision());
      this->tie(__rhs.tie());
      this->fill(__rhs.fill());
      _M_ios_locale = __rhs.getloc();


      _M_call_callbacks(copyfmt_event);

      _M_cache_locale(_M_ios_locale);



      this->exceptions(__rhs.exceptions());

      return *this;
    }

  template<typename _CharT, typename _Traits>
    char
    basic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const
    {
      char __ret = __dfault;
      if (_M_check_facet(_M_fctype))
        __ret = _M_fctype->narrow(__c, __dfault);
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    _CharT
    basic_ios<_CharT, _Traits>::widen(char __c) const
    {
      char_type __ret = char_type();
      if (_M_check_facet(_M_fctype))
        __ret = _M_fctype->widen(__c);
      return __ret;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
        this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();
      _M_cache_locale(_M_ios_locale);
      _M_tie = 0;
# 166 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
        _M_fctype = &use_facet<__ctype_type>(__loc);
      else
        _M_fctype = 0;
      if (__builtin_expect(has_facet<__numput_type>(__loc), true))
        _M_fnumput = &use_facet<__numput_type>(__loc);
      else
        _M_fnumput = 0;
      if (__builtin_expect(has_facet<__numget_type>(__loc), true))
        _M_fnumget = &use_facet<__numget_type>(__loc);
      else
        _M_fnumget = 0;
    }



  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_facets(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
        _M_fctype = &use_facet<__ctype_type>(__loc);
      if (__builtin_expect(has_facet<__numput_type>(__loc), true))
        _M_fnumput = &use_facet<__numput_type>(__loc);
      if (__builtin_expect(has_facet<__numget_type>(__loc), true))
        _M_fnumget = &use_facet<__numget_type>(__loc);
    }






  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;


}
# 457 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/basic_ios.h" 2 3
# 52 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ios" 2 3
# 46 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ostream" 2 3

namespace std
{
# 57 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef ostreambuf_iterator<_CharT, _Traits> __ostreambuf_iter;
      typedef num_put<_CharT, __ostreambuf_iter> __numput_type;
      typedef ctype<_CharT> __ctype_type;

      template<typename _CharT2, typename _Traits2>
        friend basic_ostream<_CharT2, _Traits2>&
        operator<<(basic_ostream<_CharT2, _Traits2>&, _CharT2);

      template<typename _Traits2>
        friend basic_ostream<char, _Traits2>&
        operator<<(basic_ostream<char, _Traits2>&, char);

      template<typename _CharT2, typename _Traits2>
        friend basic_ostream<_CharT2, _Traits2>&
        operator<<(basic_ostream<_CharT2, _Traits2>&, const _CharT2*);

      template<typename _Traits2>
        friend basic_ostream<char, _Traits2>&
        operator<<(basic_ostream<char, _Traits2>&, const char*);

      template<typename _CharT2, typename _Traits2>
        friend basic_ostream<_CharT2, _Traits2>&
        operator<<(basic_ostream<_CharT2, _Traits2>&, const char*);
# 104 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 130 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&));

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&));

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&));
# 167 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ostream" 3
      __ostream_type&
      operator<<(long __n);

      __ostream_type&
      operator<<(unsigned long __n);

      __ostream_type&
      operator<<(bool __n);

      __ostream_type&
      operator<<(short __n)
      {
        ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
        if (__fmt & ios_base::oct || __fmt & ios_base::hex)
          return this->operator<<(static_cast<unsigned long>
                                  (static_cast<unsigned short>(__n)));
        else
          return this->operator<<(static_cast<long>(__n));
      }

      __ostream_type&
      operator<<(unsigned short __n)
      { return this->operator<<(static_cast<unsigned long>(__n)); }

      __ostream_type&
      operator<<(int __n)
      {
        ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
        if (__fmt & ios_base::oct || __fmt & ios_base::hex)
          return this->operator<<(static_cast<unsigned long>
                                  (static_cast<unsigned int>(__n)));
        else
          return this->operator<<(static_cast<long>(__n));
      }

      __ostream_type&
      operator<<(unsigned int __n)
      { return this->operator<<(static_cast<unsigned long>(__n)); }


      __ostream_type&
      operator<<(long long __n);

      __ostream_type&
      operator<<(unsigned long long __n);


      __ostream_type&
      operator<<(double __f);

      __ostream_type&
      operator<<(float __f)
      { return this->operator<<(static_cast<double>(__f)); }

      __ostream_type&
      operator<<(long double __f);

      __ostream_type&
      operator<<(const void* __p);
# 248 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 281 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ostream" 3
      __ostream_type&
      put(char_type __c);
# 300 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 313 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ostream" 3
      __ostream_type&
      flush();
# 324 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ostream" 3
      pos_type
      tellp();
# 335 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 347 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);
    };
# 361 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT,_Traits>& _M_os;

    public:
# 380 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ostream" 3
      explicit
      sentry(basic_ostream<_CharT,_Traits>& __os);
# 390 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ostream" 3
      ~sentry()
      {

        if (_M_os.flags() & ios_base::unitbuf && !uncaught_exception())
          {

            if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
              _M_os.setstate(ios_base::badbit);
          }
      }
# 408 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ostream" 3
      operator bool()
      { return _M_ok; }
    };
# 429 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ostream" 3
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c);

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c);


  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
# 469 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ostream" 3
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s);

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s);


  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
# 503 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ostream" 3
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }







  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }

}





# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/ostream.tcc" 1 3
# 36 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/ostream.tcc" 3

# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/locale" 1 3
# 43 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/locale" 3




# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/locale_facets.tcc" 1 3
# 37 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/locale_facets.tcc" 3

# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cerrno" 1 3
# 47 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cerrno" 3

# 1 "/usr/include/errno.h" 1 3 4
# 32 "/usr/include/errno.h" 3 4
extern "C" {



# 1 "/usr/include/bits/errno.h" 1 3 4
# 25 "/usr/include/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4



# 1 "/usr/include/asm/errno.h" 1 3 4
# 5 "/usr/include/linux/errno.h" 2 3 4
# 26 "/usr/include/bits/errno.h" 2 3 4
# 38 "/usr/include/bits/errno.h" 3 4
extern int *__errno_location (void) throw () __attribute__ ((__const__));
# 37 "/usr/include/errno.h" 2 3 4
# 55 "/usr/include/errno.h" 3 4
extern char *program_invocation_name, *program_invocation_short_name;



}
# 69 "/usr/include/errno.h" 3 4
typedef int error_t;
# 49 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cerrno" 2 3
# 39 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/locale_facets.tcc" 2 3


# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cmath" 1 3
# 48 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cmath" 3



# 1 "/usr/include/math.h" 1 3 4
# 29 "/usr/include/math.h" 3 4
extern "C" {



# 1 "/usr/include/bits/huge_val.h" 1 3 4
# 34 "/usr/include/math.h" 2 3 4

# 1 "/usr/include/bits/huge_valf.h" 1 3 4
# 36 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/bits/huge_vall.h" 1 3 4
# 37 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/inf.h" 1 3 4
# 40 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/nan.h" 1 3 4
# 43 "/usr/include/math.h" 2 3 4



# 1 "/usr/include/bits/mathdef.h" 1 3 4
# 36 "/usr/include/bits/mathdef.h" 3 4
typedef long double float_t;

typedef long double double_t;
# 47 "/usr/include/math.h" 2 3 4
# 70 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4


extern double acos (double __x) throw (); extern double __acos (double __x) throw ();

extern double asin (double __x) throw (); extern double __asin (double __x) throw ();

extern double atan (double __x) throw (); extern double __atan (double __x) throw ();

extern double atan2 (double __y, double __x) throw (); extern double __atan2 (double __y, double __x) throw ();


extern double cos (double __x) throw (); extern double __cos (double __x) throw ();

extern double sin (double __x) throw (); extern double __sin (double __x) throw ();

extern double tan (double __x) throw (); extern double __tan (double __x) throw ();




extern double cosh (double __x) throw (); extern double __cosh (double __x) throw ();

extern double sinh (double __x) throw (); extern double __sinh (double __x) throw ();

extern double tanh (double __x) throw (); extern double __tanh (double __x) throw ();




extern void sincos (double __x, double *__sinx, double *__cosx) throw (); extern void __sincos (double __x, double *__sinx, double *__cosx) throw ();






extern double acosh (double __x) throw (); extern double __acosh (double __x) throw ();

extern double asinh (double __x) throw (); extern double __asinh (double __x) throw ();

extern double atanh (double __x) throw (); extern double __atanh (double __x) throw ();







extern double exp (double __x) throw (); extern double __exp (double __x) throw ();


extern double frexp (double __x, int *__exponent) throw (); extern double __frexp (double __x, int *__exponent) throw ();


extern double ldexp (double __x, int __exponent) throw (); extern double __ldexp (double __x, int __exponent) throw ();


extern double log (double __x) throw (); extern double __log (double __x) throw ();


extern double log10 (double __x) throw (); extern double __log10 (double __x) throw ();


extern double modf (double __x, double *__iptr) throw (); extern double __modf (double __x, double *__iptr) throw ();




extern double exp10 (double __x) throw (); extern double __exp10 (double __x) throw ();

extern double pow10 (double __x) throw (); extern double __pow10 (double __x) throw ();





extern double expm1 (double __x) throw (); extern double __expm1 (double __x) throw ();


extern double log1p (double __x) throw (); extern double __log1p (double __x) throw ();


extern double logb (double __x) throw (); extern double __logb (double __x) throw ();






extern double exp2 (double __x) throw (); extern double __exp2 (double __x) throw ();


extern double log2 (double __x) throw (); extern double __log2 (double __x) throw ();








extern double pow (double __x, double __y) throw (); extern double __pow (double __x, double __y) throw ();


extern double sqrt (double __x) throw (); extern double __sqrt (double __x) throw ();





extern double hypot (double __x, double __y) throw (); extern double __hypot (double __x, double __y) throw ();






extern double cbrt (double __x) throw (); extern double __cbrt (double __x) throw ();








extern double ceil (double __x) throw () __attribute__ ((__const__)); extern double __ceil (double __x) throw () __attribute__ ((__const__));


extern double fabs (double __x) throw () __attribute__ ((__const__)); extern double __fabs (double __x) throw () __attribute__ ((__const__));


extern double floor (double __x) throw () __attribute__ ((__const__)); extern double __floor (double __x) throw () __attribute__ ((__const__));


extern double fmod (double __x, double __y) throw (); extern double __fmod (double __x, double __y) throw ();




extern int __isinf (double __value) throw () __attribute__ ((__const__));


extern int __finite (double __value) throw () __attribute__ ((__const__));





extern int isinf (double __value) throw () __attribute__ ((__const__));


extern int finite (double __value) throw () __attribute__ ((__const__));


extern double drem (double __x, double __y) throw (); extern double __drem (double __x, double __y) throw ();



extern double significand (double __x) throw (); extern double __significand (double __x) throw ();





extern double copysign (double __x, double __y) throw () __attribute__ ((__const__)); extern double __copysign (double __x, double __y) throw () __attribute__ ((__const__));






extern double nan (__const char *__tagb) throw () __attribute__ ((__const__)); extern double __nan (__const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnan (double __value) throw () __attribute__ ((__const__));



extern int isnan (double __value) throw () __attribute__ ((__const__));


extern double j0 (double) throw (); extern double __j0 (double) throw ();
extern double j1 (double) throw (); extern double __j1 (double) throw ();
extern double jn (int, double) throw (); extern double __jn (int, double) throw ();
extern double y0 (double) throw (); extern double __y0 (double) throw ();
extern double y1 (double) throw (); extern double __y1 (double) throw ();
extern double yn (int, double) throw (); extern double __yn (int, double) throw ();






extern double erf (double) throw (); extern double __erf (double) throw ();
extern double erfc (double) throw (); extern double __erfc (double) throw ();
extern double lgamma (double) throw (); extern double __lgamma (double) throw ();






extern double tgamma (double) throw (); extern double __tgamma (double) throw ();





extern double gamma (double) throw (); extern double __gamma (double) throw ();






extern double lgamma_r (double, int *__signgamp) throw (); extern double __lgamma_r (double, int *__signgamp) throw ();







extern double rint (double __x) throw (); extern double __rint (double __x) throw ();


extern double nextafter (double __x, double __y) throw () __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) throw () __attribute__ ((__const__));

extern double nexttoward (double __x, long double __y) throw () __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) throw () __attribute__ ((__const__));



extern double remainder (double __x, double __y) throw (); extern double __remainder (double __x, double __y) throw ();



extern double scalbn (double __x, int __n) throw (); extern double __scalbn (double __x, int __n) throw ();



extern int ilogb (double __x) throw (); extern int __ilogb (double __x) throw ();




extern double scalbln (double __x, long int __n) throw (); extern double __scalbln (double __x, long int __n) throw ();



extern double nearbyint (double __x) throw (); extern double __nearbyint (double __x) throw ();



extern double round (double __x) throw () __attribute__ ((__const__)); extern double __round (double __x) throw () __attribute__ ((__const__));



extern double trunc (double __x) throw () __attribute__ ((__const__)); extern double __trunc (double __x) throw () __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) throw (); extern double __remquo (double __x, double __y, int *__quo) throw ();






extern long int lrint (double __x) throw (); extern long int __lrint (double __x) throw ();
extern long long int llrint (double __x) throw (); extern long long int __llrint (double __x) throw ();



extern long int lround (double __x) throw (); extern long int __lround (double __x) throw ();
extern long long int llround (double __x) throw (); extern long long int __llround (double __x) throw ();



extern double fdim (double __x, double __y) throw (); extern double __fdim (double __x, double __y) throw ();


extern double fmax (double __x, double __y) throw (); extern double __fmax (double __x, double __y) throw ();


extern double fmin (double __x, double __y) throw (); extern double __fmin (double __x, double __y) throw ();



extern int __fpclassify (double __value) throw ()
     __attribute__ ((__const__));


extern int __signbit (double __value) throw ()
     __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) throw (); extern double __fma (double __x, double __y, double __z) throw ();








extern double scalb (double __x, double __n) throw (); extern double __scalb (double __x, double __n) throw ();
# 71 "/usr/include/math.h" 2 3 4
# 93 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4


extern float acosf (float __x) throw (); extern float __acosf (float __x) throw ();

extern float asinf (float __x) throw (); extern float __asinf (float __x) throw ();

extern float atanf (float __x) throw (); extern float __atanf (float __x) throw ();

extern float atan2f (float __y, float __x) throw (); extern float __atan2f (float __y, float __x) throw ();


extern float cosf (float __x) throw (); extern float __cosf (float __x) throw ();

extern float sinf (float __x) throw (); extern float __sinf (float __x) throw ();

extern float tanf (float __x) throw (); extern float __tanf (float __x) throw ();




extern float coshf (float __x) throw (); extern float __coshf (float __x) throw ();

extern float sinhf (float __x) throw (); extern float __sinhf (float __x) throw ();

extern float tanhf (float __x) throw (); extern float __tanhf (float __x) throw ();




extern void sincosf (float __x, float *__sinx, float *__cosx) throw (); extern void __sincosf (float __x, float *__sinx, float *__cosx) throw ();






extern float acoshf (float __x) throw (); extern float __acoshf (float __x) throw ();

extern float asinhf (float __x) throw (); extern float __asinhf (float __x) throw ();

extern float atanhf (float __x) throw (); extern float __atanhf (float __x) throw ();







extern float expf (float __x) throw (); extern float __expf (float __x) throw ();


extern float frexpf (float __x, int *__exponent) throw (); extern float __frexpf (float __x, int *__exponent) throw ();


extern float ldexpf (float __x, int __exponent) throw (); extern float __ldexpf (float __x, int __exponent) throw ();


extern float logf (float __x) throw (); extern float __logf (float __x) throw ();


extern float log10f (float __x) throw (); extern float __log10f (float __x) throw ();


extern float modff (float __x, float *__iptr) throw (); extern float __modff (float __x, float *__iptr) throw ();




extern float exp10f (float __x) throw (); extern float __exp10f (float __x) throw ();

extern float pow10f (float __x) throw (); extern float __pow10f (float __x) throw ();





extern float expm1f (float __x) throw (); extern float __expm1f (float __x) throw ();


extern float log1pf (float __x) throw (); extern float __log1pf (float __x) throw ();


extern float logbf (float __x) throw (); extern float __logbf (float __x) throw ();






extern float exp2f (float __x) throw (); extern float __exp2f (float __x) throw ();


extern float log2f (float __x) throw (); extern float __log2f (float __x) throw ();








extern float powf (float __x, float __y) throw (); extern float __powf (float __x, float __y) throw ();


extern float sqrtf (float __x) throw (); extern float __sqrtf (float __x) throw ();





extern float hypotf (float __x, float __y) throw (); extern float __hypotf (float __x, float __y) throw ();






extern float cbrtf (float __x) throw (); extern float __cbrtf (float __x) throw ();








extern float ceilf (float __x) throw () __attribute__ ((__const__)); extern float __ceilf (float __x) throw () __attribute__ ((__const__));


extern float fabsf (float __x) throw () __attribute__ ((__const__)); extern float __fabsf (float __x) throw () __attribute__ ((__const__));


extern float floorf (float __x) throw () __attribute__ ((__const__)); extern float __floorf (float __x) throw () __attribute__ ((__const__));


extern float fmodf (float __x, float __y) throw (); extern float __fmodf (float __x, float __y) throw ();




extern int __isinff (float __value) throw () __attribute__ ((__const__));


extern int __finitef (float __value) throw () __attribute__ ((__const__));





extern int isinff (float __value) throw () __attribute__ ((__const__));


extern int finitef (float __value) throw () __attribute__ ((__const__));


extern float dremf (float __x, float __y) throw (); extern float __dremf (float __x, float __y) throw ();



extern float significandf (float __x) throw (); extern float __significandf (float __x) throw ();





extern float copysignf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) throw () __attribute__ ((__const__));






extern float nanf (__const char *__tagb) throw () __attribute__ ((__const__)); extern float __nanf (__const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanf (float __value) throw () __attribute__ ((__const__));



extern int isnanf (float __value) throw () __attribute__ ((__const__));


extern float j0f (float) throw (); extern float __j0f (float) throw ();
extern float j1f (float) throw (); extern float __j1f (float) throw ();
extern float jnf (int, float) throw (); extern float __jnf (int, float) throw ();
extern float y0f (float) throw (); extern float __y0f (float) throw ();
extern float y1f (float) throw (); extern float __y1f (float) throw ();
extern float ynf (int, float) throw (); extern float __ynf (int, float) throw ();






extern float erff (float) throw (); extern float __erff (float) throw ();
extern float erfcf (float) throw (); extern float __erfcf (float) throw ();
extern float lgammaf (float) throw (); extern float __lgammaf (float) throw ();






extern float tgammaf (float) throw (); extern float __tgammaf (float) throw ();





extern float gammaf (float) throw (); extern float __gammaf (float) throw ();






extern float lgammaf_r (float, int *__signgamp) throw (); extern float __lgammaf_r (float, int *__signgamp) throw ();







extern float rintf (float __x) throw (); extern float __rintf (float __x) throw ();


extern float nextafterf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) throw () __attribute__ ((__const__));

extern float nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__));



extern float remainderf (float __x, float __y) throw (); extern float __remainderf (float __x, float __y) throw ();



extern float scalbnf (float __x, int __n) throw (); extern float __scalbnf (float __x, int __n) throw ();



extern int ilogbf (float __x) throw (); extern int __ilogbf (float __x) throw ();




extern float scalblnf (float __x, long int __n) throw (); extern float __scalblnf (float __x, long int __n) throw ();



extern float nearbyintf (float __x) throw (); extern float __nearbyintf (float __x) throw ();



extern float roundf (float __x) throw () __attribute__ ((__const__)); extern float __roundf (float __x) throw () __attribute__ ((__const__));



extern float truncf (float __x) throw () __attribute__ ((__const__)); extern float __truncf (float __x) throw () __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) throw (); extern float __remquof (float __x, float __y, int *__quo) throw ();






extern long int lrintf (float __x) throw (); extern long int __lrintf (float __x) throw ();
extern long long int llrintf (float __x) throw (); extern long long int __llrintf (float __x) throw ();



extern long int lroundf (float __x) throw (); extern long int __lroundf (float __x) throw ();
extern long long int llroundf (float __x) throw (); extern long long int __llroundf (float __x) throw ();



extern float fdimf (float __x, float __y) throw (); extern float __fdimf (float __x, float __y) throw ();


extern float fmaxf (float __x, float __y) throw (); extern float __fmaxf (float __x, float __y) throw ();


extern float fminf (float __x, float __y) throw (); extern float __fminf (float __x, float __y) throw ();



extern int __fpclassifyf (float __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf (float __value) throw ()
     __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) throw (); extern float __fmaf (float __x, float __y, float __z) throw ();








extern float scalbf (float __x, float __n) throw (); extern float __scalbf (float __x, float __n) throw ();
# 94 "/usr/include/math.h" 2 3 4
# 114 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4


extern long double acosl (long double __x) throw (); extern long double __acosl (long double __x) throw ();

extern long double asinl (long double __x) throw (); extern long double __asinl (long double __x) throw ();

extern long double atanl (long double __x) throw (); extern long double __atanl (long double __x) throw ();

extern long double atan2l (long double __y, long double __x) throw (); extern long double __atan2l (long double __y, long double __x) throw ();


extern long double cosl (long double __x) throw (); extern long double __cosl (long double __x) throw ();

extern long double sinl (long double __x) throw (); extern long double __sinl (long double __x) throw ();

extern long double tanl (long double __x) throw (); extern long double __tanl (long double __x) throw ();




extern long double coshl (long double __x) throw (); extern long double __coshl (long double __x) throw ();

extern long double sinhl (long double __x) throw (); extern long double __sinhl (long double __x) throw ();

extern long double tanhl (long double __x) throw (); extern long double __tanhl (long double __x) throw ();




extern void sincosl (long double __x, long double *__sinx, long double *__cosx) throw (); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) throw ();






extern long double acoshl (long double __x) throw (); extern long double __acoshl (long double __x) throw ();

extern long double asinhl (long double __x) throw (); extern long double __asinhl (long double __x) throw ();

extern long double atanhl (long double __x) throw (); extern long double __atanhl (long double __x) throw ();







extern long double expl (long double __x) throw (); extern long double __expl (long double __x) throw ();


extern long double frexpl (long double __x, int *__exponent) throw (); extern long double __frexpl (long double __x, int *__exponent) throw ();


extern long double ldexpl (long double __x, int __exponent) throw (); extern long double __ldexpl (long double __x, int __exponent) throw ();


extern long double logl (long double __x) throw (); extern long double __logl (long double __x) throw ();


extern long double log10l (long double __x) throw (); extern long double __log10l (long double __x) throw ();


extern long double modfl (long double __x, long double *__iptr) throw (); extern long double __modfl (long double __x, long double *__iptr) throw ();




extern long double exp10l (long double __x) throw (); extern long double __exp10l (long double __x) throw ();

extern long double pow10l (long double __x) throw (); extern long double __pow10l (long double __x) throw ();





extern long double expm1l (long double __x) throw (); extern long double __expm1l (long double __x) throw ();


extern long double log1pl (long double __x) throw (); extern long double __log1pl (long double __x) throw ();


extern long double logbl (long double __x) throw (); extern long double __logbl (long double __x) throw ();






extern long double exp2l (long double __x) throw (); extern long double __exp2l (long double __x) throw ();


extern long double log2l (long double __x) throw (); extern long double __log2l (long double __x) throw ();








extern long double powl (long double __x, long double __y) throw (); extern long double __powl (long double __x, long double __y) throw ();


extern long double sqrtl (long double __x) throw (); extern long double __sqrtl (long double __x) throw ();





extern long double hypotl (long double __x, long double __y) throw (); extern long double __hypotl (long double __x, long double __y) throw ();






extern long double cbrtl (long double __x) throw (); extern long double __cbrtl (long double __x) throw ();








extern long double ceill (long double __x) throw () __attribute__ ((__const__)); extern long double __ceill (long double __x) throw () __attribute__ ((__const__));


extern long double fabsl (long double __x) throw () __attribute__ ((__const__)); extern long double __fabsl (long double __x) throw () __attribute__ ((__const__));


extern long double floorl (long double __x) throw () __attribute__ ((__const__)); extern long double __floorl (long double __x) throw () __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) throw (); extern long double __fmodl (long double __x, long double __y) throw ();




extern int __isinfl (long double __value) throw () __attribute__ ((__const__));


extern int __finitel (long double __value) throw () __attribute__ ((__const__));





extern int isinfl (long double __value) throw () __attribute__ ((__const__));


extern int finitel (long double __value) throw () __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) throw (); extern long double __dreml (long double __x, long double __y) throw ();



extern long double significandl (long double __x) throw (); extern long double __significandl (long double __x) throw ();





extern long double copysignl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) throw () __attribute__ ((__const__));






extern long double nanl (__const char *__tagb) throw () __attribute__ ((__const__)); extern long double __nanl (__const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanl (long double __value) throw () __attribute__ ((__const__));



extern int isnanl (long double __value) throw () __attribute__ ((__const__));


extern long double j0l (long double) throw (); extern long double __j0l (long double) throw ();
extern long double j1l (long double) throw (); extern long double __j1l (long double) throw ();
extern long double jnl (int, long double) throw (); extern long double __jnl (int, long double) throw ();
extern long double y0l (long double) throw (); extern long double __y0l (long double) throw ();
extern long double y1l (long double) throw (); extern long double __y1l (long double) throw ();
extern long double ynl (int, long double) throw (); extern long double __ynl (int, long double) throw ();






extern long double erfl (long double) throw (); extern long double __erfl (long double) throw ();
extern long double erfcl (long double) throw (); extern long double __erfcl (long double) throw ();
extern long double lgammal (long double) throw (); extern long double __lgammal (long double) throw ();






extern long double tgammal (long double) throw (); extern long double __tgammal (long double) throw ();





extern long double gammal (long double) throw (); extern long double __gammal (long double) throw ();






extern long double lgammal_r (long double, int *__signgamp) throw (); extern long double __lgammal_r (long double, int *__signgamp) throw ();







extern long double rintl (long double __x) throw (); extern long double __rintl (long double __x) throw ();


extern long double nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__));

extern long double nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__));



extern long double remainderl (long double __x, long double __y) throw (); extern long double __remainderl (long double __x, long double __y) throw ();



extern long double scalbnl (long double __x, int __n) throw (); extern long double __scalbnl (long double __x, int __n) throw ();



extern int ilogbl (long double __x) throw (); extern int __ilogbl (long double __x) throw ();




extern long double scalblnl (long double __x, long int __n) throw (); extern long double __scalblnl (long double __x, long int __n) throw ();



extern long double nearbyintl (long double __x) throw (); extern long double __nearbyintl (long double __x) throw ();



extern long double roundl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundl (long double __x) throw () __attribute__ ((__const__));



extern long double truncl (long double __x) throw () __attribute__ ((__const__)); extern long double __truncl (long double __x) throw () __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) throw (); extern long double __remquol (long double __x, long double __y, int *__quo) throw ();






extern long int lrintl (long double __x) throw (); extern long int __lrintl (long double __x) throw ();
extern long long int llrintl (long double __x) throw (); extern long long int __llrintl (long double __x) throw ();



extern long int lroundl (long double __x) throw (); extern long int __lroundl (long double __x) throw ();
extern long long int llroundl (long double __x) throw (); extern long long int __llroundl (long double __x) throw ();



extern long double fdiml (long double __x, long double __y) throw (); extern long double __fdiml (long double __x, long double __y) throw ();


extern long double fmaxl (long double __x, long double __y) throw (); extern long double __fmaxl (long double __x, long double __y) throw ();


extern long double fminl (long double __x, long double __y) throw (); extern long double __fminl (long double __x, long double __y) throw ();



extern int __fpclassifyl (long double __value) throw ()
     __attribute__ ((__const__));


extern int __signbitl (long double __value) throw ()
     __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) throw (); extern long double __fmal (long double __x, long double __y, long double __z) throw ();








extern long double scalbl (long double __x, long double __n) throw (); extern long double __scalbl (long double __x, long double __n) throw ();
# 115 "/usr/include/math.h" 2 3 4
# 130 "/usr/include/math.h" 3 4
extern int signgam;
# 171 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN,

    FP_INFINITE,

    FP_ZERO,

    FP_SUBNORMAL,

    FP_NORMAL

  };
# 257 "/usr/include/math.h" 3 4
typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;




extern _LIB_VERSION_TYPE _LIB_VERSION;
# 280 "/usr/include/math.h" 3 4
struct __exception



  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };


extern int matherr (struct __exception *__exc) throw ();
# 438 "/usr/include/math.h" 3 4
}
# 52 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cmath" 2 3
# 80 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cmath" 3
namespace __gnu_cxx
{
  namespace __c99_binding
  {
# 107 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cmath" 3
    using ::acosf;


    using ::asinf;


    using ::atanf;


    using ::atan2f;


    using ::ceilf;


    using ::coshf;


    using ::expf;


    using ::floorf;


    using ::fmodf;


    using ::frexpf;


    using ::ldexpf;


    using ::logf;


    using ::log10f;


    using ::modff;


    using ::powf;


    using ::sinhf;


    using ::tanf;


    using ::tanhf;


  }
}

namespace std
{


  template<typename _Tp> _Tp __cmath_power(_Tp, unsigned int);

  inline double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }


  inline float
  acos(float __x) { return __gnu_cxx::__c99_binding::acosf(__x); }





  using ::acos;


  inline long double
  acos(long double __x) { return ::acosl(__x); }





  using ::asin;


  inline float
  asin(float __x) { return __gnu_cxx::__c99_binding::asinf(__x); }






  inline long double
  asin(long double __x) { return ::asinl(__x); }





  using ::atan;


  inline float
  atan(float __x) { return __gnu_cxx::__c99_binding::atanf(__x); }






  inline long double
  atan(long double __x) { return ::atanl(__x); }





  using ::atan2;


  inline float
  atan2(float __y, float __x) { return __gnu_cxx::__c99_binding::atan2f(__y, __x); }







  inline long double
  atan2(long double __y, long double __x) { return ::atan2l(__y, __x); }






  using ::ceil;


  inline float
  ceil(float __x) { return __gnu_cxx::__c99_binding::ceilf(__x); }






  inline long double
  ceil(long double __x) { return ::ceill(__x); }





  using ::cos;

  inline float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline long double
  cos(long double __x)
  { return __builtin_cosl(__x); }

  using ::cosh;


  inline float
  cosh(float __x) { return __gnu_cxx::__c99_binding::coshf(__x); }






  inline long double
  cosh(long double __x) { return ::coshl(__x); }





  using ::exp;


  inline float
  exp(float __x) { return __gnu_cxx::__c99_binding::expf(__x); }






  inline long double
  exp(long double __x) { return ::expl(__x); }





  using ::fabs;

  inline float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }

  using ::floor;


  inline float
  floor(float __x) { return __gnu_cxx::__c99_binding::floorf(__x); }






  inline long double
  floor(long double __x) { return ::floorl(__x); }





  using ::fmod;


  inline float
  fmod(float __x, float __y) { return __gnu_cxx::__c99_binding::fmodf(__x, __y); }







  inline long double
  fmod(long double __x, long double __y) { return ::fmodl(__x, __y); }






  using ::frexp;


  inline float
  frexp(float __x, int* __exp) { return __gnu_cxx::__c99_binding::frexpf(__x, __exp); }






  inline long double
  frexp(long double __x, int* __exp) { return ::frexpl(__x, __exp); }






  using ::ldexp;


  inline float
  ldexp(float __x, int __exp) { return __gnu_cxx::__c99_binding::ldexpf(__x, __exp); }







  inline long double
  ldexp(long double __x, int __exp) { return ::ldexpl(__x, __exp); }






  using ::log;


  inline float
  log(float __x) { return __gnu_cxx::__c99_binding::logf(__x); }






  inline long double
  log(long double __x) { return ::logl(__x); }





  using ::log10;


  inline float
  log10(float __x) { return __gnu_cxx::__c99_binding::log10f(__x); }






  inline long double
  log10(long double __x) { return ::log10l(__x); }





  using ::modf;


  inline float
  modf(float __x, float* __iptr) { return __gnu_cxx::__c99_binding::modff(__x, __iptr); }
# 460 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cmath" 3
  inline long double
  modf(long double __x, long double* __iptr) { return ::modfl(__x, __iptr); }
# 473 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cmath" 3
  template<typename _Tp>
    inline _Tp
    __pow_helper(_Tp __x, int __n)
    {
      return __n < 0
        ? _Tp(1)/__cmath_power(__x, -__n)
        : __cmath_power(__x, __n);
    }

  using ::pow;


  inline float
  pow(float __x, float __y) { return __gnu_cxx::__c99_binding::powf(__x, __y); }







  inline long double
  pow(long double __x, long double __y) { return ::powl(__x, __y); }






  inline double
  pow(double __x, int __i)
  { return __pow_helper(__x, __i); }

  inline float
  pow(float __x, int __n)
  { return __pow_helper(__x, __n); }

  inline long double
  pow(long double __x, int __n)
  { return __pow_helper(__x, __n); }

  using ::sin;

  inline float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline long double
  sin(long double __x)
  { return __builtin_sinl(__x); }

  using ::sinh;


  inline float
  sinh(float __x) { return __gnu_cxx::__c99_binding::sinhf(__x); }






  inline long double
  sinh(long double __x) { return ::sinhl(__x); }





  using ::sqrt;

  inline float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }

  using ::tan;


  inline float
  tan(float __x) { return __gnu_cxx::__c99_binding::tanf(__x); }






  inline long double
  tan(long double __x) { return ::tanl(__x); }





  using ::tanh;


  inline float
  tanh(float __x) { return __gnu_cxx::__c99_binding::tanhf(__x); }






  inline long double
  tanh(long double __x) { return ::tanhl(__x); }




}







namespace __gnu_cxx
{
  template<typename _Tp>
    int
    __capture_fpclassify(_Tp __f) { return (sizeof (__f) == sizeof (float) ? __fpclassifyf (__f) : sizeof (__f) == sizeof (double) ? __fpclassify (__f) : __fpclassifyl (__f)); }

  template<typename _Tp>
    int
    __capture_isfinite(_Tp __f) { return (sizeof (__f) == sizeof (float) ? __finitef (__f) : sizeof (__f) == sizeof (double) ? __finite (__f) : __finitel (__f)); }

  template<typename _Tp>
    int
    __capture_isinf(_Tp __f) { return (sizeof (__f) == sizeof (float) ? __isinff (__f) : sizeof (__f) == sizeof (double) ? __isinf (__f) : __isinfl (__f)); }

  template<typename _Tp>
    int
    __capture_isnan(_Tp __f) { return (sizeof (__f) == sizeof (float) ? __isnanf (__f) : sizeof (__f) == sizeof (double) ? __isnan (__f) : __isnanl (__f)); }

  template<typename _Tp>
    int
    __capture_isnormal(_Tp __f) { return ((sizeof (__f) == sizeof (float) ? __fpclassifyf (__f) : sizeof (__f) == sizeof (double) ? __fpclassify (__f) : __fpclassifyl (__f)) == FP_NORMAL); }

  template<typename _Tp>
    int
    __capture_signbit(_Tp __f) { return (sizeof (__f) == sizeof (float) ? __signbitf (__f) : sizeof (__f) == sizeof (double) ? __signbit (__f) : __signbitl (__f)); }

  template<typename _Tp>
    int
    __capture_isgreater(_Tp __f1, _Tp __f2)
    { return __builtin_isgreater(__f1, __f2); }

  template<typename _Tp>
     int
     __capture_isgreaterequal(_Tp __f1, _Tp __f2)
     { return __builtin_isgreaterequal(__f1, __f2); }

  template<typename _Tp>
     int
     __capture_isless(_Tp __f1, _Tp __f2) { return __builtin_isless(__f1, __f2); }

  template<typename _Tp>
     int
     __capture_islessequal(_Tp __f1, _Tp __f2)
     { return __builtin_islessequal(__f1, __f2); }

  template<typename _Tp>
     int
     __capture_islessgreater(_Tp __f1, _Tp __f2)
     { return __builtin_islessgreater(__f1, __f2); }

  template<typename _Tp>
     int
     __capture_isunordered(_Tp __f1, _Tp __f2)
     { return __builtin_isunordered(__f1, __f2); }
}
# 668 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cmath" 3
namespace __gnu_cxx
{
  template<typename _Tp>
    int
    fpclassify(_Tp __f) { return __capture_fpclassify(__f); }

  template<typename _Tp>
    int
    isfinite(_Tp __f) { return __capture_isfinite(__f); }

  template<typename _Tp>
    int
    isinf(_Tp __f) { return __capture_isinf(__f); }

  template<typename _Tp>
    int
    isnan(_Tp __f) { return __capture_isnan(__f); }

  template<typename _Tp>
    int
    isnormal(_Tp __f) { return __capture_isnormal(__f); }

  template<typename _Tp>
    int
    signbit(_Tp __f) { return __capture_signbit(__f); }

  template<typename _Tp>
    int
    isgreater(_Tp __f1, _Tp __f2) { return __capture_isgreater(__f1, __f2); }

  template<typename _Tp>
    int
    isgreaterequal(_Tp __f1, _Tp __f2)
    { return __capture_isgreaterequal(__f1, __f2); }

  template<typename _Tp>
    int
    isless(_Tp __f1, _Tp __f2) { return __capture_isless(__f1, __f2); }

  template<typename _Tp>
    int
    islessequal(_Tp __f1, _Tp __f2)
    { return __capture_islessequal(__f1, __f2); }

  template<typename _Tp>
    int
    islessgreater(_Tp __f1, _Tp __f2)
    { return __capture_islessgreater(__f1, __f2); }

  template<typename _Tp>
    int
    isunordered(_Tp __f1, _Tp __f2)
    { return __capture_isunordered(__f1, __f2); }
}

namespace std
{
  using __gnu_cxx::fpclassify;
  using __gnu_cxx::isfinite;
  using __gnu_cxx::isinf;
  using __gnu_cxx::isnan;
  using __gnu_cxx::isnormal;
  using __gnu_cxx::signbit;
  using __gnu_cxx::isgreater;
  using __gnu_cxx::isgreaterequal;
  using __gnu_cxx::isless;
  using __gnu_cxx::islessequal;
  using __gnu_cxx::islessgreater;
  using __gnu_cxx::isunordered;
}





# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/cmath.tcc" 1 3
# 35 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/cmath.tcc" 3
namespace std
{
  template<typename _Tp>
    _Tp
    __cmath_power(_Tp __x, unsigned int __n)
    {
      _Tp __y = __n % 2 ? __x : 1;

      while (__n >>= 1)
        {
          __x = __x * __x;
          if (__n % 2)
            __y = __y * __x;
        }

      return __y;
    }
}
# 744 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/cmath" 2 3
# 42 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/locale_facets.tcc" 2 3

# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/limits" 1 3
# 47 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/limits" 3
# 150 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/limits" 3
namespace std
{
  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };

  enum float_denorm_style
  {
    denorm_indeterminate = -1,
    denorm_absent = 0,
    denorm_present = 1
  };




  struct __numeric_limits_base
  {
    static const bool is_specialized = false;

    static const int digits = 0;
    static const int digits10 = 0;
    static const bool is_signed = false;
    static const bool is_integer = false;
    static const bool is_exact = false;
    static const int radix = 0;

    static const int min_exponent = 0;
    static const int min_exponent10 = 0;
    static const int max_exponent = 0;
    static const int max_exponent10 = 0;

    static const bool has_infinity = false;
    static const bool has_quiet_NaN = false;
    static const bool has_signaling_NaN = false;
    static const float_denorm_style has_denorm = denorm_absent;
    static const bool has_denorm_loss = false;

    static const bool is_iec559 = false;
    static const bool is_bounded = false;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_toward_zero;
  };

  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {
      static _Tp min() throw() { return static_cast<_Tp>(0); }
      static _Tp max() throw() { return static_cast<_Tp>(0); }
      static _Tp epsilon() throw() { return static_cast<_Tp>(0); }
      static _Tp round_error() throw() { return static_cast<_Tp>(0); }
      static _Tp infinity() throw() { return static_cast<_Tp>(0); }
      static _Tp quiet_NaN() throw() { return static_cast<_Tp>(0); }
      static _Tp signaling_NaN() throw() { return static_cast<_Tp>(0); }
      static _Tp denorm_min() throw() { return static_cast<_Tp>(0); }
    };



  template<>
    struct numeric_limits<bool>
    {
      static const bool is_specialized = true;

      static bool min() throw()
      { return false; }
      static bool max() throw()
      { return true; }

      static const int digits = 1;
      static const int digits10 = 0;
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static bool epsilon() throw()
      { return false; }
      static bool round_error() throw()
      { return false; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static bool infinity() throw()
      { return false; }
      static bool quiet_NaN() throw()
      { return false; }
      static bool signaling_NaN() throw()
      { return false; }
      static bool denorm_min() throw()
      { return false; }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;




      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<char>
    {
      static const bool is_specialized = true;

      static char min() throw()
      { return (((char)(-1) < 0) ? (char)1 << (sizeof(char) * 8 - ((char)(-1) < 0)) : (char)0); }
      static char max() throw()
      { return (((char)(-1) < 0) ? ((char)1 << (sizeof(char) * 8 - ((char)(-1) < 0))) - 1 : ~(char)0); }

      static const int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static const int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = ((char)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static char epsilon() throw()
      { return 0; }
      static char round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static char infinity() throw()
      { return char(); }
      static char quiet_NaN() throw()
      { return char(); }
      static char signaling_NaN() throw()
      { return char(); }
      static char denorm_min() throw()
      { return static_cast<char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<signed char>
    {
      static const bool is_specialized = true;

      static signed char min() throw()
      { return -127 - 1; }
      static signed char max() throw()
      { return 127; }

      static const int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static const int digits10 = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static signed char epsilon() throw()
      { return 0; }
      static signed char round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static signed char infinity() throw()
      { return static_cast<signed char>(0); }
      static signed char quiet_NaN() throw()
      { return static_cast<signed char>(0); }
      static signed char signaling_NaN() throw()
      { return static_cast<signed char>(0); }
      static signed char denorm_min() throw()
      { return static_cast<signed char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<unsigned char>
    {
      static const bool is_specialized = true;

      static unsigned char min() throw()
      { return 0; }
      static unsigned char max() throw()
      { return 127 * 2U + 1; }

      static const int digits = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned char epsilon() throw()
      { return 0; }
      static unsigned char round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned char infinity() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char quiet_NaN() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char signaling_NaN() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char denorm_min() throw()
      { return static_cast<unsigned char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<wchar_t>
    {
      static const bool is_specialized = true;

      static wchar_t min() throw()
      { return (((wchar_t)(-1) < 0) ? (wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) : (wchar_t)0); }
      static wchar_t max() throw()
      { return (((wchar_t)(-1) < 0) ? ((wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0))) - 1 : ~(wchar_t)0); }

      static const int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static const int digits10 = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = ((wchar_t)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static wchar_t epsilon() throw()
      { return 0; }
      static wchar_t round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static wchar_t infinity() throw()
      { return wchar_t(); }
      static wchar_t quiet_NaN() throw()
      { return wchar_t(); }
      static wchar_t signaling_NaN() throw()
      { return wchar_t(); }
      static wchar_t denorm_min() throw()
      { return wchar_t(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<short>
    {
      static const bool is_specialized = true;

      static short min() throw()
      { return -32767 - 1; }
      static short max() throw()
      { return 32767; }

      static const int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static const int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static short epsilon() throw()
      { return 0; }
      static short round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static short infinity() throw()
      { return short(); }
      static short quiet_NaN() throw()
      { return short(); }
      static short signaling_NaN() throw()
      { return short(); }
      static short denorm_min() throw()
      { return short(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<unsigned short>
    {
      static const bool is_specialized = true;

      static unsigned short min() throw()
      { return 0; }
      static unsigned short max() throw()
      { return 32767 * 2U + 1; }

      static const int digits = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned short epsilon() throw()
      { return 0; }
      static unsigned short round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned short infinity() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short quiet_NaN() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short signaling_NaN() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short denorm_min() throw()
      { return static_cast<unsigned short>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<int>
    {
      static const bool is_specialized = true;

      static int min() throw()
      { return -2147483647 - 1; }
      static int max() throw()
      { return 2147483647; }

      static const int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static const int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static int epsilon() throw()
      { return 0; }
      static int round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static int infinity() throw()
      { return static_cast<int>(0); }
      static int quiet_NaN() throw()
      { return static_cast<int>(0); }
      static int signaling_NaN() throw()
      { return static_cast<int>(0); }
      static int denorm_min() throw()
      { return static_cast<int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<unsigned int>
    {
      static const bool is_specialized = true;

      static unsigned int min() throw()
      { return 0; }
      static unsigned int max() throw()
      { return 2147483647 * 2U + 1; }

      static const int digits = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned int epsilon() throw()
      { return 0; }
      static unsigned int round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned int infinity() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int quiet_NaN() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int signaling_NaN() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int denorm_min() throw()
      { return static_cast<unsigned int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<long>
    {
      static const bool is_specialized = true;

      static long min() throw()
      { return -2147483647L - 1; }
      static long max() throw()
      { return 2147483647L; }

      static const int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static const int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static long epsilon() throw()
      { return 0; }
      static long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static long infinity() throw()
      { return static_cast<long>(0); }
      static long quiet_NaN() throw()
      { return static_cast<long>(0); }
      static long signaling_NaN() throw()
      { return static_cast<long>(0); }
      static long denorm_min() throw()
      { return static_cast<long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<unsigned long>
    {
      static const bool is_specialized = true;

      static unsigned long min() throw()
      { return 0; }
      static unsigned long max() throw()
      { return 2147483647L * 2UL + 1; }

      static const int digits = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned long epsilon() throw()
      { return 0; }
      static unsigned long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long infinity() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long quiet_NaN() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long signaling_NaN() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long denorm_min() throw()
      { return static_cast<unsigned long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<long long>
    {
      static const bool is_specialized = true;

      static long long min() throw()
      { return -9223372036854775807LL - 1; }
      static long long max() throw()
      { return 9223372036854775807LL; }

      static const int digits = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static const int digits10 = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static long long epsilon() throw()
      { return 0; }
      static long long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static long long infinity() throw()
      { return static_cast<long long>(0); }
      static long long quiet_NaN() throw()
      { return static_cast<long long>(0); }
      static long long signaling_NaN() throw()
      { return static_cast<long long>(0); }
      static long long denorm_min() throw()
      { return static_cast<long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<unsigned long long>
    {
      static const bool is_specialized = true;

      static unsigned long long min() throw()
      { return 0; }
      static unsigned long long max() throw()
      { return 9223372036854775807LL * 2ULL + 1; }

      static const int digits = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned long long epsilon() throw()
      { return 0; }
      static unsigned long long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long long infinity() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long quiet_NaN() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long signaling_NaN() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long denorm_min() throw()
      { return static_cast<unsigned long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };

  template<>
    struct numeric_limits<float>
    {
      static const bool is_specialized = true;

      static float min() throw()
      { return 1.17549435e-38F; }
      static float max() throw()
      { return 3.40282347e+38F; }

      static const int digits = 24;
      static const int digits10 = 6;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static float epsilon() throw()
      { return 1.19209290e-7F; }
      static float round_error() throw()
      { return 0.5F; }

      static const int min_exponent = (-125);
      static const int min_exponent10 = (-37);
      static const int max_exponent = 128;
      static const int max_exponent10 = 38;

      static const bool has_infinity
        = __builtin_huge_valf () / 2 == __builtin_huge_valf ();
      static const bool has_quiet_NaN
        = __builtin_nanf ("") != __builtin_nanf ("");
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
        = 1.40129846e-45F ? denorm_present : denorm_absent;
      static const bool has_denorm_loss = false;

      static float infinity() throw()
      { return __builtin_huge_valf (); }
      static float quiet_NaN() throw()
      { return __builtin_nanf (""); }
      static float signaling_NaN() throw()
      { return __builtin_nansf (""); }
      static float denorm_min() throw()
      { return 1.40129846e-45F; }

      static const bool is_iec559
        = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };





  template<>
    struct numeric_limits<double>
    {
      static const bool is_specialized = true;

      static double min() throw()
      { return 2.2250738585072014e-308; }
      static double max() throw()
      { return 1.7976931348623157e+308; }

      static const int digits = 53;
      static const int digits10 = 15;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static double epsilon() throw()
      { return 2.2204460492503131e-16; }
      static double round_error() throw()
      { return 0.5; }

      static const int min_exponent = (-1021);
      static const int min_exponent10 = (-307);
      static const int max_exponent = 1024;
      static const int max_exponent10 = 308;

      static const bool has_infinity
        = __builtin_huge_val () / 2 == __builtin_huge_val ();
      static const bool has_quiet_NaN
        = __builtin_nan ("") != __builtin_nan ("");
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
        = 4.9406564584124654e-324 ? denorm_present : denorm_absent;
      static const bool has_denorm_loss = false;

      static double infinity() throw()
      { return __builtin_huge_val(); }
      static double quiet_NaN() throw()
      { return __builtin_nan (""); }
      static double signaling_NaN() throw()
      { return __builtin_nans (""); }
      static double denorm_min() throw()
      { return 4.9406564584124654e-324; }

      static const bool is_iec559
        = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };





  template<>
    struct numeric_limits<long double>
    {
      static const bool is_specialized = true;

      static long double min() throw()
      { return 3.36210314311209350626e-4932L; }
      static long double max() throw()
      { return 1.18973149535723176502e+4932L; }

      static const int digits = 64;
      static const int digits10 = 18;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static long double epsilon() throw()
      { return 1.08420217248550443401e-19L; }
      static long double round_error() throw()
      { return 0.5L; }

      static const int min_exponent = (-16381);
      static const int min_exponent10 = (-4931);
      static const int max_exponent = 16384;
      static const int max_exponent10 = 4932;

      static const bool has_infinity
        = __builtin_huge_vall () / 2 == __builtin_huge_vall ();
      static const bool has_quiet_NaN
        = __builtin_nanl ("") != __builtin_nanl ("");
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
        = 3.64519953188247460253e-4951L ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
        = false;

      static long double infinity() throw()
      { return __builtin_huge_vall (); }
      static long double quiet_NaN() throw()
      { return __builtin_nanl (""); }
      static long double signaling_NaN() throw()
      { return __builtin_nansl (""); }
      static long double denorm_min() throw()
      { return 3.64519953188247460253e-4951L; }

      static const bool is_iec559
        = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };





}
# 44 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/locale_facets.tcc" 2 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/typeinfo" 1 3
# 40 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/typeinfo" 3
extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 55 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);

  protected:
    const char *__name;

  protected:
    explicit type_info(const char *__n): __name(__n) { }

  public:



    const char* name() const
    { return __name; }
# 101 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/typeinfo" 3
    bool before(const type_info& __arg) const
    { return __name < __arg.__name; }
    bool operator==(const type_info& __arg) const
    { return __name == __arg.__name; }

    bool operator!=(const type_info& __arg) const
    { return !operator==(__arg); }


  public:

    virtual bool __is_pointer_p() const;

    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
                            unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
                             void **__obj_ptr) const;
  };






  class bad_cast : public exception
  {
  public:
    bad_cast() throw() { }


    virtual ~bad_cast() throw();
  };


  class bad_typeid : public exception
  {
  public:
    bad_typeid () throw() { }


    virtual ~bad_typeid() throw();
  };
}

}
# 45 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/locale_facets.tcc" 2 3


namespace std
{
  template<typename _Facet>
    locale
    locale::combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
                       const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
                                __s2.data(), __s2.data() + __s2.length()) < 0);
    }

  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      size_t __i = _Facet::id._M_id();
      locale::facet** __facets = __loc._M_impl->_M_facets;
      if (!(__i < __loc._M_impl->_M_facets_size && __facets[__i]))
        __throw_bad_cast();
      return static_cast<const _Facet&>(*__facets[__i]);
    }

  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      size_t __i = _Facet::id._M_id();
      locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size && __facets[__i]);
    }



  template<typename _Facet>
    inline const __locale_cache<_Facet>&
    __use_cache(const locale& __loc)
    {
      size_t __i = _Facet::id._M_id();
      if (__builtin_expect(__i >= __loc._M_impl->_M_facets_size,false))
        __throw_bad_cast();
      __locale_cache_base* __cache = __loc._M_impl->_M_get_cache(__i);
      if (__builtin_expect(!__cache, false))
        {
          __cache = new __locale_cache<_Facet>(__loc);
          __loc._M_impl->_M_install_cache(__cache, __i);
        }
      return static_cast<const __locale_cache<_Facet>&>(*__cache);
    }


  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
                     ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);


      const char_type __plus = __ctype.widen('+');
      const char_type __minus = __ctype.widen('-');
      int __pos = 0;
      char_type __c = *__beg;
      if ((__traits_type::eq(__c, __plus) || __traits_type::eq(__c, __minus))
          && __beg != __end)
        {
          __xtrc += __ctype.narrow(__c, char());
          ++__pos;
          __c = *(++__beg);
        }


      const char_type __zero = __ctype.widen(_S_atoms_in[_M_zero]);
      bool __found_zero = false;
      while (__traits_type::eq(__c, __zero) && __beg != __end)
        {
          __c = *(++__beg);
          __found_zero = true;
        }
      if (__found_zero)
        {
          __xtrc += _S_atoms_in[_M_zero];
          ++__pos;
        }


      const size_t __len = _M_E - _M_zero + 1;
      char_type __watoms[__len];
      __ctype.widen(_S_atoms_in, _S_atoms_in + __len, __watoms);
      bool __found_dec = false;
      bool __found_sci = false;
      const char_type __dec = __np.decimal_point();

      string __found_grouping;
      const string __grouping = __np.grouping();
      bool __check_grouping = __grouping.size();
      int __sep_pos = 0;
      const char_type __sep = __np.thousands_sep();

      while (__beg != __end)
        {

          const char_type* __p = __traits_type::find(__watoms, 10, __c);


          if (__p && !__traits_type::eq(__c, char_type()))
            {

              ++__pos;
              __xtrc += _S_atoms_in[__p - __watoms];
              ++__sep_pos;
              __c = *(++__beg);
            }
          else if (__traits_type::eq(__c, __sep)
                   && __check_grouping && !__found_dec)
            {


              if (__sep_pos)
                {
                  __found_grouping += static_cast<char>(__sep_pos);
                  __sep_pos = 0;
                  __c = *(++__beg);
                }
              else
                {
                  __err |= ios_base::failbit;
                  break;
                }
            }
          else if (__traits_type::eq(__c, __dec) && !__found_dec)
            {



              if (__found_grouping.size())
                __found_grouping += static_cast<char>(__sep_pos);
              ++__pos;
              __xtrc += '.';
              __c = *(++__beg);
              __found_dec = true;
            }
          else if ((__traits_type::eq(__c, __watoms[_M_e])
                    || __traits_type::eq(__c, __watoms[_M_E]))
                   && !__found_sci && __pos)
            {

              ++__pos;
              __xtrc += __ctype.narrow(__c, char());
              __c = *(++__beg);


              if (__traits_type::eq(__c, __plus)
                  || __traits_type::eq(__c, __minus))
                {
                  ++__pos;
                  __xtrc += __ctype.narrow(__c, char());
                  __c = *(++__beg);
                }
              __found_sci = true;
            }
          else

            break;
        }



      if (__check_grouping && __found_grouping.size())
        {

          if (!__found_dec)
            __found_grouping += static_cast<char>(__sep_pos);
          if (!__verify_grouping(__grouping, __found_grouping))
            __err |= ios_base::failbit;
        }


      __xtrc += char();
      if (__beg == __end)
        __err |= ios_base::eofbit;
      return __beg;
    }


  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
                   ios_base::iostate& __err, string& __xtrc, int& __base) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);


      ios_base::fmtflags __basefield = __io.flags() & ios_base::basefield;
      if (__basefield == ios_base::oct)
        __base = 8;
      else if (__basefield == ios_base::hex)
        __base = 16;
      else
        __base = 10;


      int __pos = 0;
      char_type __c = *__beg;
      const char_type __plus = __ctype.widen('+');
      const char_type __minus = __ctype.widen('-');

      if ((__traits_type::eq(__c, __plus) || __traits_type::eq(__c, __minus))
          && __beg != __end)
        {
          __xtrc += __ctype.narrow(__c, char());
          ++__pos;
          __c = *(++__beg);
        }


      const char_type __zero = __ctype.widen(_S_atoms_in[_M_zero]);
      const char_type __x = __ctype.widen('x');
      const char_type __X = __ctype.widen('X');
      if (__base == 10)
        {
          bool __found_zero = false;
          while (__traits_type::eq(__c, __zero) && __beg != __end)
            {
              __c = *(++__beg);
              __found_zero = true;
            }
          if (__found_zero)
            {
              __xtrc += _S_atoms_in[_M_zero];
              ++__pos;
              if (__basefield == 0)
                {
                  if ((__traits_type::eq(__c, __x)
                       || __traits_type::eq(__c, __X))
                      && __beg != __end)
                    {
                      __xtrc += __ctype.narrow(__c, char());
                      ++__pos;
                      __c = *(++__beg);
                      __base = 16;
                    }
                  else
                    __base = 8;
                }
            }
        }
      else if (__base == 16)
        {
          if (__traits_type::eq(__c, __zero) && __beg != __end)
            {
              __xtrc += _S_atoms_in[_M_zero];
              ++__pos;
              __c = *(++__beg);
              if ((__traits_type::eq(__c, __x) || __traits_type::eq(__c, __X))
                  && __beg != __end)
                {
                  __xtrc += __ctype.narrow(__c, char());
                  ++__pos;
                  __c = *(++__beg);
                }
            }
        }



      size_t __len;
      if (__base == 16)
        __len = _M_size;
      else
        __len = __base;


      char_type __watoms[_M_size];
      __ctype.widen(_S_atoms_in, _S_atoms_in + __len, __watoms);
      string __found_grouping;
      const string __grouping = __np.grouping();
      bool __check_grouping = __grouping.size();
      int __sep_pos = 0;
      const char_type __sep = __np.thousands_sep();
      while (__beg != __end)
        {
          const char_type* __p = __traits_type::find(__watoms, __len, __c);


          if (__p && !__traits_type::eq(__c, char_type()))
            {

              __xtrc += _S_atoms_in[__p - __watoms];
              ++__pos;
              ++__sep_pos;
              __c = *(++__beg);
            }
          else if (__traits_type::eq(__c, __sep) && __check_grouping)
            {


              if (__sep_pos)
                {
                  __found_grouping += static_cast<char>(__sep_pos);
                  __sep_pos = 0;
                  __c = *(++__beg);
                }
              else
                {
                  __err |= ios_base::failbit;
                  break;
                }
            }
          else

            break;
        }



      if (__check_grouping && __found_grouping.size())
        {

          __found_grouping += static_cast<char>(__sep_pos);
          if (!__verify_grouping(__grouping, __found_grouping))
            __err |= ios_base::failbit;
        }


      __xtrc += char();
      if (__beg == __end)
        __err |= ios_base::eofbit;
      return __beg;
    }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {

      if (!(__io.flags() & ios_base::boolalpha))
        {


          string __xtrc;
          int __base;
          __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);

          unsigned long __ul;
          __convert_to_v(__xtrc.c_str(), __ul, __err, _S_c_locale, __base);
          if (!(__err & ios_base::failbit) && __ul <= 1)
            __v = __ul;
          else
            __err |= ios_base::failbit;
        }


      else
        {
          typedef char_traits<_CharT> __traits_type;
          typedef basic_string<_CharT> __string_type;

          locale __loc = __io.getloc();
          const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
          const __string_type __true = __np.truename();
          const __string_type __false = __np.falsename();
          const char_type* __trues = __true.c_str();
          const char_type* __falses = __false.c_str();
          const size_t __truen = __true.size() - 1;
          const size_t __falsen = __false.size() - 1;

          for (size_t __n = 0; __beg != __end; ++__n)
            {
              char_type __c = *__beg++;
              bool __testf = __n <= __falsen
                             ? __traits_type::eq(__c, __falses[__n]) : false;
              bool __testt = __n <= __truen
                             ? __traits_type::eq(__c, __trues[__n]) : false;
              if (!(__testf || __testt))
                {
                  __err |= ios_base::failbit;
                  break;
                }
              else if (__testf && __n == __falsen)
                {
                  __v = 0;
                  break;
                }
              else if (__testt && __n == __truen)
                {
                  __v = 1;
                  break;
                }
            }
          if (__beg == __end)
            __err |= ios_base::eofbit;
        }
      return __beg;
    }


  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long& __v) const
    {
      string __xtrc;
      int __base;
      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);
      __convert_to_v(__xtrc.c_str(), __v, __err, _S_c_locale, __base);
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned short& __v) const
    {
      string __xtrc;
      int __base;
      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);
      unsigned long __ul;
      __convert_to_v(__xtrc.c_str(), __ul, __err, _S_c_locale, __base);
      if (!(__err & ios_base::failbit)
          && __ul <= numeric_limits<unsigned short>::max())
        __v = static_cast<unsigned short>(__ul);
      else
        __err |= ios_base::failbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned int& __v) const
    {
      string __xtrc;
      int __base;
      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);
      unsigned long __ul;
      __convert_to_v(__xtrc.c_str(), __ul, __err, _S_c_locale, __base);
      if (!(__err & ios_base::failbit)
          && __ul <= numeric_limits<unsigned int>::max())
        __v = static_cast<unsigned int>(__ul);
      else
        __err |= ios_base::failbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned long& __v) const
    {
      string __xtrc;
      int __base;
      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);
      __convert_to_v(__xtrc.c_str(), __v, __err, _S_c_locale, __base);
      return __beg;
    }


  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long long& __v) const
    {
      string __xtrc;
      int __base;
      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);
      __convert_to_v(__xtrc.c_str(), __v, __err, _S_c_locale, __base);
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned long long& __v) const
    {
      string __xtrc;
      int __base;
      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);
      __convert_to_v(__xtrc.c_str(), __v, __err, _S_c_locale, __base);
      return __beg;
    }


  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      __convert_to_v(__xtrc.c_str(), __v, __err, _S_c_locale);
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      __convert_to_v(__xtrc.c_str(), __v, __err, _S_c_locale);
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      __convert_to_v(__xtrc.c_str(), __v, __err, _S_c_locale);
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      fmtflags __fmt = __io.flags();
      fmtflags __fmtmask = ~(ios_base::showpos | ios_base::basefield
                             | ios_base::uppercase | ios_base::internal);
      __io.flags(__fmt & __fmtmask | (ios_base::hex | ios_base::showbase));

      string __xtrc;
      int __base;
      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);


      __io.flags(__fmt);

      unsigned long __ul;
      __convert_to_v(__xtrc.c_str(), __ul, __err, _S_c_locale, __base);
      if (!(__err & ios_base::failbit))
        __v = reinterpret_cast<void*>(__ul);
      else
        __err |= ios_base::failbit;
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
           _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new, __cs,
                                                  __w, __len, true);
      __len = static_cast<int>(__w);
    }


  template<typename _CharT>
    inline int
    __int_to_char(_CharT* __out, const int __size, long __v,
                       const _CharT* __lit, ios_base::fmtflags __flags)
    {
      unsigned long __ul = static_cast<unsigned long>(__v);
      bool __neg = false;
      if (__v < 0)
        {
          __ul = -__ul;
          __neg = true;
        }
      return __int_to_char(__out, __size, __ul, __lit, __flags, __neg);
    }

  template<typename _CharT>
    inline int
    __int_to_char(_CharT* __out, const int __size, unsigned long __v,
                       const _CharT* __lit, ios_base::fmtflags __flags)
    { return __int_to_char(__out, __size, __v, __lit, __flags, false); }


  template<typename _CharT>
    inline int
    __int_to_char(_CharT* __out, const int __size, long long __v,
                       const _CharT* __lit, ios_base::fmtflags __flags)
    {
      unsigned long long __ull = static_cast<unsigned long long>(__v);
      bool __neg = false;
      if (__v < 0)
        {
          __ull = -__ull;
          __neg = true;
        }
      return __int_to_char(__out, __size, __ull, __lit, __flags, __neg);
    }

  template<typename _CharT>
    inline int
    __int_to_char(_CharT* __out, const int __size, unsigned long long __v,
                       const _CharT* __lit, ios_base::fmtflags __flags)
    { return __int_to_char(__out, __size, __v, __lit, __flags, false); }


  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __out, const int __size, _ValueT __v,
                  const _CharT* __lit, ios_base::fmtflags __flags, bool __neg)
    {

      const bool __showbase = (__flags & ios_base::showbase) && __v;
      const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
      _CharT* __buf = __out + __size - 1;
      _CharT* __bufend = __out + __size;

      if (__builtin_expect(__basefield != ios_base::oct &&
                           __basefield != ios_base::hex, true))
        {

          do
            {
              *__buf-- = __lit[(__v % 10) + __num_base::_S_digits];
              __v /= 10;
            }
          while (__v != 0);
          if (__neg)
            *__buf-- = __lit[__num_base::_S_minus];
          else if (__flags & ios_base::showpos)
            *__buf-- = __lit[__num_base::_S_plus];
        }
      else if (__basefield == ios_base::oct)
        {

          do
            {
              *__buf-- = __lit[(__v & 0x7) + __num_base::_S_digits];
              __v >>= 3;
            }
          while (__v != 0);
          if (__showbase)
            *__buf-- = __lit[__num_base::_S_digits];
        }
      else
        {

          const bool __uppercase = __flags & ios_base::uppercase;
          int __case_offset = __uppercase
                              ? __num_base::_S_udigits : __num_base::_S_digits;
          do
            {
              *__buf-- = __lit[(__v & 0xf) + __case_offset];
              __v >>= 4;
            }
          while (__v != 0);
          if (__showbase)
            {

              *__buf-- = __lit[__num_base::_S_x + __uppercase];

              *__buf-- = __lit[__num_base::_S_digits];
            }
        }
      int __ret = __bufend - __buf - 1;
      return __ret;
    }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const string& __grouping, _CharT __sep, ios_base& __io,
                 _CharT* __new, _CharT* __cs, int& __len) const
    {





      streamsize __off = 0;
      const ios_base::fmtflags __basefield = __io.flags()
                                             & ios_base::basefield;
      if ((__io.flags() & ios_base::showbase) && __len > 1)
        if (__basefield == ios_base::oct)
          {
            __off = 1;
            *__new = *__cs;
          }
        else if (__basefield == ios_base::hex)
          {
            __off = 2;
            *__new = *__cs;
            *(__new + 1) = *(__cs + 1);
          }
      _CharT* __p;
      __p = __add_grouping(__new + __off, __sep,
                           __grouping.c_str(),
                           __grouping.c_str() + __grouping.size(),
                           __cs + __off, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_convert_int(_OutIter __s, ios_base& __io, _CharT __fill,
                     _ValueT __v) const
      {
        typedef numpunct<_CharT> __facet_type;
        typedef __locale_cache<numpunct<_CharT> > __cache_type;
        const locale& __loc = __io._M_getloc();
        const __cache_type& __lc = __use_cache<__facet_type>(__loc);
        const _CharT* __lit = __lc._M_atoms_out;


        int __ilen = 4 * sizeof(_ValueT);
        _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                                                             * __ilen));


        int __len;
        __len = __int_to_char(&__cs[0], __ilen, __v, __lit, __io.flags());
        __cs = __cs + __ilen - __len;


        _CharT* __cs2;
        if (__lc._M_use_grouping)
          {


            __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                                                          * __len * 2));
            _M_group_int(__lc._M_grouping, __lc._M_thousands_sep, __io,
                         __cs2, __cs, __len);
            __cs = __cs2;
          }


        _CharT* __cs3;
        streamsize __w = __io.width();
        if (__w > static_cast<streamsize>(__len))
          {
            __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                                                          * __w));
            _M_pad(__fill, __w, __io, __cs3, __cs, __len);
            __cs = __cs3;
          }
        __io.width(0);



        return __write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const string& __grouping, _CharT __sep, const _CharT* __p,
                   _CharT* __new, _CharT* __cs, int& __len) const
    {



      _CharT* __p2;
      int __declen = __p ? __p - __cs : __len;
      __p2 = __add_grouping(__new, __sep,
                            __grouping.c_str(),
                            __grouping.c_str() + __grouping.size(),
                            __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
        {
          char_traits<_CharT>::copy(__p2, __p, __len - __declen);
          __newlen += __len - __declen;
        }
      __len = __newlen;

    }
# 872 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_convert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
                       _ValueT __v) const
      {







        const int __max_digits = numeric_limits<_ValueT>::digits10 + 2;


        streamsize __prec = __io.precision();
        if (__prec > static_cast<streamsize>(__max_digits))
          __prec = static_cast<streamsize>(__max_digits);
        else if (__prec < static_cast<streamsize>(0))
          __prec = static_cast<streamsize>(6);

        typedef numpunct<_CharT> __facet_type;
        typedef __locale_cache<numpunct<_CharT> > __cache_type;
        const locale __loc = __io._M_getloc();
        const __cache_type& __lc = __use_cache<__facet_type>(__loc);


        int __len;

        char __fbuf[16];




        int __cs_size = __max_digits * 3;
        char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));

        _S_format_float(__io, __fbuf, __mod, __prec);
        __len = __convert_from_v(__cs, __cs_size, __fbuf, __v,
                                 _S_c_locale, __prec);


        if (__len >= __cs_size)
          {
            __cs_size = __len + 1;
            __cs = static_cast<char*>(__builtin_alloca(__cs_size));
            __len = __convert_from_v(__cs, __cs_size, __fbuf, __v,
                                     _S_c_locale, __prec);
          }
# 943 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/locale_facets.tcc" 3
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                                                           * __len));
      __ctype.widen(__cs, __cs + __len, __ws);


      const _CharT __cdec = __ctype.widen('.');
      const _CharT __dec = __lc._M_decimal_point;
      const _CharT* __p;
      if (__p = char_traits<_CharT>::find(__ws, __len, __cdec))
        __ws[__p - __ws] = __dec;


      _CharT* __ws2;
      if (__lc._M_use_grouping)
        {


            __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                                                          * __len * 2));
            _M_group_float(__lc._M_grouping, __lc._M_thousands_sep, __p,
                           __ws2, __ws, __len);
            __ws = __ws2;
        }


      _CharT* __ws3;
      streamsize __w = __io.width();
      if (__w > static_cast<streamsize>(__len))
        {
          __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __w));
          _M_pad(__fill, __w, __io, __ws3, __ws, __len);
          __ws = __ws3;
        }
      __io.width(0);



      return __write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          unsigned long __uv = __v;
          __s = _M_convert_int(__s, __io, __fill, __uv);
        }
      else
        {
          typedef numpunct<_CharT> __facet_type;
          typedef __locale_cache<numpunct<_CharT> > __cache_type;
          const locale __loc = __io._M_getloc();
          const __cache_type& __lc = __use_cache<__facet_type>(__loc);

          typedef basic_string<_CharT> __string_type;
          __string_type __name;
          if (__v)
            __name = __lc._M_truename;
          else
            __name = __lc._M_falsename;

          const _CharT* __cs = __name.c_str();
          int __len = __name.size();
          _CharT* __cs3;
          streamsize __w = __io.width();
          if (__w > static_cast<streamsize>(__len))
            {
              __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                                                            * __w));
              _M_pad(__fill, __w, __io, __cs3, __cs, __len);
              __cs = __cs3;
            }
          __io.width(0);
          __s = __write(__s, __cs, __len);
        }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
    { return _M_convert_int(__s, __io, __fill, __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           unsigned long __v) const
    { return _M_convert_int(__s, __io, __fill, __v); }


  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __b, char_type __fill, long long __v) const
    { return _M_convert_int(__s, __b, __fill, __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           unsigned long long __v) const
    { return _M_convert_int(__s, __io, __fill, __v); }


  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_convert_float(__s, __io, __fill, char(), __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           long double __v) const
    { return _M_convert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      ios_base::fmtflags __flags = __io.flags();
      ios_base::fmtflags __fmt = ~(ios_base::showpos | ios_base::basefield
                                   | ios_base::uppercase | ios_base::internal);
      __io.flags(__flags & __fmt | (ios_base::hex | ios_base::showbase));
      try
        {
          __s = _M_convert_int(__s, __io, __fill,
                               reinterpret_cast<unsigned long>(__v));
          __io.flags(__flags);
        }
      catch (...)
        {
          __io.flags(__flags);
          throw;
        }
      return __s;
    }


  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
           ios_base::iostate& __err, long double& __units) const
    {
      string_type __str;
      __beg = this->do_get(__beg, __end, __intl, __io, __err, __str);

      const int __n = numeric_limits<long double>::digits10;
      char* __cs = static_cast<char*>(__builtin_alloca(__n));
      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const _CharT* __wcs = __str.c_str();
      __ctype.narrow(__wcs, __wcs + __str.size() + 1, char(), __cs);
      __convert_to_v(__cs, __units, __err, _S_c_locale);
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
           ios_base::iostate& __err, string_type& __units) const
    {

      typedef moneypunct<_CharT, true> __money_true;
      typedef moneypunct<_CharT, false> __money_false;
      typedef money_base::part part;
      typedef typename string_type::size_type size_type;

      const locale __loc = __io.getloc();
      const __money_true& __mpt = use_facet<__money_true>(__loc);
      const __money_false& __mpf = use_facet<__money_false>(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      const money_base::pattern __p = __intl ? __mpt.neg_format()
                                             : __mpf.neg_format();

      const string_type __pos_sign =__intl ? __mpt.positive_sign()
                                           : __mpf.positive_sign();
      const string_type __neg_sign =__intl ? __mpt.negative_sign()
                                           : __mpf.negative_sign();
      const char_type __d = __intl ? __mpt.decimal_point()
                                   : __mpf.decimal_point();
      const char_type __sep = __intl ? __mpt.thousands_sep()
                                     : __mpf.thousands_sep();

      const string __grouping = __intl ? __mpt.grouping() : __mpf.grouping();


      string_type __sign;

      string __grouping_tmp;

      int __sep_pos = 0;

      bool __testvalid = true;

      bool __testdecfound = false;


      string_type __temp_units;

      char_type __c = *__beg;
      char_type __eof = static_cast<char_type>(char_traits<char_type>::eof());
      for (int __i = 0; __beg != __end && __i < 4 && __testvalid; ++__i)
        {
          part __which = static_cast<part>(__p.field[__i]);
          switch (__which)
                {
                case money_base::symbol:
                  if (__io.flags() & ios_base::showbase
                      || __i < 2 || __sign.size() > 1
                      || ((static_cast<part>(__p.field[3]) != money_base::none)
                          && __i == 2))
                    {





                      const string_type __symbol = __intl ? __mpt.curr_symbol()
                                                         : __mpf.curr_symbol();
                      size_type __len = __symbol.size();
                      size_type __j = 0;
                      while (__beg != __end
                             && __j < __len && __symbol[__j] == __c)
                        {
                          __c = *(++__beg);
                          ++__j;
                        }


                      if (__j != __len && (__io.flags() & ios_base::showbase))
                        __testvalid = false;
                    }
                  break;
                case money_base::sign:

                  if (__pos_sign.size() && __neg_sign.size())
                  {

                    if (__c == __pos_sign[0])
                      {
                        __sign = __pos_sign;
                        __c = *(++__beg);
                      }
                    else if (__c == __neg_sign[0])
                      {
                        __sign = __neg_sign;
                        __c = *(++__beg);
                      }
                    else
                      __testvalid = false;
                  }
                  else if (__pos_sign.size() && __c == __pos_sign[0])
                    {
                      __sign = __pos_sign;
                      __c = *(++__beg);
                    }
                  else if (__neg_sign.size() && __c == __neg_sign[0])
                    {
                      __sign = __neg_sign;
                      __c = *(++__beg);
                    }
                  break;
                case money_base::value:


                  while (__beg != __end
                         && (__ctype.is(ctype_base::digit, __c)
                             || (__c == __d && !__testdecfound)
                             || __c == __sep))
                    {
                      if (__c == __d)
                        {
                          __grouping_tmp += static_cast<char>(__sep_pos);
                          __sep_pos = 0;
                          __testdecfound = true;
                        }
                      else if (__c == __sep)
                        {
                          if (__grouping.size())
                            {

                              __grouping_tmp += static_cast<char>(__sep_pos);
                              __sep_pos = 0;
                            }
                          else
                            {
                              __testvalid = false;
                              break;
                            }
                        }
                      else
                        {
                          __temp_units += __c;
                          ++__sep_pos;
                        }
                      __c = *(++__beg);
                    }
                  break;
                case money_base::space:
                case money_base::none:

                  if (__i != 3)
                    while (__beg != __end
                           && __ctype.is(ctype_base::space, __c))
                      __c = *(++__beg);
                  break;
                }
        }


      if (__sign.size() > 1)
        {
          size_type __len = __sign.size();
          size_type __i = 1;
          for (; __c != __eof && __i < __len; ++__i)
            while (__beg != __end && __c != __sign[__i])
              __c = *(++__beg);

          if (__i != __len)
            __testvalid = false;
        }


      while (__temp_units.size() > 1 && __temp_units[0] == __ctype.widen('0'))
        __temp_units.erase(__temp_units.begin());

      if (__sign.size() && __sign == __neg_sign)
        __temp_units.insert(__temp_units.begin(), __ctype.widen('-'));


      if (__grouping.size() && __grouping_tmp.size())
        {
          if (!__verify_grouping(__grouping, __grouping_tmp))
            __testvalid = false;
        }


      if (__c == __eof)
        __err |= ios_base::eofbit;


      if (!__testvalid || !__temp_units.size())
        __err |= ios_base::failbit;
      else

        __temp_units.swap(__units);

      return __beg;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
           long double __units) const
    {
      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);


      int __cs_size = 64;
      char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
      int __len = __convert_from_v(__cs, __cs_size, "%.01Lf", __units,
                                   _S_c_locale);

      if (__len >= __cs_size)
        {
          __cs_size = __len + 1;
          __cs = static_cast<char*>(__builtin_alloca(__cs_size));
          __len = __convert_from_v(__cs, __cs_size, "%.01Lf", __units,
                                   _S_c_locale);
        }







      _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                                                           * __cs_size));
      __ctype.widen(__cs, __cs + __len, __ws);
      string_type __digits(__ws);
      return this->do_put(__s, __intl, __io, __fill, __digits);
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
           const string_type& __digits) const
    {
      typedef typename string_type::size_type size_type;
      typedef money_base::part part;

      const locale __loc = __io.getloc();
      const size_type __width = static_cast<size_type>(__io.width());


      typedef moneypunct<_CharT, true> __money_true;
      typedef moneypunct<_CharT, false> __money_false;
      const __money_true& __mpt = use_facet<__money_true>(__loc);
      const __money_false& __mpf = use_facet<__money_false>(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);



      const char_type* __beg = __digits.data();
      const char_type* __end = __beg + __digits.size();
      money_base::pattern __p;
      string_type __sign;
      if (*__beg != __ctype.widen('-'))
        {
          __p = __intl ? __mpt.pos_format() : __mpf.pos_format();
          __sign =__intl ? __mpt.positive_sign() : __mpf.positive_sign();
        }
      else
        {
          __p = __intl ? __mpt.neg_format() : __mpf.neg_format();
          __sign =__intl ? __mpt.negative_sign() : __mpf.negative_sign();
          ++__beg;
        }


      __end = __ctype.scan_not(ctype_base::digit, __beg, __end);
      if (__beg != __end)
        {



          string_type __res;
          string_type __value;
          const string_type __symbol = __intl ? __mpt.curr_symbol()
                                              : __mpf.curr_symbol();


          const int __frac = __intl ? __mpt.frac_digits()
                                    : __mpf.frac_digits();
          if (__frac > 0)
            {
              const char_type __d = __intl ? __mpt.decimal_point()
                                           : __mpf.decimal_point();
              if (__end - __beg >= __frac)
                {
                  __value = string_type(__end - __frac, __end);
                  __value.insert(__value.begin(), __d);
                  __end -= __frac;
                }
              else
                {

                  __value = string_type(__beg, __end);
                  int __paddec = __frac - (__end - __beg);
                  char_type __zero = __ctype.widen('0');
                  __value.insert(__value.begin(), __paddec, __zero);
                  __value.insert(__value.begin(), __d);
                  __beg = __end;
                }
            }



          if (__beg != __end)
            {
              const string __grouping = __intl ? __mpt.grouping()
                                               : __mpf.grouping();
              if (__grouping.size())
                {
                  const char_type __sep = __intl ? __mpt.thousands_sep()
                                                 : __mpf.thousands_sep();
                  const char* __gbeg = __grouping.c_str();
                  const char* __gend = __gbeg + __grouping.size();
                  const int __n = (__end - __beg) * 2;
                  _CharT* __ws2 =
                  static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __n));
                  _CharT* __ws_end = __add_grouping(__ws2, __sep, __gbeg,
                                                    __gend, __beg, __end);
                  __value.insert(0, __ws2, __ws_end - __ws2);
                }
              else
                __value.insert(0, string_type(__beg, __end));
            }


          ios_base::fmtflags __f = __io.flags() & ios_base::adjustfield;
          size_type __len = __value.size() + __sign.size();
          __len += (__io.flags() & ios_base::showbase) ? __symbol.size() : 0;
          bool __testipad = __f == ios_base::internal && __len < __width;


          for (int __i = 0; __i < 4; ++__i)
            {
              part __which = static_cast<part>(__p.field[__i]);
              switch (__which)
                {
                case money_base::symbol:
                  if (__io.flags() & ios_base::showbase)
                    __res += __symbol;
                  break;
                case money_base::sign:



                  if (__sign.size())
                    __res += __sign[0];
                  break;
                case money_base::value:
                  __res += __value;
                  break;
                case money_base::space:



                  if (__testipad)
                    __res += string_type(__width - __len, __fill);
                  else
                    __res += __ctype.widen(__fill);
                  break;
                case money_base::none:
                  if (__testipad)
                    __res += string_type(__width - __len, __fill);
                  break;
                }
            }


          if (__sign.size() > 1)
            __res += string_type(__sign.begin() + 1, __sign.end());


          __len = __res.size();
          if (__width > __len)
            {
              if (__f == ios_base::left)

                __res.append(__width - __len, __fill);
              else

                __res.insert(0, string_type(__width - __len, __fill));
              __len = __width;
            }


          __s = __write(__s, __res.c_str(), __len);
        }
      __io.width(0);
      return __s;
    }





  template<typename _CharT, typename _InIter>
    time_base::dateorder
    time_get<_CharT, _InIter>::do_date_order() const
    { return time_base::no_order; }

  template<typename _CharT, typename _InIter>
    void
    time_get<_CharT, _InIter>::
    _M_extract_via_format(iter_type& __beg, iter_type& __end, ios_base& __io,
                          ios_base::iostate& __err, tm* __tm,
                          const _CharT* __format) const
    {
      locale __loc = __io.getloc();
      __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      size_t __len = char_traits<_CharT>::length(__format);

      for (size_t __i = 0; __beg != __end && __i < __len && !__err; ++__i)
        {
          char __c = __format[__i];
          if (__c == '%')
            {

              __c = __format[++__i];
              char __mod = 0;
              int __mem = 0;
              if (__c == 'E' || __c == 'O')
                {
                  __mod = __c;
                  __c = __format[++__i];
                }
              switch (__c)
                {
                  const char* __cs;
                  _CharT __wcs[10];
                case 'a':

                  const char_type* __days1[7];
                  __tp._M_days_abbreviated(__days1);
                  _M_extract_name(__beg, __end, __tm->tm_wday, __days1, 7,
                                  __err);
                  break;
                case 'A':

                  const char_type* __days2[7];
                  __tp._M_days(__days2);
                  _M_extract_name(__beg, __end, __tm->tm_wday, __days2, 7,
                                  __err);
                  break;
                case 'h':
                case 'b':

                  const char_type* __months1[12];
                  __tp._M_months_abbreviated(__months1);
                  _M_extract_name(__beg, __end, __tm->tm_mon, __months1, 12,
                                  __err);
                  break;
                case 'B':

                  const char_type* __months2[12];
                  __tp._M_months(__months2);
                  _M_extract_name(__beg, __end, __tm->tm_mon, __months2, 12,
                                  __err);
                  break;
                case 'c':

                  const char_type* __dt[2];
                  __tp._M_date_time_formats(__dt);
                  _M_extract_via_format(__beg, __end, __io, __err, __tm,
                                        __dt[0]);
                  break;
                case 'd':

                  _M_extract_num(__beg, __end, __tm->tm_mday, 1, 31, 2,
                                 __ctype, __err);
                  break;
                case 'D':

                  __cs = "%m/%d/%y";
                  __ctype.widen(__cs, __cs + 9, __wcs);
                  _M_extract_via_format(__beg, __end, __io, __err, __tm,
                                        __wcs);
                  break;
                case 'H':

                  _M_extract_num(__beg, __end, __tm->tm_hour, 0, 23, 2,
                                 __ctype, __err);
                  break;
                case 'I':

                  _M_extract_num(__beg, __end, __tm->tm_hour, 1, 12, 2,
                                 __ctype, __err);
                  break;
                case 'm':

                  _M_extract_num(__beg, __end, __mem, 1, 12, 2, __ctype,
                                 __err);
                  if (!__err)
                    __tm->tm_mon = __mem - 1;
                  break;
                case 'M':

                  _M_extract_num(__beg, __end, __tm->tm_min, 0, 59, 2,
                                 __ctype, __err);
                  break;
                case 'n':
                  if (__ctype.narrow(*__beg, 0) == '\n')
                    ++__beg;
                  else
                    __err |= ios_base::failbit;
                  break;
                case 'R':

                  __cs = "%H:%M";
                  __ctype.widen(__cs, __cs + 6, __wcs);
                  _M_extract_via_format(__beg, __end, __io, __err, __tm,
                                        __wcs);
                  break;
                case 'S':

                  _M_extract_num(__beg, __end, __tm->tm_sec, 0, 59, 2,
                                 __ctype, __err);
                  break;
                case 't':
                  if (__ctype.narrow(*__beg, 0) == '\t')
                    ++__beg;
                  else
                __err |= ios_base::failbit;
                  break;
                case 'T':

                  __cs = "%H:%M:%S";
                  __ctype.widen(__cs, __cs + 9, __wcs);
                  _M_extract_via_format(__beg, __end, __io, __err, __tm,
                                        __wcs);
                  break;
                case 'x':

                  const char_type* __dates[2];
                  __tp._M_date_formats(__dates);
                  _M_extract_via_format(__beg, __end, __io, __err, __tm,
                                        __dates[0]);
                  break;
                case 'X':

                  const char_type* __times[2];
                  __tp._M_time_formats(__times);
                  _M_extract_via_format(__beg, __end, __io, __err, __tm,
                                        __times[0]);
                  break;
                case 'y':

                  _M_extract_num(__beg, __end, __tm->tm_year, 0, 99, 2,
                                 __ctype, __err);
                  break;
                case 'Y':

                  _M_extract_num(__beg, __end, __mem, 0,
                                 numeric_limits<int>::max(), 4,
                                 __ctype, __err);
                  if (!__err)
                    __tm->tm_year = __mem - 1900;
                  break;
                case 'Z':

                  if (__ctype.is(ctype_base::upper, *__beg))
                    {
                      int __tmp;
                      _M_extract_name(__beg, __end, __tmp,
                                      __timepunct<_CharT>::_S_timezones,
                                      14, __err);


                      char_type __c = *__beg;
                      if (!__err && __tmp == 0
                          && (__c == __ctype.widen('-')
                              || __c == __ctype.widen('+')))
                        {
                          _M_extract_num(__beg, __end, __tmp, 0, 23, 2,
                                          __ctype, __err);
                          _M_extract_num(__beg, __end, __tmp, 0, 59, 2,
                                          __ctype, __err);
                        }
                          }
                      else
                        __err |= ios_base::failbit;
                      break;
                    default:

                      __err |= ios_base::failbit;
                    }
                }
              else
                {

                  if (__c == __ctype.narrow(*__beg, 0))
                    ++__beg;
                  else
                    __err |= ios_base::failbit;
                }
        }
    }

  template<typename _CharT, typename _InIter>
    void
    time_get<_CharT, _InIter>::
    _M_extract_num(iter_type& __beg, iter_type& __end, int& __member,
                   int __min, int __max, size_t __len,
                   const ctype<_CharT>& __ctype,
                   ios_base::iostate& __err) const
    {
      size_t __i = 0;
      string __digits;
      bool __testvalid = true;
      char_type __c = *__beg;
      while (__beg != __end && __i < __len
             && __ctype.is(ctype_base::digit, __c))
        {
          __digits += __ctype.narrow(__c, 0);
          __c = *(++__beg);
          ++__i;
        }
      if (__i == __len)
        {
          int __value = atoi(__digits.c_str());
          if (__min <= __value && __value <= __max)
            __member = __value;
          else
            __testvalid = false;
        }
      else
        __testvalid = false;
      if (!__testvalid)
        __err |= ios_base::failbit;
    }



  template<typename _CharT, typename _InIter>
    void
    time_get<_CharT, _InIter>::
    _M_extract_name(iter_type& __beg, iter_type& __end, int& __member,
                    const _CharT** __names, size_t __indexlen,
                    ios_base::iostate& __err) const
    {
      typedef char_traits<_CharT> __traits_type;
      int* __matches = static_cast<int*>(__builtin_alloca(sizeof(int)
                                                          * __indexlen));
      size_t __nmatches = 0;
      size_t __pos = 0;
      bool __testvalid = true;
      const char_type* __name;

      char_type __c = *__beg;

      for (size_t __i1 = 0; __i1 < __indexlen; ++__i1)
        if (__c == __names[__i1][0])
          __matches[__nmatches++] = __i1;

      while (__nmatches > 1)
        {

          size_t __minlen = 10;
          for (size_t __i2 = 0; __i2 < __nmatches; ++__i2)
            __minlen = min(__minlen,
                           __traits_type::length(__names[__matches[__i2]]));

          if (__pos < __minlen && __beg != __end)
            {
              ++__pos;
              __c = *(++__beg);
              for (size_t __i3 = 0; __i3 < __nmatches; ++__i3)
                {
                  __name = __names[__matches[__i3]];
                  if (__name[__pos] != __c)
                    __matches[__i3] = __matches[--__nmatches];
                }
            }
          else
            break;
        }

      if (__nmatches == 1)
        {

          __name = __names[__matches[0]];
          const size_t __len = __traits_type::length(__name);
          while (__pos < __len && __beg != __end && __name[__pos] == *__beg)
            ++__beg, ++__pos;

          if (__len == __pos)
            __member = __matches[0];
          else
            __testvalid = false;
        }
      else
        __testvalid = false;
      if (!__testvalid)
        __err |= ios_base::failbit;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
                ios_base::iostate& __err, tm* __tm) const
    {
      _CharT __wcs[3];
      const char* __cs = "%X";
      locale __loc = __io.getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __ctype.widen(__cs, __cs + 3, __wcs);
      _M_extract_via_format(__beg, __end, __io, __err, __tm, __wcs);
      if (__beg == __end)
        __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
                ios_base::iostate& __err, tm* __tm) const
    {
      _CharT __wcs[3];
      const char* __cs = "%x";
      locale __loc = __io.getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __ctype.widen(__cs, __cs + 3, __wcs);
      _M_extract_via_format(__beg, __end, __io, __err, __tm, __wcs);
      if (__beg == __end)
        __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
                   ios_base::iostate& __err, tm* __tm) const
    {
      typedef char_traits<_CharT> __traits_type;
      locale __loc = __io.getloc();
      __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __days[7];
      __tp._M_days_abbreviated(__days);
      int __tmpwday;
      _M_extract_name(__beg, __end, __tmpwday, __days, 7, __err);







      if (!__err)
        {
          size_t __pos = __traits_type::length(__days[__tmpwday]);
          __tp._M_days(__days);
          const char_type* __name = __days[__tmpwday];
          if (__name[__pos] == *__beg)
            {

              const size_t __len = __traits_type::length(__name);
              while (__pos < __len && __beg != __end
                     && __name[__pos] == *__beg)
                ++__beg, ++__pos;
              if (__len != __pos)
                __err |= ios_base::failbit;
            }
          if (!__err)
            __tm->tm_wday = __tmpwday;
        }
      if (__beg == __end)
        __err |= ios_base::eofbit;
      return __beg;
     }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_monthname(iter_type __beg, iter_type __end,
                     ios_base& __io, ios_base::iostate& __err, tm* __tm) const
    {
      typedef char_traits<_CharT> __traits_type;
      locale __loc = __io.getloc();
      __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __months[12];
      __tp._M_months_abbreviated(__months);
      int __tmpmon;
      _M_extract_name(__beg, __end, __tmpmon, __months, 12, __err);







      if (!__err)
        {
          size_t __pos = __traits_type::length(__months[__tmpmon]);
          __tp._M_months(__months);
          const char_type* __name = __months[__tmpmon];
          if (__name[__pos] == *__beg)
            {

              const size_t __len = __traits_type::length(__name);
              while (__pos < __len && __beg != __end
                     && __name[__pos] == *__beg)
                ++__beg, ++__pos;
              if (__len != __pos)
                __err |= ios_base::failbit;
            }
          if (!__err)
            __tm->tm_mon = __tmpmon;
        }

      if (__beg == __end)
        __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
                ios_base::iostate& __err, tm* __tm) const
    {
      locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      char_type __c = *__beg;
      size_t __i = 0;
      string __digits;
      while (__i < 4 && __beg != __end && __ctype.is(ctype_base::digit, __c))
        {
          __digits += __ctype.narrow(__c, 0);
          __c = *(++__beg);
          ++__i;
        }
      if (__i == 2 || __i == 4)
        {
          long __l;
          __convert_to_v(__digits.c_str(), __l, __err, _S_c_locale);
          if (!(__err & ios_base::failbit) && __l <= 2147483647)
            {
              __l = __i == 2 ? __l : __l - 1900;
              __tm->tm_year = static_cast<int>(__l);
            }
        }
      else
        __err |= ios_base::failbit;
      if (__beg == __end)
        __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    put(iter_type __s, ios_base& __io, char_type, const tm* __tm,
        const _CharT* __beg, const _CharT* __end) const
    {
      locale __loc = __io.getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      while (__beg != __end)
        {
          char __c = __ctype.narrow(*__beg, 0);
          ++__beg;
          if (__c == '%')
            {
              char __format;
              char __mod = 0;
              size_t __len = 1;
              __c = __ctype.narrow(*__beg, 0);
              ++__beg;
              if (__c == 'E' || __c == 'O')
                {
                  __mod = __c;
                  __format = __ctype.narrow(*__beg, 0);
                  ++__beg;
                }
              else
                __format = __c;
              __s = this->do_put(__s, __io, _CharT(), __tm, __format, __mod);
            }
          else
            {
              *__s = __c;
              ++__s;
            }
        }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type, const tm* __tm,
           char __format, char __mod) const
    {
      locale __loc = __io.getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);



      const size_t __maxlen = 64;
      char_type* __res = static_cast<char_type*>(__builtin_alloca(sizeof(char_type) * __maxlen));






      char_type __fmt[4];
      __fmt[0] = __ctype.widen('%');
      if (!__mod)
        {
          __fmt[1] = __format;
          __fmt[2] = char_type();
        }
      else
        {
          __fmt[1] = __mod;
          __fmt[2] = __format;
          __fmt[3] = char_type();
        }

      __tp._M_put(__res, __maxlen, __fmt, __tm);


      return __write(__s, __res, char_traits<char_type>::length(__res));
    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
               const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.c_str() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.c_str() + __two.length();




      for (;;)
        {
          int __res = _M_compare(__p, __q);
          if (__res)
            return __res;

          __p += char_traits<_CharT>::length(__p);
          __q += char_traits<_CharT>::length(__q);
          if (__p == __pend && __q == __qend)
            return 0;
          else if (__p == __pend)
            return -1;
          else if (__q == __qend)
            return 1;

          __p++;
          __q++;
        }
    }

 template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {

      string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.c_str() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      string_type __ret;




      for (;;)
        {

          _CharT* __c =
            static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __len));
          size_t __res = _M_transform(__c, __p, __len);


          if (__res >= __len)
            {
              __len = __res + 1;
              __c = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                                                          * __len));
              __res = _M_transform(__c, __p, __res + 1);
            }

          __ret.append(__c, __res);
          __p += char_traits<_CharT>::length(__p);
          if (__p == __pend)
            return __ret;

          __p++;
          __ret.push_back(_CharT());
        }
    }

 template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
        __val = *__lo + ((__val << 7) |
                       (__val >> (numeric_limits<unsigned long>::digits - 7)));
      return static_cast<long>(__val);
    }
# 2165 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
                                   _CharT* __news, const _CharT* __olds,
                                   const streamsize __newlen,
                                   const streamsize __oldlen, const bool __num)
    {
      size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      _CharT* __pads = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                                                             * __plen));
      _Traits::assign(__pads, __plen, __fill);

      _CharT* __beg;
      _CharT* __end;
      size_t __mod = 0;
      size_t __beglen;
      ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;

      if (__adjust == ios_base::left)
        {

          __beg = const_cast<_CharT*>(__olds);
          __beglen = __oldlen;
          __end = __pads;
        }
      else if (__adjust == ios_base::internal && __num)
        {



          locale __loc = __io.getloc();
          const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
          const _CharT __minus = __ctype.widen('-');
          const _CharT __plus = __ctype.widen('+');
          bool __testsign = _Traits::eq(__olds[0], __minus)
                            || _Traits::eq(__olds[0], __plus);

          bool __testhex = _Traits::eq(__ctype.widen('0'), __olds[0])
                           && (_Traits::eq(__ctype.widen('x'), __olds[1])
                               || _Traits::eq(__ctype.widen('X'), __olds[1]));
          if (__testhex)
            {
              __news[0] = __olds[0];
              __news[1] = __olds[1];
              __mod += 2;
              __news += 2;
              __beg = __pads;
              __beglen = __plen;
              __end = const_cast<_CharT*>(__olds + __mod);
            }
          else if (__testsign)
            {
              _Traits::eq((__news[0] = __olds[0]), __plus) ? __plus : __minus;
              ++__mod;
              ++__news;
              __beg = __pads;
              __beglen = __plen;
              __end = const_cast<_CharT*>(__olds + __mod);
            }
          else
            {

              __beg = __pads;
              __beglen = __plen;
              __end = const_cast<_CharT*>(__olds);
            }
        }
      else
        {

          __beg = __pads;
          __beglen = __plen;
          __end = const_cast<_CharT*>(__olds);
        }
      _Traits::copy(__news, __beg, __beglen);
      _Traits::copy(__news + __beglen, __end,
                          __newlen - __beglen - __mod);
    }

  template<typename _CharT>
    bool
    __verify_grouping(const basic_string<_CharT>& __grouping,
                      basic_string<_CharT>& __grouping_tmp)
    {
      int __i = 0;
      int __j = 0;
      const int __len = __grouping.size();
      const int __n = __grouping_tmp.size();
      bool __test = true;




      while (__test && __i < __n - 1)
        for (__j = 0; __test && __j < __len && __i < __n - 1; ++__j,++__i)
          __test &= __grouping[__j] == __grouping_tmp[__n - __i - 1];


      __j == __len ? __j = 0 : __j;
      __test &= __grouping[__j] >= __grouping_tmp[__n - __i - 1];
      return __test;
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
                   const char* __gbeg, const char* __gend,
                   const _CharT* __first, const _CharT* __last)
    {
      if (__last - __first > *__gbeg)
        {
          __s = __add_grouping(__s, __sep,
                               (__gbeg + 1 == __gend ? __gbeg : __gbeg + 1),
                               __gend, __first, __last - *__gbeg);
          __first = __last - *__gbeg;
          *__s++ = __sep;
        }
      do
        *__s++ = *__first++;
      while (__first != __last);
      return __s;
    }



  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_convert_int(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
                     char __modl, _ValueT __v) const
      {



        char __fbuf[16];
        _S_format_int(__io, __fbuf, __mod, __modl);


        int __cs_size = 64;
        char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
        int __len = __convert_from_v(__cs, __cs_size, __fbuf, __v,
                                     _S_c_locale);

        if (__len >= __cs_size)
          {
            __cs_size = __len + 1;
            __cs = static_cast<char*>(__builtin_alloca(__cs_size));
            __len = __convert_from_v(__cs, __cs_size, __fbuf, __v,
                                     _S_c_locale);
          }






        return _M_widen_int(__s, __io, __fill, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    _M_widen_float(_OutIter __s, ios_base& __io, _CharT __fill, char* __cs,
                   int __len) const
    {
      typedef char_traits<_CharT> __traits_type;


      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                                                           * __len));


      _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                                                            * __len * 2));
      __ctype.widen(__cs, __cs + __len, __ws);


      const _CharT* __p;
      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
      if (__p = __traits_type::find(__ws, __len, __ctype.widen('.')))
        __ws[__p - __ws] = __np.decimal_point();




      const string __grouping = __np.grouping();
      if (__grouping.size())
        {
          _CharT* __p2;
          int __declen = __p ? __p - __ws : __len;
          __p2 = __add_grouping(__ws2, __np.thousands_sep(),
                                __grouping.c_str(),
                                __grouping.c_str() + __grouping.size(),
                                __ws, __ws + __declen);
          int __newlen = __p2 - __ws2;


          if (__p)
            {
              __traits_type::copy(__p2, __p, __len - __declen);
              __newlen += __len - __declen;
            }


          __ws = __ws2;
          __len = __newlen;
        }

      return _M_insert(__s, __io, __fill, __ws, __len);
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    _M_widen_int(_OutIter __s, ios_base& __io, _CharT __fill, char* __cs,
                 int __len) const
    {


      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                                                           * __len));


      _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                                                            * __len * 2));
      __ctype.widen(__cs, __cs + __len, __ws);


      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
      const string __grouping = __np.grouping();
      if (__grouping.size())
        {





          streamsize __off = 0;
          const ios_base::fmtflags __basefield = __io.flags()
                                                 & ios_base::basefield;
          if ((__io.flags() & ios_base::showbase) && __len > 1)
            if (__basefield == ios_base::oct)
              {
                __off = 1;
                *__ws2 = *__ws;
              }
            else if (__basefield == ios_base::hex)
              {
                __off = 2;
                *__ws2 = *__ws;
                *(__ws2 + 1) = *(__ws + 1);
              }
          _CharT* __p;
          __p = __add_grouping(__ws2 + __off, __np.thousands_sep(),
                               __grouping.c_str(),
                               __grouping.c_str() + __grouping.size(),
                               __ws + __off, __ws + __len);
          __len = __p - __ws2;

          __ws = __ws2;
        }
      return _M_insert(__s, __io, __fill, __ws, __len);
    }



  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    _M_insert(_OutIter __s, ios_base& __io, _CharT __fill, const _CharT* __ws,
              int __len) const
    {
      typedef char_traits<_CharT> __traits_type;


      streamsize __w = __io.width();
      _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                                                            * __w));
      if (__w > static_cast<streamsize>(__len))
        {
          __pad<_CharT, __traits_type>::_S_pad(__io, __fill, __ws2, __ws,
                                               __w, __len, true);
          __len = static_cast<int>(__w);

          __ws = __ws2;
        }
      __io.width(0);



      return __write(__s, __ws, __len);
    }


  template<typename _CharT>
    __locale_cache<numpunct<_CharT> >::__locale_cache(const locale& __loc)
      : _M_truename(0), _M_falsename(0), _M_use_grouping(false),
        _M_grouping(0)
    {
      if (has_facet<numpunct<_CharT> >(__loc))
        {
          const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
          _M_decimal_point = __np.decimal_point();
          _M_thousands_sep = __np.thousands_sep();

          string_type __false = __np.falsename();
          _CharT* __falsename = new _CharT[__false.length() + 1];
          __false.copy(__falsename, __false.length());
          __falsename[__false.length()] = _CharT();
          _M_falsename = __falsename;

          string_type __true = __np.truename();
          _CharT* __truename = new _CharT[__true.length() + 1];
          __true.copy(__truename, __true.length());
          __truename[__true.length()] = _CharT();
          _M_truename = __truename;

          string __grouping = __np.grouping();
          char* __group = new char[__grouping.length() + 1];
          __grouping.copy(__group, __grouping.length());
          __group[__grouping.length()] = 0;
          _M_grouping = __group;

          _M_use_grouping = __grouping.length() != 0
            && __grouping.data()[0] != 0;
        }

      if (has_facet<ctype<_CharT> >(__loc))
        {
          const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
          __ct.widen(__num_base::_S_atoms_out,
                     __num_base::_S_atoms_out + __num_base::_S_end,
                     _M_atoms_out);
        }
    }



  template<typename _CharT>
    __locale_cache<numpunct<_CharT> >::
    __locale_cache(const locale& __loc, bool)
    {

      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
      _M_thousands_sep = __np._M_thousands_sep;
      _M_decimal_point = __np._M_decimal_point;
      _M_falsename = __np._M_falsename;
      _M_truename = __np._M_truename;
      _M_grouping = __np._M_grouping;
      _M_use_grouping = false;

      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
      __ct.widen(__num_base::_S_atoms_out,
                 __num_base::_S_atoms_out + __num_base::_S_end,
                 _M_atoms_out);
    }





  extern template class moneypunct<char, false>;
  extern template class moneypunct<char, true>;
  extern template class moneypunct_byname<char, false>;
  extern template class moneypunct_byname<char, true>;
  extern template class money_get<char>;
  extern template class money_put<char>;
  extern template class numpunct<char>;
  extern template class numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class __timepunct<char>;
  extern template class time_put<char>;
  extern template class time_put_byname<char>;
  extern template class time_get<char>;
  extern template class time_get_byname<char>;
  extern template class messages<char>;
  extern template class messages_byname<char>;
  extern template class ctype_byname<char>;
  extern template class codecvt_byname<char, char, mbstate_t>;
  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const codecvt<char, char, mbstate_t>&
    use_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    const moneypunct<char, true>&
    use_facet<moneypunct<char, true> >(const locale&);

  extern template
    const moneypunct<char, false>&
    use_facet<moneypunct<char, false> >(const locale&);

  extern template
    const money_put<char>&
    use_facet<money_put<char> >(const locale&);

  extern template
    const money_get<char>&
    use_facet<money_get<char> >(const locale&);

  extern template
    const __timepunct<char>&
    use_facet<__timepunct<char> >(const locale&);

  extern template
    const time_put<char>&
    use_facet<time_put<char> >(const locale&);

  extern template
    const time_get<char>&
    use_facet<time_get<char> >(const locale&);

  extern template
    const messages<char>&
    use_facet<messages<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<char> >(const locale&);

  extern template
    bool
    has_facet<money_put<char> >(const locale&);

  extern template
    bool
    has_facet<money_get<char> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<char> >(const locale&);

  extern template
    bool
    has_facet<time_put<char> >(const locale&);

  extern template
    bool
    has_facet<time_get<char> >(const locale&);

  extern template
    bool
    has_facet<messages<char> >(const locale&);


  extern template class moneypunct<wchar_t, false>;
  extern template class moneypunct<wchar_t, true>;
  extern template class moneypunct_byname<wchar_t, false>;
  extern template class moneypunct_byname<wchar_t, true>;
  extern template class money_get<wchar_t>;
  extern template class money_put<wchar_t>;
  extern template class numpunct<wchar_t>;
  extern template class numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class __timepunct<wchar_t>;
  extern template class time_put<wchar_t>;
  extern template class time_put_byname<wchar_t>;
  extern template class time_get<wchar_t>;
  extern template class time_get_byname<wchar_t>;
  extern template class messages<wchar_t>;
  extern template class messages_byname<wchar_t>;
  extern template class ctype_byname<wchar_t>;
  extern template class codecvt_byname<wchar_t, char, mbstate_t>;
  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const codecvt<wchar_t, char, mbstate_t>&
    use_facet<codecvt<wchar_t, char, mbstate_t> >(locale const&);

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

  extern template
    const moneypunct<wchar_t, true>&
    use_facet<moneypunct<wchar_t, true> >(const locale&);

  extern template
    const moneypunct<wchar_t, false>&
    use_facet<moneypunct<wchar_t, false> >(const locale&);

  extern template
    const money_put<wchar_t>&
    use_facet<money_put<wchar_t> >(const locale&);

  extern template
    const money_get<wchar_t>&
    use_facet<money_get<wchar_t> >(const locale&);

  extern template
    const __timepunct<wchar_t>&
    use_facet<__timepunct<wchar_t> >(const locale&);

  extern template
    const time_put<wchar_t>&
    use_facet<time_put<wchar_t> >(const locale&);

  extern template
    const time_get<wchar_t>&
    use_facet<time_get<wchar_t> >(const locale&);

  extern template
    const messages<wchar_t>&
    use_facet<messages<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<money_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<money_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<time_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<time_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<messages<wchar_t> >(const locale&);


}
# 48 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/locale" 2 3
# 38 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/ostream.tcc" 2 3

namespace std
{
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT,_Traits>& __os)
    : _M_os(__os)
    {

      if (__os.tie() && __os.good())
        __os.tie()->flush();

      if (__os.good())
        _M_ok = true;
      else
        {
          _M_ok = false;
          __os.setstate(ios_base::failbit);
        }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__ostream_type& (*__pf)(__ostream_type&))
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          try
            { __pf(*this); }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__ios_type& (*__pf)(__ios_type&))
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          try
            { __pf(*this); }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(ios_base& (*__pf)(ios_base&))
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          try
            { __pf(*this); }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::operator<<(__streambuf_type* __sbin)
    {
      sentry __cerb(*this);
      if (__cerb && __sbin)
        {
          try
            {
              if (!__copy_streambufs(*this, __sbin, this->rdbuf()))
                this->setstate(ios_base::failbit);
            }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      else if (!__sbin)
        this->setstate(ios_base::badbit);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::operator<<(bool __n)
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          try
            {
              if (_M_check_facet(_M_fnumput))
                if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())
                  this->setstate(ios_base::badbit);
            }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::operator<<(long __n)
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          try
            {
              char_type __c = this->fill();
              ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
              if (_M_check_facet(_M_fnumput))
                {
                  bool __b = false;
                  if ((__fmt & ios_base::oct) || (__fmt & ios_base::hex))
                    {
                      unsigned long __l = static_cast<unsigned long>(__n);
                      __b = _M_fnumput->put(*this, *this, __c, __l).failed();
                    }
                  else
                    __b = _M_fnumput->put(*this, *this, __c, __n).failed();
                  if (__b)
                    this->setstate(ios_base::badbit);
                }
            }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::operator<<(unsigned long __n)
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          try
            {
              if (_M_check_facet(_M_fnumput))
                if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())
                  this->setstate(ios_base::badbit);
            }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::operator<<(long long __n)
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          try
            {
              char_type __c = this->fill();
              ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
              if (_M_check_facet(_M_fnumput))
                {
                  bool __b = false;
                  if ((__fmt & ios_base::oct) || (__fmt & ios_base::hex))
                    {
                      unsigned long long __l;
                      __l = static_cast<unsigned long long>(__n);
                      __b = _M_fnumput->put(*this, *this, __c, __l).failed();
                    }
                  else
                    __b = _M_fnumput->put(*this, *this, __c, __n).failed();
                  if (__b)
                    this->setstate(ios_base::badbit);
                }
            }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::operator<<(unsigned long long __n)
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          try
            {
              if (_M_check_facet(_M_fnumput))
                if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())
                  this->setstate(ios_base::badbit);
            }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::operator<<(double __n)
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          try
            {
              if (_M_check_facet(_M_fnumput))
                if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())
                  this->setstate(ios_base::badbit);
            }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::operator<<(long double __n)
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          try
            {
              if (_M_check_facet(_M_fnumput))
                if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())
                  this->setstate(ios_base::badbit);
            }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::operator<<(const void* __n)
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          try
            {
              if (_M_check_facet(_M_fnumput))
                if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())
                  this->setstate(ios_base::badbit);
            }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::put(char_type __c)
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          int_type __put = rdbuf()->sputc(__c);
          if (traits_type::eq_int_type(__put, traits_type::eof()))
            this->setstate(ios_base::badbit);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::write(const _CharT* __s, streamsize __n)
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          streamsize __put = this->rdbuf()->sputn(__s, __n);
          if ( __put != __n)
            this->setstate(ios_base::badbit);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::flush()
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
            this->setstate(ios_base::badbit);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::tellp()
    {
      pos_type __ret = pos_type(-1);
      if (!this->fail())
        __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
      return __ret;
    }


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::seekp(pos_type __pos)
    {
      if (!this->fail())
        {


          pos_type __err = this->rdbuf()->pubseekpos(__pos, ios_base::out);


          if (__err == pos_type(off_type(-1)))
            this->setstate(ios_base::failbit);

        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __d)
    {
      if (!this->fail())
        {


          pos_type __err = this->rdbuf()->pubseekoff(__off, __d,
                                                     ios_base::out);


          if (__err == pos_type(off_type(-1)))
            this->setstate(ios_base::failbit);

        }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
        {
          try
            {
              const streamsize __w = __out.width() > 0 ? __out.width() : 0;
              _CharT* __pads = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * (__w + 1)));
              __pads[0] = __c;
              streamsize __len = 1;
              if (__w > __len)
                {
                  __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __pads,
                                                 &__c, __w, __len, false);
                  __len = __w;
                }
              __out.write(__pads, __len);
              __out.width(0);
            }
          catch(...)
            {


              __out._M_setstate(ios_base::badbit);
              if ((__out.exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return __out;
    }


  template <class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    {
      typedef basic_ostream<char, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
        {
          try
            {
              const streamsize __w = __out.width() > 0 ? __out.width() : 0;
              char* __pads = static_cast<char*>(__builtin_alloca(__w + 1));
              __pads[0] = __c;
              streamsize __len = 1;
              if (__w > __len)
                {
                  __pad<char, _Traits>::_S_pad(__out, __out.fill(), __pads,
                                               &__c, __w, __len, false);
                  __len = __w;
                }
              __out.write(__pads, __len);
              __out.width(0);
            }
          catch(...)
            {


              __out._M_setstate(ios_base::badbit);
              if ((__out.exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return __out;
     }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb && __s)
        {
          try
            {
              const streamsize __w = __out.width() > 0 ? __out.width() : 0;
              _CharT* __pads = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __w));
              streamsize __len = static_cast<streamsize>(_Traits::length(__s));
              if (__w > __len)
                {
                  __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __pads,
                                                 __s, __w, __len, false);
                  __s = __pads;
                  __len = __w;
                }
              __out.write(__s, __len);
              __out.width(0);
            }
          catch(...)
            {


              __out._M_setstate(ios_base::badbit);
              if ((__out.exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      else if (!__s)
        __out.setstate(ios_base::badbit);
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;



      typedef char_traits<char> __traits_type;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb && __s)
        {
          size_t __clen = __traits_type::length(__s);
          _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * (__clen + 1)));
          for (size_t __i = 0; __i < __clen; ++__i)
            __ws[__i] = __out.widen(__s[__i]);
          _CharT* __str = __ws;

          try
            {
              streamsize __len = static_cast<streamsize>(__clen);
              const streamsize __w = __out.width() > 0 ? __out.width() : 0;
              _CharT* __pads = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __w));

              if (__w > __len)
                {
                  __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __pads,
                                                 __ws, __w, __len, false);
                  __str = __pads;
                  __len = __w;
                }
              __out.write(__str, __len);
              __out.width(0);
            }
          catch(...)
            {


              __out._M_setstate(ios_base::badbit);
              if ((__out.exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      else if (!__s)
        __out.setstate(ios_base::badbit);
      return __out;
    }


  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      typedef basic_ostream<char, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb && __s)
        {
          try
            {
              const streamsize __w = __out.width() > 0 ? __out.width() : 0;
              char* __pads = static_cast<char*>(__builtin_alloca(__w));
              streamsize __len = static_cast<streamsize>(_Traits::length(__s));

              if (__w > __len)
                {
                  __pad<char, _Traits>::_S_pad(__out, __out.fill(), __pads,
                                                 __s, __w, __len, false);
                  __s = __pads;
                  __len = __w;
                }
              __out.write(__s, __len);
              __out.width(0);
            }
          catch(...)
            {


              __out._M_setstate(ios_base::badbit);
              if ((__out.exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      else if (!__s)
        __out.setstate(ios_base::badbit);
      return __out;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out,
               const basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
        {
          const _CharT* __s = __str.data();
          const streamsize __w = __out.width() > 0 ? __out.width() : 0;
          _CharT* __pads = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __w));
          streamsize __len = static_cast<streamsize>(__str.size());



          if (__w > __len)
            {
              __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __pads, __s,
                                             __w, __len, false);
              __s = __pads;
              __len = __w;
            }
          streamsize __res = __out.rdbuf()->sputn(__s, __len);
          __out.width(0);
          if (__res != __len)
            __out.setstate(ios_base::failbit);
        }
      return __out;
    }





  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);


}
# 536 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ostream" 2 3
# 46 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/iostream" 2 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 1 3
# 43 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 3




namespace std
{
# 57 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef istreambuf_iterator<_CharT, _Traits> __istreambuf_iter;
      typedef num_get<_CharT, __istreambuf_iter> __numget_type;
      typedef ctype<_CharT> __ctype_type;

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

    protected:







      streamsize _M_gcount;

    public:
# 103 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 3
      explicit
      basic_istream(__streambuf_type* __sb)
      {
        this->init(__sb);
        _M_gcount = streamsize(0);
      }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 133 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&));

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&));

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&));
# 171 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 3
      __istream_type&
      operator>>(bool& __n);

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n);

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n);

      __istream_type&
      operator>>(long& __n);

      __istream_type&
      operator>>(unsigned long& __n);


      __istream_type&
      operator>>(long long& __n);

      __istream_type&
      operator>>(unsigned long long& __n);


      __istream_type&
      operator>>(float& __f);

      __istream_type&
      operator>>(double& __f);

      __istream_type&
      operator>>(long double& __f);

      __istream_type&
      operator>>(void*& __p);
# 232 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 242 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 3
      inline streamsize
      gcount() const
      { return _M_gcount; }
# 274 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 3
      int_type
      get();
# 288 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 3
      __istream_type&
      get(char_type& __c);
# 315 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 326 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 3
      inline __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 349 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 359 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 3
      inline __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 388 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 399 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 3
      inline __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 418 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 3
      __istream_type&
      ignore(streamsize __n = 1, int_type __delim = traits_type::eof());
# 429 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 3
      int_type
      peek();
# 447 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 466 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 482 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 3
      __istream_type&
      putback(char_type __c);
# 497 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 3
      __istream_type&
      unget();
# 515 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 3
      int
      sync();
# 529 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 3
      pos_type
      tellg();
# 544 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 3
      __istream_type&
      seekg(pos_type);
# 560 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);

    };
# 576 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {
    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 608 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 618 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 3
      operator bool() { return _M_ok; }

    private:
      bool _M_ok;
    };
# 637 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
# 678 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);

  template<class _Traits>
    basic_istream<char,_Traits>&
    operator>>(basic_istream<char,_Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    basic_istream<char,_Traits>&
    operator>>(basic_istream<char,_Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
# 700 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;



      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb)
      { }




      virtual
      ~basic_iostream() { }
    };
# 759 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);
}





# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/istream.tcc" 1 3
# 36 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/istream.tcc" 3




namespace std
{
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskipws)
    {
      if (__in.good())
        {
          if (__in.tie())
            __in.tie()->flush();
          if (!__noskipws && (__in.flags() & ios_base::skipws))
            {
              const __int_type __eof = traits_type::eof();
              __streambuf_type* __sb = __in.rdbuf();
              __int_type __c = __sb->sgetc();

              if (__in._M_check_facet(__in._M_fctype))
                while (!traits_type::eq_int_type(__c, __eof)
                       && __in._M_fctype->is(ctype_base::space,
                                             traits_type::to_char_type(__c)))
                  __c = __sb->snextc();



              if (traits_type::eq_int_type(__c, __eof))
                __in.setstate(ios_base::eofbit);

            }
        }

      if (__in.good())
        _M_ok = true;
      else
        {
          _M_ok = false;
          __in.setstate(ios_base::failbit);
        }
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__istream_type& (*__pf)(__istream_type&))
    {
      __pf(*this);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__ios_type& (*__pf)(__ios_type&))
    {
      __pf(*this);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(ios_base& (*__pf)(ios_base&))
    {
      __pf(*this);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(bool& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          try
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __n);
              this->setstate(__err);
            }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          try
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              long __l;
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __l);


              if (!(__err & ios_base::failbit)
                  && (numeric_limits<short>::min() <= __l
                      && __l <= numeric_limits<short>::max()))
                __n = __l;
              else
                __err |= ios_base::failbit;

              this->setstate(__err);
            }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(unsigned short& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          try
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __n);
              this->setstate(__err);
            }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          try
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              long __l;
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __l);


              if (!(__err & ios_base::failbit)
                  && (numeric_limits<int>::min() <= __l
                      && __l <= numeric_limits<int>::max()))
                __n = __l;
              else
                __err |= ios_base::failbit;

              this->setstate(__err);
            }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(unsigned int& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          try
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __n);
              this->setstate(__err);
            }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(long& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          try
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __n);
              this->setstate(__err);
            }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(unsigned long& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          try
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __n);
              this->setstate(__err);
            }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(long long& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          try
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __n);
              this->setstate(__err);
            }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
              throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(unsigned long long& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          try
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __n);
              this->setstate(__err);
            }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(float& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          try
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __n);
              this->setstate(__err);
            }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(double& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          try
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __n);
              this->setstate(__err);
            }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(long double& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          try
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __n);
              this->setstate(__err);
            }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(void*& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          try
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __n);
              this->setstate(__err);
            }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
       sentry __cerb(*this, false);
       if (__cerb)
         {
           try
             {
               streamsize __xtrct = 0;
               if (__sbout)
                 {
                   __streambuf_type* __sbin = this->rdbuf();
                   __xtrct = __copy_streambufs(*this, __sbin, __sbout);
                 }
               if (!__sbout || !__xtrct)
                 this->setstate(ios_base::failbit);
             }
           catch(...)
             {


               this->_M_setstate(ios_base::badbit);
               if ((this->exceptions() & ios_base::badbit) != 0)
                 throw;
             }
         }
       return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              __c = this->rdbuf()->sbumpc();

              if (!traits_type::eq_int_type(__c, __eof))
                _M_gcount = 1;
              else
                this->setstate(ios_base::eofbit | ios_base::failbit);
            }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __eof = traits_type::eof();
              int_type __bufval = this->rdbuf()->sbumpc();

              if (!traits_type::eq_int_type(__bufval, __eof))
                {
                  _M_gcount = 1;
                  __c = traits_type::to_char_type(__bufval);
                }
              else
                this->setstate(ios_base::eofbit | ios_base::failbit);
            }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                this->setstate(ios_base::eofbit);
            }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      *__s = char_type();
      if (!_M_gcount)
        this->setstate(ios_base::failbit);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __this_sb = this->rdbuf();
              int_type __c = __this_sb->sgetc();
              char_type __c2 = traits_type::to_char_type(__c);

              while (!traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim)
                     && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
                {
                  ++_M_gcount;
                  __c = __this_sb->snextc();
                  __c2 = traits_type::to_char_type(__c);
                }
              if (traits_type::eq_int_type(__c, __eof))
                this->setstate(ios_base::eofbit);
            }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      if (!_M_gcount)
        this->setstate(ios_base::failbit);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                this->setstate(ios_base::eofbit);
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    this->setstate(ios_base::failbit);
                }
            }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      *__s = char_type();
      if (!_M_gcount)
        this->setstate(ios_base::failbit);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c;

              __n = min(__n, numeric_limits<streamsize>::max());
              while (_M_gcount < __n
                     && !traits_type::eq_int_type(__c = __sb->sbumpc(), __eof))
                {
                  ++_M_gcount;
                  if (traits_type::eq_int_type(__c, __delim))
                    break;
                }
              if (traits_type::eq_int_type(__c, __eof))
                this->setstate(ios_base::eofbit);
            }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            { __c = this->rdbuf()->sgetc(); }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              _M_gcount = this->rdbuf()->sgetn(__s, __n);
              if (_M_gcount != __n)
                this->setstate(ios_base::eofbit | ios_base::failbit);
            }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      else
        this->setstate(ios_base::failbit);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {

              streamsize __num = this->rdbuf()->in_avail();
              if (__num >= 0)
                {
                  __num = min(__num, __n);
                  if (__num)
                    _M_gcount = this->rdbuf()->sgetn(__s, __num);
                }
              else
                this->setstate(ios_base::eofbit);
            }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      else
        this->setstate(ios_base::failbit);
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;

      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              if (!__sb
                  || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
                this->setstate(ios_base::badbit);
            }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      else
        this->setstate(ios_base::failbit);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;

      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              if (!__sb
                  || traits_type::eq_int_type(__sb->sungetc(), __eof))
                this->setstate(ios_base::badbit);
            }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      else
        this->setstate(ios_base::failbit);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {

      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              __streambuf_type* __sb = this->rdbuf();
              if (__sb)
                {
                  if (__sb->pubsync() == -1)
                    this->setstate(ios_base::badbit);
                  else
                    __ret = 0;
                }
            }
          catch(...)
            {


              this->_M_setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {

      pos_type __ret = pos_type(-1);
      if (!this->fail())
        __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);
      return __ret;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {

      if (!this->fail())
        {


          pos_type __err = this->rdbuf()->pubseekpos(__pos, ios_base::in);


          if (__err == pos_type(off_type(-1)))
            this->setstate(ios_base::failbit);

        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {

      if (!this->fail())
        {


          pos_type __err = this->rdbuf()->pubseekoff(__off, __dir,
                                                     ios_base::in);


          if (__err == pos_type(off_type(-1)))
            this->setstate(ios_base::failbit);

        }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
        {
          try
            { __in.get(__c); }
          catch(...)
            {


              __in._M_setstate(ios_base::badbit);
              if ((__in.exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      else
        __in.setstate(ios_base::failbit);
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;
      streamsize __extracted = 0;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
        {
          try
            {

              streamsize __num = __in.width();
              if (__num <= 0)
                __num = numeric_limits<streamsize>::max();

              const __ctype_type& __ctype = use_facet<__ctype_type>(__in.getloc());
              const int_type __eof = _Traits::eof();
              __streambuf_type* __sb = __in.rdbuf();
              int_type __c = __sb->sgetc();

              while (__extracted < __num - 1
                     && !_Traits::eq_int_type(__c, __eof)
                     && !__ctype.is(ctype_base::space, _Traits::to_char_type(__c)))
                {
                  *__s++ = _Traits::to_char_type(__c);
                  ++__extracted;
                  __c = __sb->snextc();
                }
              if (_Traits::eq_int_type(__c, __eof))
                __in.setstate(ios_base::eofbit);



              *__s = char_type();

              __in.width(0);
            }
          catch(...)
            {


              __in._M_setstate(ios_base::badbit);
              if ((__in.exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      if (!__extracted)
        __in.setstate(ios_base::failbit);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT,_Traits>&
    ws(basic_istream<_CharT,_Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename __istream_type::int_type __int_type;

      const __ctype_type& __ctype = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
             && __ctype.is(ctype_base::space, _Traits::to_char_type(__c)))
        __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
        __in.setstate(ios_base::eofbit);

      return __in;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
               basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __size_type __extracted = 0;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
        {
          __str.erase();
          streamsize __w = __in.width();
          __size_type __n;
          __n = __w > 0 ? static_cast<__size_type>(__w) : __str.max_size();

          const __ctype_type& __ctype = use_facet<__ctype_type>(__in.getloc());
          const __int_type __eof = _Traits::eof();
          __streambuf_type* __sb = __in.rdbuf();
          __int_type __c = __sb->sgetc();

          while (__extracted < __n
                 && !_Traits::eq_int_type(__c, __eof)
                 && !__ctype.is(ctype_base::space, _Traits::to_char_type(__c)))
            {
              __str += _Traits::to_char_type(__c);
              ++__extracted;
              __c = __sb->snextc();
            }
          if (_Traits::eq_int_type(__c, __eof))
            __in.setstate(ios_base::eofbit);
          __in.width(0);
        }


      if (!__extracted)
        __in.setstate (ios_base::failbit);

      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
            basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      bool __testdelim = false;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
        {
          __str.erase();
          __size_type __n = __str.max_size();

          __int_type __idelim = _Traits::to_int_type(__delim);
          __streambuf_type* __sb = __in.rdbuf();
          __int_type __c = __sb->sbumpc();
          const __int_type __eof = _Traits::eof();
          __testdelim = _Traits::eq_int_type(__c, __idelim);

          while (__extracted <= __n
                 && !_Traits::eq_int_type(__c, __eof)
                 && !__testdelim)
            {
              __str += _Traits::to_char_type(__c);
              ++__extracted;
              __c = __sb->sbumpc();
              __testdelim = _Traits::eq_int_type(__c, __idelim);
            }
          if (_Traits::eq_int_type(__c, __eof))
            __in.setstate(ios_base::eofbit);
        }
      if (!__extracted && !__testdelim)
        __in.setstate(ios_base::failbit);
      return __in;
    }

  template<class _CharT, class _Traits, class _Alloc>
    inline basic_istream<_CharT,_Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
            basic_string<_CharT,_Traits,_Alloc>& __str)
    { return getline(__in, __str, __in.widen('\n')); }





  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);


}
# 769 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/istream" 2 3
# 47 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/iostream" 2 3

namespace std
{
# 63 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/iostream" 3
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;


  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;




  static ios_base::Init __ioinit;
}
# 23 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/common/definitions.h" 2
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/fstream" 1 3
# 44 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/fstream" 3




# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/basic_file.h" 1 3
# 43 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/i686-pc-linux-gnu/bits/basic_file.h" 3




namespace std
{

  template<typename _CharT>
    class __basic_file;


  template<>
    class __basic_file<char>
    {

      __c_file* _M_cfile;

      bool _M_cfile_created;

    public:
      __basic_file(__c_lock* __lock = 0);

      void
      _M_open_mode(ios_base::openmode __mode, int& __p_mode, int& __rw_mode,
                   char* __c_mode);

      __basic_file*
      open(const char* __name, ios_base::openmode __mode, int __prot = 0664);

      __basic_file*
      sys_open(__c_file* __file, ios_base::openmode);

      __basic_file*
      sys_open(int __fd, ios_base::openmode __mode, bool __del);

      int
      sys_getc();

      int
      sys_ungetc(int);

      __basic_file*
      close();

      bool
      is_open() const;

      int
      fd();

      ~__basic_file();

      streamsize
      xsputn(const char* __s, streamsize __n);

      streamsize
      xsgetn(char* __s, streamsize __n);

      streamoff
      seekoff(streamoff __off, ios_base::seekdir __way,
              ios_base::openmode __mode = ios_base::in | ios_base::out);

      streamoff
      seekpos(streamoff __pos,
              ios_base::openmode __mode = ios_base::in | ios_base::out);

      int
      sync();

      streamsize
      showmanyc_helper();
    };
}
# 49 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/fstream" 2 3


namespace std
{
# 62 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_filebuf : public basic_streambuf<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;







      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef __basic_file<char> __file_type;
      typedef typename traits_type::state_type __state_type;
      typedef codecvt<char_type, char, __state_type> __codecvt_type;
      typedef ctype<char_type> __ctype_type;


      friend class ios_base;

    protected:







      __c_lock _M_lock;







      __file_type _M_file;







      __state_type _M_state_cur;
      __state_type _M_state_beg;







      bool _M_buf_allocated;


      bool _M_last_overflowed;
# 134 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/fstream" 3
      char_type* _M_filepos;

    public:







      basic_filebuf();




      virtual
      ~basic_filebuf()
      {
        this->close();
        _M_last_overflowed = false;
      }





      bool
      is_open() const throw() { return _M_file.is_open(); }
# 176 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/fstream" 3
      __filebuf_type*
      open(const char* __s, ios_base::openmode __mode);
# 190 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/fstream" 3
      __filebuf_type*
      close() throw();

    protected:





      void
      _M_allocate_internal_buffer();






      void
      _M_destroy_internal_buffer() throw();



      virtual streamsize
      showmanyc();
# 231 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/fstream" 3
      int_type
      _M_underflow_common(bool __bump);


      virtual int_type
      underflow();


      virtual int_type
      uflow();


      virtual int_type
      pbackfail(int_type __c = _Traits::eof());
# 256 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/fstream" 3
      virtual int_type
      overflow(int_type __c = _Traits::eof());
# 271 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/fstream" 3
      int_type
      _M_really_overflow(int_type __c = _Traits::eof());
# 281 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/fstream" 3
      void
      _M_convert_to_external(char_type*, streamsize, streamsize&, streamsize&);
# 296 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/fstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n);


      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
              ios_base::openmode __mode = ios_base::in | ios_base::out);


      virtual pos_type
      seekpos(pos_type __pos,
              ios_base::openmode __mode = ios_base::in | ios_base::out);


      virtual int
      sync()
      {
        int __ret = 0;
        bool __testput = _M_out_cur && _M_out_beg < _M_out_end;



        if (__testput)
          {

            off_type __off = _M_out_cur - _M_out_end;


            if (traits_type::eq_int_type(_M_really_overflow(),
                                         traits_type::eof()))
              __ret = -1;
            else if (__off)
              _M_file.seekoff(__off, ios_base::cur);
          }
        else
          _M_file.sync();

        _M_last_overflowed = false;
        return __ret;
      }


      virtual void
      imbue(const locale& __loc);


      virtual streamsize
      xsgetn(char_type* __s, streamsize __n)
      {
        streamsize __ret = 0;

        if (_M_pback_init)
          {
            while (__ret < __n && _M_in_cur < _M_in_end)
              {
                *__s = *_M_in_cur;
                ++__ret;
                ++__s;
                ++_M_in_cur;
              }
            _M_pback_destroy();
          }
        if (__ret < __n)
          __ret += __streambuf_type::xsgetn(__s, __n - __ret);
        return __ret;
      }


      virtual streamsize
      xsputn(const char_type* __s, streamsize __n)
      {
        _M_pback_destroy();
        return __streambuf_type::xsputn(__s, __n);
      }






      void
      _M_output_unshift();
# 391 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/fstream" 3
      void
      _M_set_indeterminate(void)
      {
        if (_M_mode & ios_base::in)
          this->setg(_M_buf, _M_buf, _M_buf);
        if (_M_mode & ios_base::out)
          this->setp(_M_buf, _M_buf);
        _M_filepos = _M_buf;
      }






      void
      _M_set_determinate(off_type __off)
      {
        bool __testin = _M_mode & ios_base::in;
        bool __testout = _M_mode & ios_base::out;
        if (__testin)
          this->setg(_M_buf, _M_buf, _M_buf + __off);
        if (__testout)
          this->setp(_M_buf, _M_buf + __off);
        _M_filepos = _M_buf + __off;
      }






      bool
      _M_is_indeterminate(void)
      {
        bool __ret = false;

        if (_M_buf)
          {
            if (_M_mode & ios_base::in)
              __ret = _M_in_beg == _M_in_cur && _M_in_cur == _M_in_end;
            if (_M_mode & ios_base::out)
              __ret = _M_out_beg == _M_out_cur && _M_out_cur == _M_out_end;
          }
        return __ret;
      }
    };


  template<>
    basic_filebuf<char>::int_type
    basic_filebuf<char>::_M_underflow_common(bool __bump);


  template<>
    basic_filebuf<wchar_t>::int_type
    basic_filebuf<wchar_t>::_M_underflow_common(bool __bump);



  template <typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::underflow()
    { return _M_underflow_common(false); }

  template <typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::uflow()
    { return _M_underflow_common(true); }
# 471 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_ifstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:





      __filebuf_type _M_filebuf;

    public:
# 503 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/fstream" 3
      basic_ifstream()
      : __istream_type(__null), _M_filebuf()
      { this->init(&_M_filebuf); }
# 517 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/fstream" 3
      explicit
      basic_ifstream(const char* __s, ios_base::openmode __mode = ios_base::in)
      : __istream_type(__null), _M_filebuf()
      {
        this->init(&_M_filebuf);
        this->open(__s, __mode);
      }







      ~basic_ifstream()
      { }
# 541 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open() { return _M_filebuf.is_open(); }
# 563 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/fstream" 3
      void
      open(const char* __s, ios_base::openmode __mode = ios_base::in)
      {
        if (!_M_filebuf.open(__s, __mode | ios_base::in))
          this->setstate(ios_base::failbit);
      }







      void
      close()
      {
        if (!_M_filebuf.close())
          this->setstate(ios_base::failbit);
      }
    };
# 594 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_ofstream : public basic_ostream<_CharT,_Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:





      __filebuf_type _M_filebuf;

    public:
# 626 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/fstream" 3
      basic_ofstream()
      : __ostream_type(__null), _M_filebuf()
      { this->init(&_M_filebuf); }
# 641 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/fstream" 3
      explicit
      basic_ofstream(const char* __s,
                     ios_base::openmode __mode = ios_base::out|ios_base::trunc)
      : __ostream_type(__null), _M_filebuf()
      {
        this->init(&_M_filebuf);
        this->open(__s, __mode);
      }







      ~basic_ofstream()
      { }
# 666 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open() { return _M_filebuf.is_open(); }
# 688 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/fstream" 3
      void
      open(const char* __s,
           ios_base::openmode __mode = ios_base::out | ios_base::trunc)
      {
        if (!_M_filebuf.open(__s, __mode | ios_base::out))
          this->setstate(ios_base::failbit);
      }







      void
      close()
      {
        if (!_M_filebuf.close())
          this->setstate(ios_base::failbit);
      }
    };
# 720 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_fstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_ios<char_type, traits_type> __ios_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:





      __filebuf_type _M_filebuf;

    public:
# 753 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/fstream" 3
      basic_fstream()
      : __iostream_type(__null), _M_filebuf()
      { this->init(&_M_filebuf); }
# 765 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/fstream" 3
      explicit
      basic_fstream(const char* __s,
                    ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __iostream_type(__null), _M_filebuf()
      {
        this->init(&_M_filebuf);
        this->open(__s, __mode);
      }







      ~basic_fstream()
      { }
# 790 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open() { return _M_filebuf.is_open(); }
# 812 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/fstream" 3
      void
      open(const char* __s,
           ios_base::openmode __mode = ios_base::in | ios_base::out)
      {
        if (!_M_filebuf.open(__s, __mode))
          setstate(ios_base::failbit);
      }







      void
      close()
      {
        if (!_M_filebuf.close())
          setstate(ios_base::failbit);
      }
    };
}





# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/fstream.tcc" 1 3
# 39 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/fstream.tcc" 3

namespace std
{
  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    _M_allocate_internal_buffer()
    {
      if (!_M_buf && _M_buf_size_opt)
        {
          _M_buf_size = _M_buf_size_opt;


          _M_buf = new char_type[_M_buf_size];
          _M_buf_allocated = true;
        }
    }


  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    _M_destroy_internal_buffer() throw()
    {
      if (_M_buf_allocated)
        {
          delete [] _M_buf;
          _M_buf = __null;
          _M_buf_allocated = false;
          this->setg(__null, __null, __null);
          this->setp(__null, __null);
        }
    }

  template<typename _CharT, typename _Traits>
    basic_filebuf<_CharT, _Traits>::
    basic_filebuf() : __streambuf_type(), _M_file(&_M_lock),
    _M_state_cur(__state_type()), _M_state_beg(__state_type()),
    _M_buf_allocated(false), _M_last_overflowed(false)
    { _M_buf_unified = true; }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__filebuf_type*
    basic_filebuf<_CharT, _Traits>::
    open(const char* __s, ios_base::openmode __mode)
    {
      __filebuf_type *__ret = __null;
      if (!this->is_open())
        {
          _M_file.open(__s, __mode);
          if (this->is_open())
            {
              _M_allocate_internal_buffer();
              _M_mode = __mode;


              _M_set_indeterminate();

              if ((__mode & ios_base::ate)
                  && this->seekoff(0, ios_base::end, __mode) < 0)
                {

                  this->close();
                  return __ret;
                }

              __ret = this;
            }
        }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__filebuf_type*
    basic_filebuf<_CharT, _Traits>::
    close() throw()
    {
      __filebuf_type* __ret = __null;
      if (this->is_open())
        {
          bool __testfail = false;
          try
            {
              const int_type __eof = traits_type::eof();
              bool __testput = _M_out_cur && _M_out_beg < _M_out_end;
              if (__testput
                  && traits_type::eq_int_type(_M_really_overflow(__eof),
                                              __eof))
                __testfail = true;
# 137 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/fstream.tcc" 3
            }
          catch(...)
            {
              __testfail = true;
            }


          this->_M_mode = ios_base::openmode(0);
          _M_destroy_internal_buffer();
          _M_pback_destroy();

          if (!_M_file.close())
            __testfail = true;

          if (!__testfail)
            __ret = this;
        }
      _M_last_overflowed = false;
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    showmanyc()
    {
      streamsize __ret = -1;
      bool __testin = _M_mode & ios_base::in;
      const locale __loc = this->getloc();
      const __codecvt_type& __cvt = use_facet<__codecvt_type>(__loc);

      if (__testin && this->is_open())
        {
          __ret = _M_in_end - _M_in_cur;
          if (__cvt.always_noconv())
            __ret += _M_file.showmanyc_helper();
        }

      _M_last_overflowed = false;
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    pbackfail(int_type __i)
    {
      int_type __ret = traits_type::eof();
      bool __testin = _M_mode & ios_base::in;

      if (__testin)
        {
          bool __testpb = _M_in_beg < _M_in_cur;
          char_type __c = traits_type::to_char_type(__i);
          bool __testeof = traits_type::eq_int_type(__i, __ret);

          if (__testpb)
            {
              bool __testout = _M_mode & ios_base::out;
              bool __testeq = traits_type::eq(__c, this->gptr()[-1]);



              if (!__testeof && __testeq)
                {
                  --_M_in_cur;
                  if (__testout)
                    --_M_out_cur;
                  __ret = __i;
                }
              else if (__testeof)
                {
                  --_M_in_cur;
                  if (__testout)
                    --_M_out_cur;
                  __ret = traits_type::not_eof(__i);
                }
              else if (!__testeof)
                {
                  --_M_in_cur;
                  if (__testout)
                    --_M_out_cur;
                  _M_pback_create();
                  *_M_in_cur = __c;
                  __ret = __i;
                }
            }
          else
            {





              if (this->seekoff(-1, ios_base::cur) >= 0)
                {
                  this->underflow();
                  if (!__testeof)
                    {
                      if (!traits_type::eq(__c, *_M_in_cur))
                        {
                          _M_pback_create();
                          *_M_in_cur = __c;
                        }
                      __ret = __i;
                    }
                  else
                    __ret = traits_type::not_eof(__i);
                }
            }
        }
      _M_last_overflowed = false;
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    overflow(int_type __c)
    {
      int_type __ret = traits_type::eof();
      bool __testput = _M_out_cur && _M_out_cur < _M_buf + _M_buf_size;
      bool __testout = _M_mode & ios_base::out;

      if (__testout)
        {
          if (traits_type::eq_int_type(__c, traits_type::eof()))
            __ret = traits_type::not_eof(__c);
          else if (__testput)
            {
              *_M_out_cur = traits_type::to_char_type(__c);
              _M_out_cur_move(1);
              __ret = traits_type::not_eof(__c);
            }
          else
            __ret = this->_M_really_overflow(__c);
        }

      _M_last_overflowed = false;
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    _M_convert_to_external(_CharT* __ibuf, streamsize __ilen,
                           streamsize& __elen, streamsize& __plen)
    {
      const locale __loc = this->getloc();
      const __codecvt_type& __cvt = use_facet<__codecvt_type>(__loc);

      if (__cvt.always_noconv() && __ilen)
        {
          __elen += _M_file.xsputn(reinterpret_cast<char*>(__ibuf), __ilen);
          __plen += __ilen;
        }
      else
        {

          int __ext_multiplier = __cvt.encoding();
          if (__ext_multiplier == -1 || __ext_multiplier == 0)
            __ext_multiplier = sizeof(char_type);
          streamsize __blen = __ilen * __ext_multiplier;
          char* __buf = static_cast<char*>(__builtin_alloca(__blen));
          char* __bend;
          const char_type* __iend;
          codecvt_base::result __r;
          __r = __cvt.out(_M_state_cur, __ibuf, __ibuf + __ilen,
                          __iend, __buf, __buf + __blen, __bend);

          if (__r == codecvt_base::ok || __r == codecvt_base::partial)
            __blen = __bend - __buf;
          else if (__r == codecvt_base::noconv)
            {

              __buf = reinterpret_cast<char*>(__ibuf);
              __blen = __ilen;
            }
          else
            {

              __blen = 0;
            }

          if (__blen)
            {
              __elen += _M_file.xsputn(__buf, __blen);
              __plen += __blen;
            }


          if (__r == codecvt_base::partial)
            {
              const char_type* __iresume = __iend;
              streamsize __rlen = _M_out_end - __iend;
              __r = __cvt.out(_M_state_cur, __iresume, __iresume + __rlen,
                              __iend, __buf, __buf + __blen, __bend);
              if (__r != codecvt_base::error)
                {
                  __rlen = __bend - __buf;
                  __elen += _M_file.xsputn(__buf, __rlen);
                  __plen += __rlen;
                }
            }
        }
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    _M_really_overflow(int_type __c)
    {
      int_type __ret = traits_type::eof();
      bool __testput = _M_out_cur && _M_out_beg < _M_out_end;
      bool __testunbuffered = _M_file.is_open() && !_M_buf_size;

      if (__testput || __testunbuffered)
        {

          streamsize __elen = 0;
          streamsize __plen = 0;




          if (_M_filepos && _M_filepos != _M_out_beg)
            {
              off_type __off = _M_out_beg - _M_filepos;
              _M_file.seekoff(__off, ios_base::cur);
            }



          if (!__testunbuffered)
            _M_convert_to_external(_M_out_beg, _M_out_end - _M_out_beg,
                                   __elen, __plen);



          if (__testunbuffered || (__elen && __elen == __plen))
            {


              if (!traits_type::eq_int_type(__c, traits_type::eof()))
                {
                  char_type __pending = traits_type::to_char_type(__c);
                  _M_convert_to_external(&__pending, 1, __elen, __plen);



                  if (__elen == __plen && __elen)
                    {
                      _M_set_indeterminate();
                      __ret = traits_type::not_eof(__c);
                    }
                }
              else if (!_M_file.sync())
                {
                  _M_set_indeterminate();
                  __ret = traits_type::not_eof(__c);
                }
            }
        }
      _M_last_overflowed = true;
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__streambuf_type*
    basic_filebuf<_CharT, _Traits>::
    setbuf(char_type* __s, streamsize __n)
    {
      if (!this->is_open() && __s == 0 && __n == 0)
        _M_buf_size_opt = 0;
      else if (__s && __n)
        {





          _M_destroy_internal_buffer();


          _M_buf = __s;
          _M_buf_size_opt = _M_buf_size = __n;
          _M_set_indeterminate();
        }
      _M_last_overflowed = false;
      return this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      bool __testin = (ios_base::in & _M_mode & __mode) != 0;
      bool __testout = (ios_base::out & _M_mode & __mode) != 0;

      int __width = 0;
      if (has_facet<__codecvt_type>(this->_M_buf_locale))
          __width = use_facet<__codecvt_type>(this->_M_buf_locale).encoding();
      if (__width < 0)
        __width = 0;

      bool __testfail = __off != 0 && __width <= 0;
      if (this->is_open() && !__testfail && (__testin || __testout))
        {

          _M_pback_destroy();

          if (__way != ios_base::cur || __off != 0)
            {
              off_type __computed_off = __width * __off;

              bool __testget = _M_in_cur && _M_in_beg < _M_in_end;
              bool __testput = _M_out_cur && _M_out_beg < _M_out_end;


              if (__testput || _M_last_overflowed)
                {

                  this->sync();

                  _M_output_unshift();
                }

              else if (__testget && __way == ios_base::cur)
                __computed_off += _M_in_cur - _M_filepos;


              __ret = _M_file.seekoff(__computed_off, __way, __mode);
              _M_set_indeterminate();
            }


          else
            {
              pos_type __tmp =
                _M_file.seekoff(__off, ios_base::cur, __mode);
              if (__tmp >= 0)
                {

                  __ret = __tmp;
                  __ret += max(_M_out_cur, _M_in_cur) - _M_filepos;
                }
            }
        }
      _M_last_overflowed = false;
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    seekpos(pos_type __pos, ios_base::openmode __mode)
    {


      return this->seekoff(off_type(__pos), ios_base::beg, __mode);

    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    _M_output_unshift()
    { }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    imbue(const locale& __loc)
    {
      bool __testbeg = gptr() == eback() && pptr() == pbase();

      if (__testbeg && _M_buf_locale != __loc)
        _M_buf_locale = __loc;





      _M_last_overflowed = false;
    }





  extern template class basic_filebuf<char>;
  extern template class basic_ifstream<char>;
  extern template class basic_ofstream<char>;
  extern template class basic_fstream<char>;


  extern template class basic_filebuf<wchar_t>;
  extern template class basic_ifstream<wchar_t>;
  extern template class basic_ofstream<wchar_t>;
  extern template class basic_fstream<wchar_t>;


}
# 840 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/fstream" 2 3
# 24 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/common/definitions.h" 2



# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/map" 1 3
# 65 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/map" 3

# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_tree.h" 1 3
# 91 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_tree.h" 3
namespace std
{
  enum _Rb_tree_color { _M_red = false, _M_black = true };

  struct _Rb_tree_node_base
  {
    typedef _Rb_tree_node_base* _Base_ptr;

    _Rb_tree_color _M_color;
    _Base_ptr _M_parent;
    _Base_ptr _M_left;
    _Base_ptr _M_right;

    static _Base_ptr
    _S_minimum(_Base_ptr __x)
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Base_ptr
    _S_maximum(_Base_ptr __x)
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }
  };

  template<typename _Val>
    struct _Rb_tree_node : public _Rb_tree_node_base
    {
      typedef _Rb_tree_node<_Val>* _Link_type;
      _Val _M_value_field;
    };

  struct _Rb_tree_base_iterator
  {
    typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
    typedef bidirectional_iterator_tag iterator_category;
    typedef ptrdiff_t difference_type;

    _Base_ptr _M_node;

    void
    _M_increment()
    {
      if (_M_node->_M_right != 0)
        {
          _M_node = _M_node->_M_right;
          while (_M_node->_M_left != 0)
            _M_node = _M_node->_M_left;
        }
      else
        {
          _Base_ptr __y = _M_node->_M_parent;
          while (_M_node == __y->_M_right)
            {
              _M_node = __y;
              __y = __y->_M_parent;
            }
          if (_M_node->_M_right != __y)
            _M_node = __y;
        }
    }

    void
    _M_decrement()
    {
      if (_M_node->_M_color == _M_red
          && _M_node->_M_parent->_M_parent == _M_node)
        _M_node = _M_node->_M_right;
      else if (_M_node->_M_left != 0)
        {
          _Base_ptr __y = _M_node->_M_left;
          while (__y->_M_right != 0)
            __y = __y->_M_right;
          _M_node = __y;
        }
      else
        {
          _Base_ptr __y = _M_node->_M_parent;
          while (_M_node == __y->_M_left)
            {
              _M_node = __y;
              __y = __y->_M_parent;
            }
          _M_node = __y;
        }
    }
  };

  template<typename _Val, typename _Ref, typename _Ptr>
    struct _Rb_tree_iterator : public _Rb_tree_base_iterator
    {
      typedef _Val value_type;
      typedef _Ref reference;
      typedef _Ptr pointer;
      typedef _Rb_tree_iterator<_Val, _Val&, _Val*> iterator;
      typedef _Rb_tree_iterator<_Val, const _Val&, const _Val*>
      const_iterator;
      typedef _Rb_tree_iterator<_Val, _Ref, _Ptr> _Self;
      typedef _Rb_tree_node<_Val>* _Link_type;

      _Rb_tree_iterator() {}
      _Rb_tree_iterator(_Link_type __x) { _M_node = __x; }
      _Rb_tree_iterator(const iterator& __it) { _M_node = __it._M_node; }

      reference
      operator*() const { return _Link_type(_M_node)->_M_value_field; }

      pointer
      operator->() const { return &(operator*()); }

      _Self&
      operator++()
      {
        _M_increment();
        return *this;
      }

      _Self
      operator++(int)
      {
        _Self __tmp = *this;
        _M_increment();
        return __tmp;
      }

      _Self&
      operator--() { _M_decrement(); return *this; }

      _Self
      operator--(int)
      {
        _Self __tmp = *this;
        _M_decrement();
        return __tmp;
      }
  };

  template<typename _Val, typename _Ref, typename _Ptr>
    inline bool
    operator==(const _Rb_tree_iterator<_Val, _Ref, _Ptr>& __x,
               const _Rb_tree_iterator<_Val, _Ref, _Ptr>& __y)
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator==(const _Rb_tree_iterator<_Val, const _Val&, const _Val*>& __x,
               const _Rb_tree_iterator<_Val, _Val&, _Val*>& __y)
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator==(const _Rb_tree_iterator<_Val, _Val&, _Val*>& __x,
               const _Rb_tree_iterator<_Val, const _Val&, const _Val*>& __y)
    { return __x._M_node == __y._M_node; }

  template<typename _Val, typename _Ref, typename _Ptr>
    inline bool
    operator!=(const _Rb_tree_iterator<_Val, _Ref, _Ptr>& __x,
               const _Rb_tree_iterator<_Val, _Ref, _Ptr>& __y)
    { return __x._M_node != __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _Rb_tree_iterator<_Val, const _Val&, const _Val*>& __x,
               const _Rb_tree_iterator<_Val, _Val&, _Val*>& __y)
    { return __x._M_node != __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _Rb_tree_iterator<_Val, _Val&, _Val*>& __x,
               const _Rb_tree_iterator<_Val, const _Val&, const _Val*>& __y)
    { return __x._M_node != __y._M_node; }

  inline void
  _Rb_tree_rotate_left(_Rb_tree_node_base* __x, _Rb_tree_node_base*& __root)
  {
    _Rb_tree_node_base* __y = __x->_M_right;
    __x->_M_right = __y->_M_left;
    if (__y->_M_left !=0)
      __y->_M_left->_M_parent = __x;
    __y->_M_parent = __x->_M_parent;

    if (__x == __root)
      __root = __y;
    else if (__x == __x->_M_parent->_M_left)
      __x->_M_parent->_M_left = __y;
    else
      __x->_M_parent->_M_right = __y;
    __y->_M_left = __x;
    __x->_M_parent = __y;
  }

  inline void
  _Rb_tree_rotate_right(_Rb_tree_node_base* __x, _Rb_tree_node_base*& __root)
  {
    _Rb_tree_node_base* __y = __x->_M_left;
    __x->_M_left = __y->_M_right;
    if (__y->_M_right != 0)
      __y->_M_right->_M_parent = __x;
    __y->_M_parent = __x->_M_parent;

    if (__x == __root)
      __root = __y;
    else if (__x == __x->_M_parent->_M_right)
      __x->_M_parent->_M_right = __y;
    else
      __x->_M_parent->_M_left = __y;
    __y->_M_right = __x;
    __x->_M_parent = __y;
  }

  inline void
  _Rb_tree_rebalance(_Rb_tree_node_base* __x, _Rb_tree_node_base*& __root)
  {
    __x->_M_color = _M_red;
    while (__x != __root
           && __x->_M_parent->_M_color == _M_red)
      {
        if (__x->_M_parent == __x->_M_parent->_M_parent->_M_left)
          {
            _Rb_tree_node_base* __y = __x->_M_parent->_M_parent->_M_right;
            if (__y && __y->_M_color == _M_red)
              {
                __x->_M_parent->_M_color = _M_black;
                __y->_M_color = _M_black;
                __x->_M_parent->_M_parent->_M_color = _M_red;
                __x = __x->_M_parent->_M_parent;
              }
            else
              {
                if (__x == __x->_M_parent->_M_right)
                  {
                    __x = __x->_M_parent;
                    _Rb_tree_rotate_left(__x, __root);
                  }
                __x->_M_parent->_M_color = _M_black;
                __x->_M_parent->_M_parent->_M_color = _M_red;
                _Rb_tree_rotate_right(__x->_M_parent->_M_parent, __root);
              }
          }
        else
          {
            _Rb_tree_node_base* __y = __x->_M_parent->_M_parent->_M_left;
            if (__y && __y->_M_color == _M_red)
              {
                __x->_M_parent->_M_color = _M_black;
                __y->_M_color = _M_black;
                __x->_M_parent->_M_parent->_M_color = _M_red;
                __x = __x->_M_parent->_M_parent;
              }
            else
              {
                if (__x == __x->_M_parent->_M_left)
                  {
                    __x = __x->_M_parent;
                    _Rb_tree_rotate_right(__x, __root);
                  }
                __x->_M_parent->_M_color = _M_black;
                __x->_M_parent->_M_parent->_M_color = _M_red;
                _Rb_tree_rotate_left(__x->_M_parent->_M_parent, __root);
              }
          }
      }
    __root->_M_color = _M_black;
  }

  inline _Rb_tree_node_base*
  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* __z,
                               _Rb_tree_node_base*& __root,
                               _Rb_tree_node_base*& __leftmost,
                               _Rb_tree_node_base*& __rightmost)
  {
    _Rb_tree_node_base* __y = __z;
    _Rb_tree_node_base* __x = 0;
    _Rb_tree_node_base* __x_parent = 0;
    if (__y->_M_left == 0)
      __x = __y->_M_right;
    else
      if (__y->_M_right == 0)
        __x = __y->_M_left;
      else
        {

          __y = __y->_M_right;
          while (__y->_M_left != 0)
            __y = __y->_M_left;
          __x = __y->_M_right;
        }
    if (__y != __z)
      {

        __z->_M_left->_M_parent = __y;
        __y->_M_left = __z->_M_left;
        if (__y != __z->_M_right)
          {
            __x_parent = __y->_M_parent;
            if (__x) __x->_M_parent = __y->_M_parent;
            __y->_M_parent->_M_left = __x;
            __y->_M_right = __z->_M_right;
            __z->_M_right->_M_parent = __y;
          }
        else
          __x_parent = __y;
        if (__root == __z)
          __root = __y;
        else if (__z->_M_parent->_M_left == __z)
          __z->_M_parent->_M_left = __y;
        else
          __z->_M_parent->_M_right = __y;
        __y->_M_parent = __z->_M_parent;
        std::swap(__y->_M_color, __z->_M_color);
        __y = __z;

      }
    else
      {
        __x_parent = __y->_M_parent;
        if (__x)
          __x->_M_parent = __y->_M_parent;
        if (__root == __z)
          __root = __x;
        else
          if (__z->_M_parent->_M_left == __z)
            __z->_M_parent->_M_left = __x;
          else
            __z->_M_parent->_M_right = __x;
        if (__leftmost == __z)
          if (__z->_M_right == 0)
            __leftmost = __z->_M_parent;

          else
            __leftmost = _Rb_tree_node_base::_S_minimum(__x);
        if (__rightmost == __z)
          if (__z->_M_left == 0)
            __rightmost = __z->_M_parent;

          else
            __rightmost = _Rb_tree_node_base::_S_maximum(__x);
      }
    if (__y->_M_color != _M_red)
      {
        while (__x != __root && (__x == 0 || __x->_M_color == _M_black))
          if (__x == __x_parent->_M_left)
            {
              _Rb_tree_node_base* __w = __x_parent->_M_right;
              if (__w->_M_color == _M_red)
                {
                  __w->_M_color = _M_black;
                  __x_parent->_M_color = _M_red;
                  _Rb_tree_rotate_left(__x_parent, __root);
                  __w = __x_parent->_M_right;
                }
              if ((__w->_M_left == 0 ||
                   __w->_M_left->_M_color == _M_black) &&
                  (__w->_M_right == 0 ||
                   __w->_M_right->_M_color == _M_black))
                {
                  __w->_M_color = _M_red;
                  __x = __x_parent;
                  __x_parent = __x_parent->_M_parent;
                }
              else
                {
                  if (__w->_M_right == 0
                      || __w->_M_right->_M_color == _M_black)
                    {
                      __w->_M_left->_M_color = _M_black;
                      __w->_M_color = _M_red;
                      _Rb_tree_rotate_right(__w, __root);
                      __w = __x_parent->_M_right;
                    }
                  __w->_M_color = __x_parent->_M_color;
                  __x_parent->_M_color = _M_black;
                  if (__w->_M_right)
                    __w->_M_right->_M_color = _M_black;
                  _Rb_tree_rotate_left(__x_parent, __root);
                  break;
                }
            }
          else
            {

              _Rb_tree_node_base* __w = __x_parent->_M_left;
              if (__w->_M_color == _M_red)
                {
                  __w->_M_color = _M_black;
                  __x_parent->_M_color = _M_red;
                  _Rb_tree_rotate_right(__x_parent, __root);
                  __w = __x_parent->_M_left;
                }
              if ((__w->_M_right == 0 ||
                   __w->_M_right->_M_color == _M_black) &&
                  (__w->_M_left == 0 ||
                   __w->_M_left->_M_color == _M_black))
                {
                  __w->_M_color = _M_red;
                  __x = __x_parent;
                  __x_parent = __x_parent->_M_parent;
                }
              else
                {
                  if (__w->_M_left == 0 || __w->_M_left->_M_color == _M_black)
                    {
                      __w->_M_right->_M_color = _M_black;
                      __w->_M_color = _M_red;
                      _Rb_tree_rotate_left(__w, __root);
                      __w = __x_parent->_M_left;
                    }
                  __w->_M_color = __x_parent->_M_color;
                  __x_parent->_M_color = _M_black;
                  if (__w->_M_left)
                    __w->_M_left->_M_color = _M_black;
                  _Rb_tree_rotate_right(__x_parent, __root);
                  break;
                }
            }
        if (__x) __x->_M_color = _M_black;
      }
    return __y;
  }







  template<typename _Tp, typename _Alloc, bool _S_instanceless>
    class _Rb_tree_alloc_base
    {
    public:
    typedef typename _Alloc_traits<_Tp, _Alloc>::allocator_type allocator_type;

      allocator_type
      get_allocator() const { return _M_node_allocator; }

      _Rb_tree_alloc_base(const allocator_type& __a)
      : _M_node_allocator(__a), _M_header(0) {}

    protected:
      typename _Alloc_traits<_Rb_tree_node<_Tp>, _Alloc>::allocator_type
      _M_node_allocator;

      _Rb_tree_node<_Tp>* _M_header;

      _Rb_tree_node<_Tp>*
      _M_get_node() { return _M_node_allocator.allocate(1); }

      void
      _M_put_node(_Rb_tree_node<_Tp>* __p)
      { _M_node_allocator.deallocate(__p, 1); }
    };


  template<typename _Tp, typename _Alloc>
    class _Rb_tree_alloc_base<_Tp, _Alloc, true>
    {
    public:
    typedef typename _Alloc_traits<_Tp, _Alloc>::allocator_type allocator_type;
      allocator_type get_allocator() const { return allocator_type(); }

      _Rb_tree_alloc_base(const allocator_type&) : _M_header(0) {}

    protected:
      _Rb_tree_node<_Tp>* _M_header;

      typedef typename _Alloc_traits<_Rb_tree_node<_Tp>, _Alloc>::_Alloc_type
      _Alloc_type;

      _Rb_tree_node<_Tp>*
      _M_get_node() { return _Alloc_type::allocate(1); }

      void
      _M_put_node(_Rb_tree_node<_Tp>* __p) { _Alloc_type::deallocate(__p, 1); }
    };

  template<typename _Tp, typename _Alloc>
    struct _Rb_tree_base : public _Rb_tree_alloc_base<_Tp, _Alloc,
                                  _Alloc_traits<_Tp, _Alloc>::_S_instanceless>
    {
      typedef _Rb_tree_alloc_base<_Tp,
        _Alloc, _Alloc_traits<_Tp, _Alloc>::_S_instanceless> _Base;
      typedef typename _Base::allocator_type allocator_type;

      _Rb_tree_base(const allocator_type& __a)
      : _Base(__a) { _M_header = _M_get_node(); }
      ~_Rb_tree_base() { _M_put_node(_M_header); }
    };


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc = allocator<_Val> >
    class _Rb_tree : protected _Rb_tree_base<_Val, _Alloc>
    {
      typedef _Rb_tree_base<_Val, _Alloc> _Base;

    protected:
      typedef _Rb_tree_node_base* _Base_ptr;
      typedef _Rb_tree_node<_Val> _Rb_tree_node;

    public:
      typedef _Key key_type;
      typedef _Val value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef _Rb_tree_node* _Link_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;

      typedef typename _Base::allocator_type allocator_type;
      allocator_type get_allocator() const { return _Base::get_allocator(); }

    protected:
      using _Base::_M_get_node;
      using _Base::_M_put_node;
      using _Base::_M_header;

      _Link_type
      _M_create_node(const value_type& __x)
      {
        _Link_type __tmp = _M_get_node();
        try
          { _Construct(&__tmp->_M_value_field, __x); }
        catch(...)
          {
          _M_put_node(__tmp);
          throw;
          }
        return __tmp;
      }

      _Link_type
      _M_clone_node(_Link_type __x)
      {
        _Link_type __tmp = _M_create_node(__x->_M_value_field);
        __tmp->_M_color = __x->_M_color;
        __tmp->_M_left = 0;
        __tmp->_M_right = 0;
        return __tmp;
      }

      void
      destroy_node(_Link_type __p)
      {
        _Destroy(&__p->_M_value_field);
        _M_put_node(__p);
      }

      size_type _M_node_count;
      _Compare _M_key_compare;

      _Link_type&
      _M_root() const { return (_Link_type&) _M_header->_M_parent; }

      _Link_type&
      _M_leftmost() const { return (_Link_type&) _M_header->_M_left; }

      _Link_type&
      _M_rightmost() const { return (_Link_type&) _M_header->_M_right; }

      static _Link_type&
      _S_left(_Link_type __x) { return (_Link_type&)(__x->_M_left); }

      static _Link_type&
      _S_right(_Link_type __x) { return (_Link_type&)(__x->_M_right); }

      static _Link_type&
      _S_parent(_Link_type __x) { return (_Link_type&)(__x->_M_parent); }

      static reference
      _S_value(_Link_type __x) { return __x->_M_value_field; }

      static const _Key&
      _S_key(_Link_type __x) { return _KeyOfValue()(_S_value(__x)); }

      static _Rb_tree_color&
      _S_color(_Link_type __x) { return __x->_M_color; }

      static _Link_type&
      _S_left(_Base_ptr __x) { return (_Link_type&)(__x->_M_left); }

      static _Link_type&
      _S_right(_Base_ptr __x) { return (_Link_type&)(__x->_M_right); }

      static _Link_type&
      _S_parent(_Base_ptr __x) { return (_Link_type&)(__x->_M_parent); }

      static reference
      _S_value(_Base_ptr __x) { return ((_Link_type)__x)->_M_value_field; }

      static const _Key&
      _S_key(_Base_ptr __x) { return _KeyOfValue()(_S_value(_Link_type(__x)));}

      static _Rb_tree_color&
      _S_color(_Base_ptr __x) { return (_Link_type(__x)->_M_color); }

      static _Link_type
      _S_minimum(_Link_type __x)
      { return (_Link_type) _Rb_tree_node_base::_S_minimum(__x); }

      static _Link_type
      _S_maximum(_Link_type __x)
      { return (_Link_type) _Rb_tree_node_base::_S_maximum(__x); }

    public:
      typedef _Rb_tree_iterator<value_type, reference, pointer> iterator;
      typedef _Rb_tree_iterator<value_type, const_reference, const_pointer>
      const_iterator;

      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;

    private:
      iterator
      _M_insert(_Base_ptr __x, _Base_ptr __y, const value_type& __v);

      _Link_type
      _M_copy(_Link_type __x, _Link_type __p);

      void
      _M_erase(_Link_type __x);

    public:

      _Rb_tree()
        : _Base(allocator_type()), _M_node_count(0), _M_key_compare()
      { _M_empty_initialize(); }

      _Rb_tree(const _Compare& __comp)
        : _Base(allocator_type()), _M_node_count(0), _M_key_compare(__comp)
      { _M_empty_initialize(); }

      _Rb_tree(const _Compare& __comp, const allocator_type& __a)
        : _Base(__a), _M_node_count(0), _M_key_compare(__comp)
      { _M_empty_initialize(); }

      _Rb_tree(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x)
        : _Base(__x.get_allocator()), _M_node_count(0),
                 _M_key_compare(__x._M_key_compare)
      {
        if (__x._M_root() == 0)
          _M_empty_initialize();
        else
          {
            _S_color(_M_header) = _M_red;
            _M_root() = _M_copy(__x._M_root(), _M_header);
            _M_leftmost() = _S_minimum(_M_root());
            _M_rightmost() = _S_maximum(_M_root());
          }
        _M_node_count = __x._M_node_count;
      }

      ~_Rb_tree() { clear(); }

      _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>&
      operator=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x);

    private:
      void _M_empty_initialize()
      {
        _S_color(_M_header) = _M_red;

        _M_root() = 0;
        _M_leftmost() = _M_header;
        _M_rightmost() = _M_header;
      }

    public:

      _Compare
      key_comp() const { return _M_key_compare; }

      iterator
      begin() { return _M_leftmost(); }

      const_iterator
      begin() const { return _M_leftmost(); }

      iterator
      end() { return _M_header; }

      const_iterator
      end() const { return _M_header; }

      reverse_iterator
      rbegin() { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const { return const_reverse_iterator(end()); }

      reverse_iterator
      rend() { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const { return const_reverse_iterator(begin()); }

      bool
      empty() const { return _M_node_count == 0; }

      size_type
      size() const { return _M_node_count; }

      size_type
      max_size() const { return size_type(-1); }

      void
      swap(_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __t)
      {
        std::swap(_M_header, __t._M_header);
        std::swap(_M_node_count, __t._M_node_count);
        std::swap(_M_key_compare, __t._M_key_compare);
      }


      pair<iterator,bool>
      insert_unique(const value_type& __x);

      iterator
      insert_equal(const value_type& __x);

      iterator
      insert_unique(iterator __position, const value_type& __x);

      iterator
      insert_equal(iterator __position, const value_type& __x);

      template<typename _InputIterator>
      void
      insert_unique(_InputIterator __first, _InputIterator __last);

      template<typename _InputIterator>
      void
      insert_equal(_InputIterator __first, _InputIterator __last);

      void
      erase(iterator __position);

      size_type
      erase(const key_type& __x);

      void
      erase(iterator __first, iterator __last);

      void
      erase(const key_type* __first, const key_type* __last);

      void
      clear()
      {
        if (_M_node_count != 0)
          {
            _M_erase(_M_root());
            _M_leftmost() = _M_header;
            _M_root() = 0;
            _M_rightmost() = _M_header;
            _M_node_count = 0;
          }
      }


      iterator
      find(const key_type& __x);

      const_iterator
      find(const key_type& __x) const;

      size_type
      count(const key_type& __x) const;

      iterator
      lower_bound(const key_type& __x);

      const_iterator
      lower_bound(const key_type& __x) const;

      iterator
      upper_bound(const key_type& __x);

      const_iterator
      upper_bound(const key_type& __x) const;

      pair<iterator,iterator>
      equal_range(const key_type& __x);

      pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const;


      bool
      __rb_verify() const;
    };

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator==(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x,
               const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)
    {
      return __x.size() == __y.size() &&
        equal(__x.begin(), __x.end(), __y.begin());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x,
              const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)
    {
      return lexicographical_compare(__x.begin(), __x.end(),
                                     __y.begin(), __y.end());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator!=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x,
               const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)
    { return !(__x == __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x,
              const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)
    { return __y < __x; }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x,
               const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)
  { return !(__y < __x); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x,
               const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)
  { return !(__x < __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    swap(_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x,
         _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)
    { __x.swap(__y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>&
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
    operator=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x)
    {
      if (this != &__x)
        {

          clear();
          _M_node_count = 0;
          _M_key_compare = __x._M_key_compare;
          if (__x._M_root() == 0)
            {
              _M_root() = 0;
              _M_leftmost() = _M_header;
              _M_rightmost() = _M_header;
            }
          else
            {
              _M_root() = _M_copy(__x._M_root(), _M_header);
              _M_leftmost() = _S_minimum(_M_root());
              _M_rightmost() = _S_maximum(_M_root());
              _M_node_count = __x._M_node_count;
            }
        }
      return *this;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
    _M_insert(_Base_ptr __x_, _Base_ptr __y_, const _Val& __v)
    {
      _Link_type __x = (_Link_type) __x_;
      _Link_type __y = (_Link_type) __y_;
      _Link_type __z;

      if (__y == _M_header || __x != 0 ||
          _M_key_compare(_KeyOfValue()(__v), _S_key(__y)))
        {
          __z = _M_create_node(__v);
          _S_left(__y) = __z;

          if (__y == _M_header)
            {
              _M_root() = __z;
              _M_rightmost() = __z;
            }
          else if (__y == _M_leftmost())
            _M_leftmost() = __z;
        }
      else
        {
          __z = _M_create_node(__v);
          _S_right(__y) = __z;

          if (__y == _M_rightmost())
            _M_rightmost() = __z;
        }
      _S_parent(__z) = __y;
      _S_left(__z) = 0;
      _S_right(__z) = 0;
      _Rb_tree_rebalance(__z, _M_header->_M_parent);
      ++_M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
    insert_equal(const _Val& __v)
    {
      _Link_type __y = _M_header;
      _Link_type __x = _M_root();
      while (__x != 0)
        {
          __y = __x;
          __x = _M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ?
            _S_left(__x) : _S_right(__x);
        }
      return _M_insert(__x, __y, __v);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator,
    bool>
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
    insert_unique(const _Val& __v)
    {
      _Link_type __y = _M_header;
      _Link_type __x = _M_root();
      bool __comp = true;
      while (__x != 0)
        {
          __y = __x;
          __comp = _M_key_compare(_KeyOfValue()(__v), _S_key(__x));
          __x = __comp ? _S_left(__x) : _S_right(__x);
        }
      iterator __j = iterator(__y);
      if (__comp)
        if (__j == begin())
          return pair<iterator,bool>(_M_insert(__x, __y, __v), true);
        else
          --__j;
      if (_M_key_compare(_S_key(__j._M_node), _KeyOfValue()(__v)))
        return pair<iterator,bool>(_M_insert(__x, __y, __v), true);
      return pair<iterator,bool>(__j, false);
    }


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    insert_unique(iterator __position, const _Val& __v)
    {
      if (__position._M_node == _M_header->_M_left)
        {

          if (size() > 0 &&
              _M_key_compare(_KeyOfValue()(__v), _S_key(__position._M_node)))
            return _M_insert(__position._M_node, __position._M_node, __v);

          else
            return insert_unique(__v).first;
        }
      else if (__position._M_node == _M_header)
        {

          if (_M_key_compare(_S_key(_M_rightmost()), _KeyOfValue()(__v)))
            return _M_insert(0, _M_rightmost(), __v);
          else
            return insert_unique(__v).first;
        }
      else
        {
          iterator __before = __position;
          --__before;
          if (_M_key_compare(_S_key(__before._M_node), _KeyOfValue()(__v))
              && _M_key_compare(_KeyOfValue()(__v),_S_key(__position._M_node)))
            {
              if (_S_right(__before._M_node) == 0)
                return _M_insert(0, __before._M_node, __v);
              else
                return _M_insert(__position._M_node, __position._M_node, __v);

            }
          else
            return insert_unique(__v).first;
        }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
    insert_equal(iterator __position, const _Val& __v)
    {
      if (__position._M_node == _M_header->_M_left)
        {

          if (size() > 0 &&
              !_M_key_compare(_S_key(__position._M_node), _KeyOfValue()(__v)))
            return _M_insert(__position._M_node, __position._M_node, __v);

          else
            return insert_equal(__v);
        }
      else if (__position._M_node == _M_header)
        {

          if (!_M_key_compare(_KeyOfValue()(__v), _S_key(_M_rightmost())))
            return _M_insert(0, _M_rightmost(), __v);
          else
            return insert_equal(__v);
        }
      else
        {
          iterator __before = __position;
          --__before;
          if (!_M_key_compare(_KeyOfValue()(__v), _S_key(__before._M_node))
              && !_M_key_compare(_S_key(__position._M_node),
                                 _KeyOfValue()(__v)))
            {
              if (_S_right(__before._M_node) == 0)
                return _M_insert(0, __before._M_node, __v);
              else
                return _M_insert(__position._M_node, __position._M_node, __v);

            }
          else
            return insert_equal(__v);
        }
    }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key,_Val,_KoV,_Cmp,_Alloc>::
      insert_equal(_II __first, _II __last)
      {
        for ( ; __first != __last; ++__first)
          insert_equal(*__first);
      }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
    void
    _Rb_tree<_Key,_Val,_KoV,_Cmp,_Alloc>::
    insert_unique(_II __first, _II __last)
    {
      for ( ; __first != __last; ++__first)
        insert_unique(*__first);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::erase(iterator __position)
    {
      _Link_type __y =
        (_Link_type) _Rb_tree_rebalance_for_erase(__position._M_node,
                                                  _M_header->_M_parent,
                                                  _M_header->_M_left,
                                                  _M_header->_M_right);
      destroy_node(__y);
      --_M_node_count;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::size_type
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::erase(const _Key& __x)
    {
      pair<iterator,iterator> __p = equal_range(__x);
      size_type __n = distance(__p.first, __p.second);
      erase(__p.first, __p.second);
      return __n;
    }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
    _Rb_tree<_Key,_Val,_KoV,_Compare,_Alloc>::
    _M_copy(_Link_type __x, _Link_type __p)
    {

      _Link_type __top = _M_clone_node(__x);
      __top->_M_parent = __p;

      try
        {
          if (__x->_M_right)
            __top->_M_right = _M_copy(_S_right(__x), __top);
          __p = __top;
          __x = _S_left(__x);

          while (__x != 0)
            {
              _Link_type __y = _M_clone_node(__x);
              __p->_M_left = __y;
              __y->_M_parent = __p;
              if (__x->_M_right)
                __y->_M_right = _M_copy(_S_right(__x), __y);
              __p = __y;
              __x = _S_left(__x);
            }
        }
      catch(...)
        {
          _M_erase(__top);
          throw;
        }
      return __top;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_M_erase(_Link_type __x)
    {

      while (__x != 0)
        {
          _M_erase(_S_right(__x));
          _Link_type __y = _S_left(__x);
          destroy_node(__x);
          __x = __y;
        }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first == begin() && __last == end())
        clear();
      else
        while (__first != __last) erase(__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
    erase(const _Key* __first, const _Key* __last)
    {
      while (__first != __last)
        erase(*__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::find(const _Key& __k)
    {
      _Link_type __y = _M_header;
      _Link_type __x = _M_root();

      while (__x != 0)
        if (!_M_key_compare(_S_key(__x), __k))
          __y = __x, __x = _S_left(__x);
        else
          __x = _S_right(__x);

      iterator __j = iterator(__y);
      return (__j == end() || _M_key_compare(__k, _S_key(__j._M_node))) ?
        end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
    find(const _Key& __k) const
    {
      _Link_type __y = _M_header;
      _Link_type __x = _M_root();

     while (__x != 0)
       {
         if (!_M_key_compare(_S_key(__x), __k))
           __y = __x, __x = _S_left(__x);
         else
           __x = _S_right(__x);
       }
     const_iterator __j = const_iterator(__y);
     return (__j == end() || _M_key_compare(__k, _S_key(__j._M_node))) ?
       end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::size_type
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
    count(const _Key& __k) const
    {
      pair<const_iterator, const_iterator> __p = equal_range(__k);
      size_type __n = distance(__p.first, __p.second);
      return __n;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
    lower_bound(const _Key& __k)
    {
      _Link_type __y = _M_header;
      _Link_type __x = _M_root();

      while (__x != 0)
        if (!_M_key_compare(_S_key(__x), __k))
          __y = __x, __x = _S_left(__x);
        else
          __x = _S_right(__x);

      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
    lower_bound(const _Key& __k) const
    {
      _Link_type __y = _M_header;
      _Link_type __x = _M_root();

      while (__x != 0)
        if (!_M_key_compare(_S_key(__x), __k))
          __y = __x, __x = _S_left(__x);
        else
          __x = _S_right(__x);

      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
    upper_bound(const _Key& __k)
    {
      _Link_type __y = _M_header;
      _Link_type __x = _M_root();

      while (__x != 0)
        if (_M_key_compare(__k, _S_key(__x)))
          __y = __x, __x = _S_left(__x);
        else
          __x = _S_right(__x);

      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
    upper_bound(const _Key& __k) const
    {
      _Link_type __y = _M_header;
      _Link_type __x = _M_root();

      while (__x != 0)
        if (_M_key_compare(__k, _S_key(__x)))
          __y = __x, __x = _S_left(__x);
        else
          __x = _S_right(__x);

      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline
    pair<typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator,
                                                                   typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator>
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::
    equal_range(const _Key& __k)
    { return pair<iterator, iterator>(lower_bound(__k), upper_bound(__k)); }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Compare, typename _Alloc>
  inline
  pair<typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::const_iterator,
                                                                typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::const_iterator>
  _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>
  ::equal_range(const _Key& __k) const
  {
    return pair<const_iterator,const_iterator>(lower_bound(__k),
                                               upper_bound(__k));
  }

  inline int
  __black_count(_Rb_tree_node_base* __node, _Rb_tree_node_base* __root)
  {
    if (__node == 0)
      return 0;
    int __sum = 0;
    do
      {
        if (__node->_M_color == _M_black)
          ++__sum;
        if (__node == __root)
          break;
        __node = __node->_M_parent;
      }
    while (1);
    return __sum;
  }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    bool
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
    {
    if (_M_node_count == 0 || begin() == end())
      return _M_node_count == 0 && begin() == end() &&
        _M_header->_M_left == _M_header && _M_header->_M_right == _M_header;

    int __len = __black_count(_M_leftmost(), _M_root());
    for (const_iterator __it = begin(); __it != end(); ++__it)
      {
        _Link_type __x = (_Link_type) __it._M_node;
        _Link_type __L = _S_left(__x);
        _Link_type __R = _S_right(__x);

        if (__x->_M_color == _M_red)
          if ((__L && __L->_M_color == _M_red)
              || (__R && __R->_M_color == _M_red))
            return false;

        if (__L && _M_key_compare(_S_key(__x), _S_key(__L)))
          return false;
        if (__R && _M_key_compare(_S_key(__R), _S_key(__x)))
          return false;

        if (!__L && !__R && __black_count(__x, _M_root()) != __len)
          return false;
      }

    if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
      return false;
    if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
      return false;
    return true;
    }
}
# 67 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/map" 2 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_map.h" 1 3
# 66 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_map.h" 3
namespace std
{
# 89 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_map.h" 3
  template <typename _Key, typename _Tp, typename _Compare = less<_Key>,
            typename _Alloc = allocator<pair<const _Key, _Tp> > >
    class map
  {

   
   

  public:
    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef pair<const _Key, _Tp> value_type;
    typedef _Compare key_compare;

    class value_compare
      : public binary_function<value_type, value_type, bool>
      {
        friend class map<_Key,_Tp,_Compare,_Alloc>;
      protected:
        _Compare comp;
        value_compare(_Compare __c) : comp(__c) {}
      public:
        bool operator()(const value_type& __x, const value_type& __y) const
        { return comp(__x.first, __y.first); }
      };

  private:

    typedef _Rb_tree<key_type, value_type,
                     _Select1st<value_type>, key_compare, _Alloc> _Rep_type;

    _Rep_type _M_t;

  public:


    typedef typename _Rep_type::allocator_type allocator_type;
    typedef typename _Rep_type::reference reference;
    typedef typename _Rep_type::const_reference const_reference;
    typedef typename _Rep_type::iterator iterator;
    typedef typename _Rep_type::const_iterator const_iterator;
    typedef typename _Rep_type::size_type size_type;
    typedef typename _Rep_type::difference_type difference_type;
    typedef typename _Rep_type::pointer pointer;
    typedef typename _Rep_type::const_pointer const_pointer;
    typedef typename _Rep_type::reverse_iterator reverse_iterator;
    typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
# 144 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_map.h" 3
    map() : _M_t(_Compare(), allocator_type()) { }





    explicit
    map(const _Compare& __comp, const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
# 161 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_map.h" 3
    map(const map& __x)
      : _M_t(__x._M_t) { }
# 173 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_map.h" 3
    template <typename _InputIterator>
      map(_InputIterator __first, _InputIterator __last)
      : _M_t(_Compare(), allocator_type())
      { _M_t.insert_unique(__first, __last); }
# 189 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_map.h" 3
    template <typename _InputIterator>
      map(_InputIterator __first, _InputIterator __last,
          const _Compare& __comp, const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a)
      { _M_t.insert_unique(__first, __last); }
# 211 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_map.h" 3
    map&
    operator=(const map& __x)
    {
      _M_t = __x._M_t;
      return *this;
    }


    allocator_type
    get_allocator() const { return _M_t.get_allocator(); }






    iterator
    begin() { return _M_t.begin(); }






    const_iterator
    begin() const { return _M_t.begin(); }





    iterator
    end() { return _M_t.end(); }






    const_iterator
    end() const { return _M_t.end(); }





    reverse_iterator
    rbegin() { return _M_t.rbegin(); }






    const_reverse_iterator
    rbegin() const { return _M_t.rbegin(); }






    reverse_iterator
    rend() { return _M_t.rend(); }






    const_reverse_iterator
    rend() const { return _M_t.rend(); }



    bool
    empty() const { return _M_t.empty(); }


    size_type
    size() const { return _M_t.size(); }


    size_type
    max_size() const { return _M_t.max_size(); }
# 310 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_map.h" 3
    mapped_type&
    operator[](const key_type& __k)
    {

     

      iterator __i = lower_bound(__k);

      if (__i == end() || key_comp()(__k, (*__i).first))
        __i = insert(__i, value_type(__k, mapped_type()));
      return (*__i).second;
    }
# 338 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_map.h" 3
    pair<iterator,bool>
    insert(const value_type& __x)
    { return _M_t.insert_unique(__x); }
# 362 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_map.h" 3
    iterator
    insert(iterator position, const value_type& __x)
    { return _M_t.insert_unique(position, __x); }
# 374 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_map.h" 3
    template <typename _InputIterator>
      void
      insert(_InputIterator __first, _InputIterator __last)
      { _M_t.insert_unique(__first, __last); }
# 388 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_map.h" 3
    void
    erase(iterator __position) { _M_t.erase(__position); }
# 402 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_map.h" 3
    size_type
    erase(const key_type& __x) { return _M_t.erase(__x); }
# 415 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_map.h" 3
    void
    erase(iterator __first, iterator __last) { _M_t.erase(__first, __last); }
# 429 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_map.h" 3
    void
    swap(map& __x) { _M_t.swap(__x._M_t); }







    void
    clear() { _M_t.clear(); }





    key_compare
    key_comp() const { return _M_t.key_comp(); }





    value_compare
    value_comp() const { return value_compare(_M_t.key_comp()); }
# 467 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_map.h" 3
    iterator
    find(const key_type& __x) { return _M_t.find(__x); }
# 481 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_map.h" 3
    const_iterator
    find(const key_type& __x) const { return _M_t.find(__x); }
# 492 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_map.h" 3
    size_type
    count(const key_type& __x) const
    { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
# 507 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_map.h" 3
    iterator
    lower_bound(const key_type& __x) { return _M_t.lower_bound(__x); }
# 521 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_map.h" 3
    const_iterator
    lower_bound(const key_type& __x) const { return _M_t.lower_bound(__x); }
# 531 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_map.h" 3
    iterator
    upper_bound(const key_type& __x) { return _M_t.upper_bound(__x); }
# 542 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_map.h" 3
    const_iterator
    upper_bound(const key_type& __x) const
    { return _M_t.upper_bound(__x); }
# 561 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_map.h" 3
    pair<iterator,iterator>
    equal_range(const key_type& __x)
    { return _M_t.equal_range(__x); }
# 580 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_map.h" 3
    pair<const_iterator,const_iterator>
    equal_range(const key_type& __x) const
    { return _M_t.equal_range(__x); }

    template <typename _K1, typename _T1, typename _C1, typename _A1>
    friend bool operator== (const map<_K1,_T1,_C1,_A1>&,
                            const map<_K1,_T1,_C1,_A1>&);
    template <typename _K1, typename _T1, typename _C1, typename _A1>
    friend bool operator< (const map<_K1,_T1,_C1,_A1>&,
                           const map<_K1,_T1,_C1,_A1>&);
  };
# 603 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_map.h" 3
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const map<_Key,_Tp,_Compare,_Alloc>& __x,
               const map<_Key,_Tp,_Compare,_Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 620 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_map.h" 3
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const map<_Key,_Tp,_Compare,_Alloc>& __x,
              const map<_Key,_Tp,_Compare,_Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const map<_Key,_Tp,_Compare,_Alloc>& __x,
               const map<_Key,_Tp,_Compare,_Alloc>& __y)
    { return !(__x == __y); }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const map<_Key,_Tp,_Compare,_Alloc>& __x,
              const map<_Key,_Tp,_Compare,_Alloc>& __y)
    { return __y < __x; }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const map<_Key,_Tp,_Compare,_Alloc>& __x,
               const map<_Key,_Tp,_Compare,_Alloc>& __y)
    { return !(__y < __x); }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const map<_Key,_Tp,_Compare,_Alloc>& __x,
               const map<_Key,_Tp,_Compare,_Alloc>& __y)
    { return !(__x < __y); }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(map<_Key,_Tp,_Compare,_Alloc>& __x, map<_Key,_Tp,_Compare,_Alloc>& __y)
    { __x.swap(__y); }
}
# 68 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/map" 2 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_multimap.h" 1 3
# 66 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_multimap.h" 3
namespace std
{


  template <typename _Key, typename _Tp,
            typename _Compare = less<_Key>,
            typename _Alloc = allocator<pair<const _Key, _Tp> > >
  class multimap;

  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
  inline bool operator==(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,
                         const multimap<_Key,_Tp,_Compare,_Alloc>& __y);

  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
  inline bool operator<(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,
                        const multimap<_Key,_Tp,_Compare,_Alloc>& __y);
# 104 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_multimap.h" 3
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    class multimap
  {

   
   

  public:
    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef pair<const _Key, _Tp> value_type;
    typedef _Compare key_compare;

    class value_compare
      : public binary_function<value_type, value_type, bool>
      {
        friend class multimap<_Key,_Tp,_Compare,_Alloc>;
      protected:
        _Compare comp;
        value_compare(_Compare __c) : comp(__c) {}
      public:
        bool operator()(const value_type& __x, const value_type& __y) const
        { return comp(__x.first, __y.first); }
    };

  private:

    typedef _Rb_tree<key_type, value_type,
                    _Select1st<value_type>, key_compare, _Alloc> _Rep_type;

    _Rep_type _M_t;

  public:


    typedef typename _Rep_type::allocator_type allocator_type;
    typedef typename _Rep_type::reference reference;
    typedef typename _Rep_type::const_reference const_reference;
    typedef typename _Rep_type::iterator iterator;
    typedef typename _Rep_type::const_iterator const_iterator;
    typedef typename _Rep_type::size_type size_type;
    typedef typename _Rep_type::difference_type difference_type;
    typedef typename _Rep_type::pointer pointer;
    typedef typename _Rep_type::const_pointer const_pointer;
    typedef typename _Rep_type::reverse_iterator reverse_iterator;
    typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;







    multimap() : _M_t(_Compare(), allocator_type()) { }





    explicit
    multimap(const _Compare& __comp, const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
# 174 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_multimap.h" 3
    multimap(const multimap& __x)
      : _M_t(__x._M_t) { }
# 186 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_multimap.h" 3
    template <typename _InputIterator>
      multimap(_InputIterator __first, _InputIterator __last)
        : _M_t(_Compare(), allocator_type())
        { _M_t.insert_equal(__first, __last); }
# 202 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_multimap.h" 3
    template <typename _InputIterator>
      multimap(_InputIterator __first, _InputIterator __last,
               const _Compare& __comp,
               const allocator_type& __a = allocator_type())
        : _M_t(__comp, __a)
        { _M_t.insert_equal(__first, __last); }
# 225 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_multimap.h" 3
    multimap&
    operator=(const multimap& __x)
    {
      _M_t = __x._M_t;
      return *this;
    }


    allocator_type
    get_allocator() const { return _M_t.get_allocator(); }






    iterator
    begin() { return _M_t.begin(); }






    const_iterator
    begin() const { return _M_t.begin(); }





    iterator
    end() { return _M_t.end(); }






    const_iterator
    end() const { return _M_t.end(); }






    reverse_iterator
    rbegin() { return _M_t.rbegin(); }






    const_reverse_iterator
    rbegin() const { return _M_t.rbegin(); }






    reverse_iterator
    rend() { return _M_t.rend(); }






    const_reverse_iterator
    rend() const { return _M_t.rend(); }



    bool
    empty() const { return _M_t.empty(); }


    size_type
    size() const { return _M_t.size(); }


    size_type
    max_size() const { return _M_t.max_size(); }
# 325 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_multimap.h" 3
    iterator
    insert(const value_type& __x) { return _M_t.insert_equal(__x); }
# 348 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_multimap.h" 3
    iterator
    insert(iterator __position, const value_type& __x)
    { return _M_t.insert_equal(__position, __x); }
# 360 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_multimap.h" 3
    template <typename _InputIterator>
      void
      insert(_InputIterator __first, _InputIterator __last)
      { _M_t.insert_equal(__first, __last); }
# 374 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_multimap.h" 3
    void
    erase(iterator __position) { _M_t.erase(__position); }
# 388 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_multimap.h" 3
    size_type
    erase(const key_type& __x) { return _M_t.erase(__x); }
# 401 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_multimap.h" 3
    void
    erase(iterator __first, iterator __last) { _M_t.erase(__first, __last); }
# 415 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_multimap.h" 3
    void
    swap(multimap& __x) { _M_t.swap(__x._M_t); }







    void
    clear() { _M_t.clear(); }






    key_compare
    key_comp() const { return _M_t.key_comp(); }





    value_compare
    value_comp() const { return value_compare(_M_t.key_comp()); }
# 454 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_multimap.h" 3
    iterator
    find(const key_type& __x) { return _M_t.find(__x); }
# 468 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_multimap.h" 3
    const_iterator
    find(const key_type& __x) const { return _M_t.find(__x); }






    size_type
    count(const key_type& __x) const { return _M_t.count(__x); }
# 490 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_multimap.h" 3
    iterator
    lower_bound(const key_type& __x) { return _M_t.lower_bound(__x); }
# 504 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_multimap.h" 3
    const_iterator
    lower_bound(const key_type& __x) const { return _M_t.lower_bound(__x); }






    iterator
    upper_bound(const key_type& __x) { return _M_t.upper_bound(__x); }







    const_iterator
    upper_bound(const key_type& __x) const { return _M_t.upper_bound(__x); }
# 537 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_multimap.h" 3
    pair<iterator,iterator>
    equal_range(const key_type& __x) { return _M_t.equal_range(__x); }
# 553 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_multimap.h" 3
    pair<const_iterator,const_iterator>
    equal_range(const key_type& __x) const { return _M_t.equal_range(__x); }

    template <typename _K1, typename _T1, typename _C1, typename _A1>
    friend bool operator== (const multimap<_K1,_T1,_C1,_A1>&,
                            const multimap<_K1,_T1,_C1,_A1>&);
    template <typename _K1, typename _T1, typename _C1, typename _A1>
    friend bool operator< (const multimap<_K1,_T1,_C1,_A1>&,
                           const multimap<_K1,_T1,_C1,_A1>&);
  };
# 575 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_multimap.h" 3
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,
               const multimap<_Key,_Tp,_Compare,_Alloc>& __y)
    {
      return __x._M_t == __y._M_t;
    }
# 594 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_multimap.h" 3
  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,
              const multimap<_Key,_Tp,_Compare,_Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,
               const multimap<_Key,_Tp,_Compare,_Alloc>& __y)
    { return !(__x == __y); }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,
              const multimap<_Key,_Tp,_Compare,_Alloc>& __y)
    { return __y < __x; }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,
               const multimap<_Key,_Tp,_Compare,_Alloc>& __y)
    { return !(__y < __x); }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,
               const multimap<_Key,_Tp,_Compare,_Alloc>& __y)
    { return !(__x < __y); }


  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(multimap<_Key,_Tp,_Compare,_Alloc>& __x,
         multimap<_Key,_Tp,_Compare,_Alloc>& __y)
    { __x.swap(__y); }
}
# 69 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/map" 2 3
# 28 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/common/definitions.h" 2

# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/list" 1 3
# 65 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/list" 3

# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/functexcept.h" 1 3
# 34 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/functexcept.h" 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/exception_defines.h" 1 3
# 35 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/functexcept.h" 2 3

namespace std
{

  void
  __throw_bad_exception(void);


  void
  __throw_bad_alloc(void);


  void
  __throw_bad_cast(void);

  void
  __throw_bad_typeid(void);


  void
  __throw_logic_error(const char* __s);

  void
  __throw_domain_error(const char* __s);

  void
  __throw_invalid_argument(const char* __s);

  void
  __throw_length_error(const char* __s);

  void
  __throw_out_of_range(const char* __s);

  void
  __throw_runtime_error(const char* __s);

  void
  __throw_range_error(const char* __s);

  void
  __throw_overflow_error(const char* __s);

  void
  __throw_underflow_error(const char* __s);


  void
  __throw_ios_failure(const char* __s);
}
# 67 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/list" 2 3




# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_list.h" 1 3
# 66 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_list.h" 3
namespace std
{






  struct _List_node_base
  {
    _List_node_base* _M_next;
    _List_node_base* _M_prev;
  };


  template<typename _Tp>
    struct _List_node : public _List_node_base
  {
    _Tp _M_data;
  };
# 97 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_list.h" 3
  struct _List_iterator_base
  {
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef bidirectional_iterator_tag iterator_category;


    _List_node_base* _M_node;

    _List_iterator_base(_List_node_base* __x)
    : _M_node(__x)
    { }

    _List_iterator_base()
    { }


    void
    _M_incr()
    { _M_node = _M_node->_M_next; }


    void
    _M_decr()
    { _M_node = _M_node->_M_prev; }

    bool
    operator==(const _List_iterator_base& __x) const
    { return _M_node == __x._M_node; }

    bool
    operator!=(const _List_iterator_base& __x) const
    { return _M_node != __x._M_node; }
  };
# 142 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_list.h" 3
  template<typename _Tp, typename _Ref, typename _Ptr>
    struct _List_iterator : public _List_iterator_base
  {
    typedef _List_iterator<_Tp,_Tp&,_Tp*> iterator;
    typedef _List_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;
    typedef _List_iterator<_Tp,_Ref,_Ptr> _Self;

    typedef _Tp value_type;
    typedef _Ptr pointer;
    typedef _Ref reference;
    typedef _List_node<_Tp> _Node;

    _List_iterator(_Node* __x)
    : _List_iterator_base(__x)
    { }

    _List_iterator()
    { }

    _List_iterator(const iterator& __x)
    : _List_iterator_base(__x._M_node)
    { }

    reference
    operator*() const
    { return static_cast<_Node*>(_M_node)->_M_data; }


    pointer
    operator->() const
    { return &(operator*()); }

    _Self&
    operator++()
    {
      this->_M_incr();
      return *this;
    }

    _Self
    operator++(int)
    {
      _Self __tmp = *this;
      this->_M_incr();
      return __tmp;
    }

    _Self&
    operator--()
    {
      this->_M_decr();
      return *this;
    }

    _Self
    operator--(int)
    {
      _Self __tmp = *this;
      this->_M_decr();
      return __tmp;
    }
  };
# 212 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_list.h" 3
  template<typename _Tp, typename _Allocator, bool _IsStatic>
    class _List_alloc_base
  {
  public:
    typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type
            allocator_type;

    allocator_type
    get_allocator() const { return _M_node_allocator; }

    _List_alloc_base(const allocator_type& __a)
    : _M_node_allocator(__a)
    { }

  protected:
    _List_node<_Tp>*
    _M_get_node()
    { return _M_node_allocator.allocate(1); }

    void
    _M_put_node(_List_node<_Tp>* __p)
    { _M_node_allocator.deallocate(__p, 1); }
# 247 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_list.h" 3
    typename _Alloc_traits<_List_node<_Tp>, _Allocator>::allocator_type
             _M_node_allocator;

    _List_node<_Tp>* _M_node;
  };


  template<typename _Tp, typename _Allocator>
    class _List_alloc_base<_Tp, _Allocator, true>
  {
  public:
    typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type
            allocator_type;

    allocator_type
    get_allocator() const { return allocator_type(); }

    _List_alloc_base(const allocator_type&)
    { }

  protected:


    typedef typename _Alloc_traits<_List_node<_Tp>, _Allocator>::_Alloc_type
            _Alloc_type;

    _List_node<_Tp>*
    _M_get_node()
    { return _Alloc_type::allocate(1); }

    void
    _M_put_node(_List_node<_Tp>* __p)
    { _Alloc_type::deallocate(__p, 1); }

    _List_node<_Tp>* _M_node;
  };







  template <typename _Tp, typename _Alloc>
    class _List_base
    : public _List_alloc_base<_Tp, _Alloc,
                              _Alloc_traits<_Tp, _Alloc>::_S_instanceless>
  {
  public:
    typedef _List_alloc_base<_Tp, _Alloc,
                             _Alloc_traits<_Tp, _Alloc>::_S_instanceless>
            _Base;
    typedef typename _Base::allocator_type allocator_type;

    _List_base(const allocator_type& __a)
    : _Base(__a)
    {
      _M_node = _M_get_node();
      _M_node->_M_next = _M_node;
      _M_node->_M_prev = _M_node;
    }


    ~_List_base()
    {
      __clear();
      _M_put_node(_M_node);
    }

    void
    __clear();
  };
# 365 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc = allocator<_Tp> >
    class list : protected _List_base<_Tp, _Alloc>
  {

   

    typedef _List_base<_Tp, _Alloc> _Base;

  public:
    typedef _Tp value_type;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef _List_iterator<_Tp,_Tp&,_Tp*> iterator;
    typedef _List_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef typename _Base::allocator_type allocator_type;

  protected:

    typedef _List_node<_Tp> _Node;







    using _Base::_M_node;
    using _Base::_M_put_node;
    using _Base::_M_get_node;
# 408 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_list.h" 3
    _Node*
    _M_create_node(const value_type& __x)
    {
      _Node* __p = _M_get_node();
      try {
        _Construct(&__p->_M_data, __x);
      }
      catch(...)
      {
        _M_put_node(__p);
        throw;
      }
      return __p;
    }







    _Node*
    _M_create_node()
    {
      _Node* __p = _M_get_node();
      try {
        _Construct(&__p->_M_data);
      }
      catch(...)
      {
        _M_put_node(__p);
        throw;
      }
      return __p;
    }

  public:





    explicit
    list(const allocator_type& __a = allocator_type())
    : _Base(__a) { }
# 461 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_list.h" 3
    list(size_type __n, const value_type& __value,
         const allocator_type& __a = allocator_type())
      : _Base(__a)
      { this->insert(begin(), __n, __value); }
# 473 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_list.h" 3
    explicit
    list(size_type __n)
      : _Base(allocator_type())
      { this->insert(begin(), __n, value_type()); }
# 485 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_list.h" 3
    list(const list& __x)
      : _Base(__x.get_allocator())
      { this->insert(begin(), __x.begin(), __x.end()); }
# 502 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_list.h" 3
    template<typename _InputIterator>
      list(_InputIterator __first, _InputIterator __last,
           const allocator_type& __a = allocator_type())
      : _Base(__a)
      { this->insert(begin(), __first, __last); }






    ~list() { }
# 522 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_list.h" 3
    list&
    operator=(const list& __x);
# 535 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_list.h" 3
    void
    assign(size_type __n, const value_type& __val) { _M_fill_assign(__n, __val); }
# 550 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_list.h" 3
    template<typename _InputIterator>
      void
      assign(_InputIterator __first, _InputIterator __last)
      {

        typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
        _M_assign_dispatch(__first, __last, _Integral());
      }


    allocator_type
    get_allocator() const { return _Base::get_allocator(); }






    iterator
    begin() { return static_cast<_Node*>(_M_node->_M_next); }





    const_iterator
    begin() const { return static_cast<_Node*>(_M_node->_M_next); }





    iterator
    end() { return _M_node; }





    const_iterator
    end() const { return _M_node; }





    reverse_iterator
    rbegin() { return reverse_iterator(end()); }





    const_reverse_iterator
    rbegin() const { return const_reverse_iterator(end()); }






    reverse_iterator
    rend() { return reverse_iterator(begin()); }






    const_reverse_iterator
    rend() const
    { return const_reverse_iterator(begin()); }





    bool
    empty() const { return _M_node->_M_next == _M_node; }


    size_type
    size() const { return distance(begin(), end()); }


    size_type
    max_size() const { return size_type(-1); }
# 648 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_list.h" 3
    void
    resize(size_type __new_size, const value_type& __x);
# 660 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_list.h" 3
    void
    resize(size_type __new_size) { this->resize(__new_size, value_type()); }






    reference
    front() { return *begin(); }





    const_reference
    front() const { return *begin(); }





    reference
    back() { return *(--end()); }





    const_reference
    back() const { return *(--end()); }
# 702 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_list.h" 3
    void
    push_front(const value_type& __x) { this->insert(begin(), __x); }
# 733 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_list.h" 3
    void
    pop_front() { this->erase(begin()); }
# 745 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_list.h" 3
    void
    push_back(const value_type& __x) { this->insert(end(), __x); }
# 776 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_list.h" 3
    void
    pop_back()
    {
      iterator __tmp = end();
      this->erase(--__tmp);
    }
# 794 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_list.h" 3
    iterator
    insert(iterator __position, const value_type& __x);
# 829 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_list.h" 3
    void
    insert(iterator __pos, size_type __n, const value_type& __x)
    { _M_fill_insert(__pos, __n, __x); }
# 845 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_list.h" 3
    template<typename _InputIterator>
      void
      insert(iterator __pos, _InputIterator __first, _InputIterator __last)
      {

        typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
        _M_insert_dispatch(__pos, __first, __last, _Integral());
      }
# 870 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_list.h" 3
    iterator
    erase(iterator __position);
# 892 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_list.h" 3
    iterator
    erase(iterator __first, iterator __last)
    {
      while (__first != __last)
        erase(__first++);
      return __last;
    }
# 909 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_list.h" 3
    void
    swap(list& __x) { std::swap(_M_node, __x._M_node); }







    void
    clear() { _Base::__clear(); }





    void
    splice(iterator __position, list& __x)
    {
      if (!__x.empty())
        this->_M_transfer(__position, __x.begin(), __x.end());
    }




    void
    splice(iterator __position, list&, iterator __i)
    {
      iterator __j = __i;
      ++__j;
      if (__position == __i || __position == __j) return;
      this->_M_transfer(__position, __i, __j);
    }




    void
    splice(iterator __position, list&, iterator __first, iterator __last)
    {
      if (__first != __last)
        this->_M_transfer(__position, __first, __last);
    }




    void
    remove(const _Tp& __value);




    template<typename _Predicate>
      void
      remove_if(_Predicate);




    void
    unique();




    template<typename _BinaryPredicate>
      void
      unique(_BinaryPredicate);




    void
    merge(list& __x);




    template<typename _StrictWeakOrdering>
      void
      merge(list&, _StrictWeakOrdering);




    void
    reverse() { __List_base_reverse(this->_M_node); }




    void
    sort();




    template<typename _StrictWeakOrdering>
      void
      sort(_StrictWeakOrdering);

  protected:



    template<typename _Integer>
      void
      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
      {
        _M_fill_assign(static_cast<size_type>(__n),
                       static_cast<value_type>(__val));
      }


    template<typename _InputIter>
      void
      _M_assign_dispatch(_InputIter __first, _InputIter __last, __false_type);



    void
    _M_fill_assign(size_type __n, const value_type& __val);





    template<typename _Integer>
      void
      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
                         __true_type)
      {
        _M_fill_insert(__pos, static_cast<size_type>(__n),
                       static_cast<value_type>(__x));
      }


    template<typename _InputIterator>
      void
      _M_insert_dispatch(iterator __pos,
                         _InputIterator __first, _InputIterator __last,
                         __false_type)
      {
        for ( ; __first != __last; ++__first)
          insert(__pos, *__first);
      }



    void
    _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)
    {
      for ( ; __n > 0; --__n)
        insert(__pos, __x);
    }



    void
    _M_transfer(iterator __position, iterator __first, iterator __last)
    {
      if (__position != __last) {

        __last._M_node->_M_prev->_M_next = __position._M_node;
        __first._M_node->_M_prev->_M_next = __last._M_node;
        __position._M_node->_M_prev->_M_next = __first._M_node;


        _List_node_base* __tmp = __position._M_node->_M_prev;
        __position._M_node->_M_prev = __last._M_node->_M_prev;
        __last._M_node->_M_prev = __first._M_node->_M_prev;
        __first._M_node->_M_prev = __tmp;
      }
    }
  };
# 1098 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
  inline bool
    operator==(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)
    {
      typedef typename list<_Tp,_Alloc>::const_iterator const_iterator;
      const_iterator __end1 = __x.end();
      const_iterator __end2 = __y.end();

      const_iterator __i1 = __x.begin();
      const_iterator __i2 = __y.begin();
      while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2) {
        ++__i1;
        ++__i2;
      }
      return __i1 == __end1 && __i2 == __end2;
    }
# 1126 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)
    {
      return lexicographical_compare(__x.begin(), __x.end(),
                                     __y.begin(), __y.end());
    }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)
    { __x.swap(__y); }
}
# 72 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/list" 2 3


# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/list.tcc" 1 3
# 64 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/list.tcc" 3
namespace std
{
  template<typename _Tp, typename _Alloc>
    void
    _List_base<_Tp,_Alloc>::
    __clear()
    {
      typedef _List_node<_Tp> _Node;
      _Node* __cur = static_cast<_Node*>(_M_node->_M_next);
      while (__cur != _M_node)
      {
        _Node* __tmp = __cur;
        __cur = static_cast<_Node*>(__cur->_M_next);
        _Destroy(&__tmp->_M_data);
        _M_put_node(__tmp);
      }
      _M_node->_M_next = _M_node;
      _M_node->_M_prev = _M_node;
    }

  template<typename _Tp, typename _Alloc>
    typename list<_Tp,_Alloc>::iterator
    list<_Tp,_Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      _Node* __tmp = _M_create_node(__x);
      __tmp->_M_next = __position._M_node;
      __tmp->_M_prev = __position._M_node->_M_prev;
      __position._M_node->_M_prev->_M_next = __tmp;
      __position._M_node->_M_prev = __tmp;
      return __tmp;
    }

  template<typename _Tp, typename _Alloc>
    typename list<_Tp,_Alloc>::iterator
    list<_Tp,_Alloc>::
    erase(iterator __position)
    {
      _List_node_base* __next_node = __position._M_node->_M_next;
      _List_node_base* __prev_node = __position._M_node->_M_prev;
      _Node* __n = static_cast<_Node*>(__position._M_node);
      __prev_node->_M_next = __next_node;
      __next_node->_M_prev = __prev_node;
      _Destroy(&__n->_M_data);
      _M_put_node(__n);
      return iterator(static_cast<_Node*>(__next_node));
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp,_Alloc>::
    resize(size_type __new_size, const value_type& __x)
    {
      iterator __i = begin();
      size_type __len = 0;
      for ( ; __i != end() && __len < __new_size; ++__i, ++__len)
        ;
      if (__len == __new_size)
        erase(__i, end());
      else
        insert(end(), __new_size - __len, __x);
    }

  template<typename _Tp, typename _Alloc>
    list<_Tp,_Alloc>&
    list<_Tp,_Alloc>::
    operator=(const list& __x)
    {
      if (this != &__x)
      {
        iterator __first1 = begin();
        iterator __last1 = end();
        const_iterator __first2 = __x.begin();
        const_iterator __last2 = __x.end();
        while (__first1 != __last1 && __first2 != __last2)
          *__first1++ = *__first2++;
        if (__first2 == __last2)
          erase(__first1, __last1);
        else
          insert(__last1, __first2, __last2);
      }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp,_Alloc>::
    _M_fill_assign(size_type __n, const value_type& __val)
    {
      iterator __i = begin();
      for ( ; __i != end() && __n > 0; ++__i, --__n)
        *__i = __val;
      if (__n > 0)
        insert(end(), __n, __val);
      else
        erase(__i, end());
    }

  template<typename _Tp, typename _Alloc>
    template <typename _InputIter>
      void
      list<_Tp,_Alloc>::
      _M_assign_dispatch(_InputIter __first2, _InputIter __last2, __false_type)
      {
        iterator __first1 = begin();
        iterator __last1 = end();
        for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)
          *__first1 = *__first2;
        if (__first2 == __last2)
          erase(__first1, __last1);
        else
          insert(__last1, __first2, __last2);
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp,_Alloc>::
    remove(const value_type& __value)
    {
      iterator __first = begin();
      iterator __last = end();
      while (__first != __last)
      {
        iterator __next = __first;
        ++__next;
        if (*__first == __value)
          erase(__first);
        __first = __next;
      }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp,_Alloc>::
    unique()
    {
      iterator __first = begin();
      iterator __last = end();
      if (__first == __last) return;
      iterator __next = __first;
      while (++__next != __last)
      {
        if (*__first == *__next)
          erase(__next);
        else
          __first = __next;
        __next = __first;
      }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp,_Alloc>::
    merge(list& __x)
    {
      iterator __first1 = begin();
      iterator __last1 = end();
      iterator __first2 = __x.begin();
      iterator __last2 = __x.end();
      while (__first1 != __last1 && __first2 != __last2)
        if (*__first2 < *__first1)
        {
          iterator __next = __first2;
          _M_transfer(__first1, __first2, ++__next);
          __first2 = __next;
        }
        else
          ++__first1;
      if (__first2 != __last2)
        _M_transfer(__last1, __first2, __last2);
    }


  inline void
  __List_base_reverse(_List_node_base* __p)
  {
    _List_node_base* __tmp = __p;
    do {
      std::swap(__tmp->_M_next, __tmp->_M_prev);
      __tmp = __tmp->_M_prev;
    } while (__tmp != __p);
  }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp,_Alloc>::
    sort()
    {

      if (_M_node->_M_next != _M_node && _M_node->_M_next->_M_next != _M_node)
      {
        list __carry;
        list __counter[64];
        int __fill = 0;
        while (!empty())
        {
          __carry.splice(__carry.begin(), *this, begin());
          int __i = 0;
          while(__i < __fill && !__counter[__i].empty())
          {
            __counter[__i].merge(__carry);
            __carry.swap(__counter[__i++]);
          }
          __carry.swap(__counter[__i]);
          if (__i == __fill) ++__fill;
        }

        for (int __i = 1; __i < __fill; ++__i)
          __counter[__i].merge(__counter[__i-1]);
        swap(__counter[__fill-1]);
      }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _Predicate>
      void
      list<_Tp,_Alloc>::
      remove_if(_Predicate __pred)
      {
        iterator __first = begin();
        iterator __last = end();
        while (__first != __last)
        {
          iterator __next = __first;
          ++__next;
          if (__pred(*__first)) erase(__first);
          __first = __next;
        }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _BinaryPredicate>
      void
      list<_Tp,_Alloc>::
      unique(_BinaryPredicate __binary_pred)
      {
        iterator __first = begin();
        iterator __last = end();
        if (__first == __last) return;
        iterator __next = __first;
        while (++__next != __last)
        {
          if (__binary_pred(*__first, *__next))
            erase(__next);
          else
            __first = __next;
          __next = __first;
        }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp,_Alloc>::
      merge(list& __x, _StrictWeakOrdering __comp)
      {
        iterator __first1 = begin();
        iterator __last1 = end();
        iterator __first2 = __x.begin();
        iterator __last2 = __x.end();
        while (__first1 != __last1 && __first2 != __last2)
          if (__comp(*__first2, *__first1))
          {
            iterator __next = __first2;
            _M_transfer(__first1, __first2, ++__next);
            __first2 = __next;
          }
          else
            ++__first1;
        if (__first2 != __last2) _M_transfer(__last1, __first2, __last2);
      }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
    void
    list<_Tp,_Alloc>::
    sort(_StrictWeakOrdering __comp)
    {

      if (_M_node->_M_next != _M_node && _M_node->_M_next->_M_next != _M_node)
      {
        list __carry;
        list __counter[64];
        int __fill = 0;
        while (!empty())
        {
          __carry.splice(__carry.begin(), *this, begin());
          int __i = 0;
          while(__i < __fill && !__counter[__i].empty())
          {
            __counter[__i].merge(__carry, __comp);
            __carry.swap(__counter[__i++]);
          }
          __carry.swap(__counter[__i]);
          if (__i == __fill) ++__fill;
        }

        for (int __i = 1; __i < __fill; ++__i)
          __counter[__i].merge(__counter[__i-1], __comp);
        swap(__counter[__fill-1]);
      }
    }
}
# 75 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/list" 2 3
# 30 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/common/definitions.h" 2
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/queue" 1 3
# 65 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/queue" 3

# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/functexcept.h" 1 3
# 34 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/functexcept.h" 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/exception_defines.h" 1 3
# 35 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/functexcept.h" 2 3

namespace std
{

  void
  __throw_bad_exception(void);


  void
  __throw_bad_alloc(void);


  void
  __throw_bad_cast(void);

  void
  __throw_bad_typeid(void);


  void
  __throw_logic_error(const char* __s);

  void
  __throw_domain_error(const char* __s);

  void
  __throw_invalid_argument(const char* __s);

  void
  __throw_length_error(const char* __s);

  void
  __throw_out_of_range(const char* __s);

  void
  __throw_runtime_error(const char* __s);

  void
  __throw_range_error(const char* __s);

  void
  __throw_overflow_error(const char* __s);

  void
  __throw_underflow_error(const char* __s);


  void
  __throw_ios_failure(const char* __s);
}
# 67 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/queue" 2 3




# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_vector.h" 1 3
# 65 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_vector.h" 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/functexcept.h" 1 3
# 34 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/functexcept.h" 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/exception_defines.h" 1 3
# 35 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/functexcept.h" 2 3

namespace std
{

  void
  __throw_bad_exception(void);


  void
  __throw_bad_alloc(void);


  void
  __throw_bad_cast(void);

  void
  __throw_bad_typeid(void);


  void
  __throw_logic_error(const char* __s);

  void
  __throw_domain_error(const char* __s);

  void
  __throw_invalid_argument(const char* __s);

  void
  __throw_length_error(const char* __s);

  void
  __throw_out_of_range(const char* __s);

  void
  __throw_runtime_error(const char* __s);

  void
  __throw_range_error(const char* __s);

  void
  __throw_overflow_error(const char* __s);

  void
  __throw_underflow_error(const char* __s);


  void
  __throw_ios_failure(const char* __s);
}
# 66 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_vector.h" 2 3


namespace std
{






  template<typename _Tp, typename _Allocator, bool _IsStatic>
    class _Vector_alloc_base
    {
    public:
      typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type
      allocator_type;

      allocator_type
      get_allocator() const { return _M_data_allocator; }

      _Vector_alloc_base(const allocator_type& __a)
      : _M_data_allocator(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
      { }

    protected:
      allocator_type _M_data_allocator;
      _Tp* _M_start;
      _Tp* _M_finish;
      _Tp* _M_end_of_storage;

      _Tp*
      _M_allocate(size_t __n) { return _M_data_allocator.allocate(__n); }

      void
      _M_deallocate(_Tp* __p, size_t __n)
      { if (__p) _M_data_allocator.deallocate(__p, __n); }
    };


  template<typename _Tp, typename _Allocator>
    class _Vector_alloc_base<_Tp, _Allocator, true>
    {
    public:
      typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type
             allocator_type;

      allocator_type
      get_allocator() const { return allocator_type(); }

      _Vector_alloc_base(const allocator_type&)
      : _M_start(0), _M_finish(0), _M_end_of_storage(0)
      { }

    protected:
      _Tp* _M_start;
      _Tp* _M_finish;
      _Tp* _M_end_of_storage;

      typedef typename _Alloc_traits<_Tp, _Allocator>::_Alloc_type _Alloc_type;

      _Tp*
      _M_allocate(size_t __n) { return _Alloc_type::allocate(__n); }

      void
      _M_deallocate(_Tp* __p, size_t __n) { _Alloc_type::deallocate(__p, __n);}
    };







  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    : public _Vector_alloc_base<_Tp, _Alloc,
                                _Alloc_traits<_Tp, _Alloc>::_S_instanceless>
    {
    public:
      typedef _Vector_alloc_base<_Tp, _Alloc,
                                 _Alloc_traits<_Tp, _Alloc>::_S_instanceless>
         _Base;
      typedef typename _Base::allocator_type allocator_type;

      _Vector_base(const allocator_type& __a)
      : _Base(__a) { }

      _Vector_base(size_t __n, const allocator_type& __a)
      : _Base(__a)
      {
        _M_start = _M_allocate(__n);
        _M_finish = _M_start;
        _M_end_of_storage = _M_start + __n;
      }

      ~_Vector_base()
      { _M_deallocate(_M_start, _M_end_of_storage - _M_start); }
    };
# 184 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {

     

      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef vector<_Tp, _Alloc> vector_type;

    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, vector_type> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector_type>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef typename _Base::allocator_type allocator_type;

    protected:






      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_start;
      using _Base::_M_finish;
      using _Base::_M_end_of_storage;

    public:





      explicit
      vector(const allocator_type& __a = allocator_type())
      : _Base(__a) { }
# 238 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_vector.h" 3
      vector(size_type __n, const value_type& __value,
             const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_finish = uninitialized_fill_n(_M_start, __n, __value); }
# 250 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_vector.h" 3
      explicit
      vector(size_type __n)
      : _Base(__n, allocator_type())
      { _M_finish = uninitialized_fill_n(_M_start, __n, value_type()); }
# 264 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(), __x.get_allocator())
      { _M_finish = uninitialized_copy(__x.begin(), __x.end(), _M_start); }
# 282 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_vector.h" 3
      template<typename _InputIterator>
        vector(_InputIterator __first, _InputIterator __last,
               const allocator_type& __a = allocator_type())
        : _Base(__a)
        {

          typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
          _M_initialize_dispatch(__first, __last, _Integral());
        }






      ~vector() { _Destroy(_M_start, _M_finish); }
# 307 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
# 320 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 336 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {

          typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
          _M_assign_dispatch(__first, __last, _Integral());
        }


      allocator_type
      get_allocator() const { return _Base::get_allocator(); }






      iterator
      begin() { return iterator (_M_start); }






      const_iterator
      begin() const { return const_iterator (_M_start); }






      iterator
      end() { return iterator (_M_finish); }





      const_iterator
      end() const { return const_iterator (_M_finish); }






      reverse_iterator
      rbegin() { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const { return const_reverse_iterator(end()); }






      reverse_iterator
      rend() { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const { return const_reverse_iterator(begin()); }



      size_type
      size() const { return size_type(end() - begin()); }


      size_type
      max_size() const { return size_type(-1) / sizeof(value_type); }
# 432 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, const value_type& __x)
      {
        if (__new_size < size())
          erase(begin() + __new_size, end());
        else
          insert(end(), __new_size - size(), __x);
      }
# 451 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_vector.h" 3
      void
      resize(size_type __new_size) { resize(__new_size, value_type()); }





      size_type
      capacity() const
      { return size_type(const_iterator(_M_end_of_storage) - begin()); }





      bool
      empty() const { return begin() == end(); }
# 486 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
# 500 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_vector.h" 3
      reference
      operator[](size_type __n) { return *(begin() + __n); }
# 514 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const { return *(begin() + __n); }

    protected:

      void
      _M_range_check(size_type __n) const
      {
        if (__n >= this->size())
          __throw_out_of_range("vector [] access out of range");
      }

    public:
# 538 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_vector.h" 3
      reference
      at(size_type __n) { _M_range_check(__n); return (*this)[__n]; }
# 552 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const { _M_range_check(__n); return (*this)[__n]; }





      reference
      front() { return *begin(); }





      const_reference
      front() const { return *begin(); }





      reference
      back() { return *(end() - 1); }





      const_reference
      back() const { return *(end() - 1); }
# 594 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
        if (_M_finish != _M_end_of_storage)
          {
            _Construct(_M_finish, __x);
            ++_M_finish;
          }
        else
          _M_insert_aux(end(), __x);
      }
# 614 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_vector.h" 3
      void
      pop_back()
      {
        --_M_finish;
        _Destroy(_M_finish);
      }
# 632 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_vector.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 669 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_vector.h" 3
      void
      insert(iterator __pos, size_type __n, const value_type& __x)
      { _M_fill_insert(__pos, __n, __x); }
# 687 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __pos, _InputIterator __first, _InputIterator __last)
        {

          typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
          _M_insert_dispatch(__pos, __first, __last, _Integral());
        }
# 711 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_vector.h" 3
      iterator
      erase(iterator __position);
# 732 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_vector.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 744 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_vector.h" 3
      void
      swap(vector& __x)
      {
        std::swap(_M_start, __x._M_start);
        std::swap(_M_finish, __x._M_finish);
        std::swap(_M_end_of_storage, __x._M_end_of_storage);
      }







      void
      clear() { erase(begin(), end()); }

    protected:






      template<typename _ForwardIterator>
        pointer
        _M_allocate_and_copy(size_type __n,
                             _ForwardIterator __first, _ForwardIterator __last)
        {
          pointer __result = _M_allocate(__n);
          try
            {
              uninitialized_copy(__first, __last, __result);
              return __result;
            }
          catch(...)
            {
              _M_deallocate(__result, __n);
              throw;
            }
        }





      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
        {
          _M_start = _M_allocate(__n);
          _M_end_of_storage = _M_start + __n;
          _M_finish = uninitialized_fill_n(_M_start, __n, __value);
        }


      template<typename _InputIter>
        void
        _M_initialize_dispatch(_InputIter __first, _InputIter __last,
                               __false_type)
        {
          typedef typename iterator_traits<_InputIter>::iterator_category
            _IterCategory;
          _M_range_initialize(__first, __last, _IterCategory());
        }


      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first,
                            _InputIterator __last, input_iterator_tag)
        {
          for ( ; __first != __last; ++__first)
            push_back(*__first);
        }


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first,
                            _ForwardIterator __last, forward_iterator_tag)
        {
          size_type __n = distance(__first, __last);
          _M_start = _M_allocate(__n);
          _M_end_of_storage = _M_start + __n;
          _M_finish = uninitialized_copy(__first, __last, _M_start);
        }






      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        {
          _M_fill_assign(static_cast<size_type>(__n),
                         static_cast<value_type>(__val));
        }


      template<typename _InputIter>
        void
        _M_assign_dispatch(_InputIter __first, _InputIter __last, __false_type)
        {
          typedef typename iterator_traits<_InputIter>::iterator_category
            _IterCategory;
          _M_assign_aux(__first, __last, _IterCategory());
        }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
                      input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                      forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);





      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
                           __true_type)
        {
          _M_fill_insert(__pos, static_cast<size_type>(__n),
                         static_cast<value_type>(__val));
        }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos, _InputIterator __first,
                           _InputIterator __last, __false_type)
        {
          typedef typename iterator_traits<_InputIterator>::iterator_category
            _IterCategory;
          _M_range_insert(__pos, __first, __last, _IterCategory());
        }


      template<typename _InputIterator>
        void
        _M_range_insert(iterator __pos, _InputIterator __first,
                        _InputIterator __last, input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert(iterator __pos, _ForwardIterator __first,
                        _ForwardIterator __last, forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);


      void
      _M_insert_aux(iterator __position, const value_type& __x);





    };
# 934 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)
    {
      return __x.size() == __y.size() &&
             equal(__x.begin(), __x.end(), __y.begin());
    }
# 953 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)
    {
      return lexicographical_compare(__x.begin(), __x.end(),
                                     __y.begin(), __y.end());
    }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp,_Alloc>& __x, const vector<_Tp,_Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp,_Alloc>& __x, vector<_Tp,_Alloc>& __y)
    { __x.swap(__y); }
}
# 72 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/queue" 2 3

# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 1 3
# 68 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
namespace std
{
# 82 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
  inline size_t
  __deque_buf_size(size_t __size)
  { return __size < 512 ? size_t(512 / __size) : size_t(1); }
# 99 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
  template <typename _Tp, typename _Ref, typename _Ptr>
    struct _Deque_iterator
  {
    typedef _Deque_iterator<_Tp, _Tp&, _Tp*> iterator;
    typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;
    static size_t _S_buffer_size() { return __deque_buf_size(sizeof(_Tp)); }

    typedef random_access_iterator_tag iterator_category;
    typedef _Tp value_type;
    typedef _Ptr pointer;
    typedef _Ref reference;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Tp** _Map_pointer;
    typedef _Deque_iterator _Self;

    _Tp* _M_cur;
    _Tp* _M_first;
    _Tp* _M_last;
    _Map_pointer _M_node;

    _Deque_iterator(_Tp* __x, _Map_pointer __y)
      : _M_cur(__x), _M_first(*__y),
        _M_last(*__y + _S_buffer_size()), _M_node(__y) {}
    _Deque_iterator() : _M_cur(0), _M_first(0), _M_last(0), _M_node(0) {}
    _Deque_iterator(const iterator& __x)
      : _M_cur(__x._M_cur), _M_first(__x._M_first),
        _M_last(__x._M_last), _M_node(__x._M_node) {}

    reference operator*() const { return *_M_cur; }
    pointer operator->() const { return _M_cur; }

    _Self& operator++() {
      ++_M_cur;
      if (_M_cur == _M_last) {
        _M_set_node(_M_node + 1);
        _M_cur = _M_first;
      }
      return *this;
    }
    _Self operator++(int) {
      _Self __tmp = *this;
      ++*this;
      return __tmp;
    }

    _Self& operator--() {
      if (_M_cur == _M_first) {
        _M_set_node(_M_node - 1);
        _M_cur = _M_last;
      }
      --_M_cur;
      return *this;
    }
    _Self operator--(int) {
      _Self __tmp = *this;
      --*this;
      return __tmp;
    }

    _Self& operator+=(difference_type __n)
    {
      difference_type __offset = __n + (_M_cur - _M_first);
      if (__offset >= 0 && __offset < difference_type(_S_buffer_size()))
        _M_cur += __n;
      else {
        difference_type __node_offset =
          __offset > 0 ? __offset / difference_type(_S_buffer_size())
                     : -difference_type((-__offset - 1) / _S_buffer_size()) - 1;
        _M_set_node(_M_node + __node_offset);
        _M_cur = _M_first +
          (__offset - __node_offset * difference_type(_S_buffer_size()));
      }
      return *this;
    }

    _Self operator+(difference_type __n) const
    {
      _Self __tmp = *this;
      return __tmp += __n;
    }

    _Self& operator-=(difference_type __n) { return *this += -__n; }

    _Self operator-(difference_type __n) const {
      _Self __tmp = *this;
      return __tmp -= __n;
    }

    reference operator[](difference_type __n) const { return *(*this + __n); }







    void
    _M_set_node(_Map_pointer __new_node)
    {
      _M_node = __new_node;
      _M_first = *__new_node;
      _M_last = _M_first + difference_type(_S_buffer_size());
    }
  };




  template <typename _Tp, typename _Ref, typename _Ptr>
  inline bool
  operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
           const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
  {
    return __x._M_cur == __y._M_cur;
  }

  template <typename _Tp, typename _RefL, typename _PtrL,
                          typename _RefR, typename _PtrR>
  inline bool
  operator==(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
           const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
  {
    return __x._M_cur == __y._M_cur;
  }

  template <typename _Tp, typename _Ref, typename _Ptr>
  inline bool
  operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
           const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
  {
    return !(__x == __y);
  }

  template <typename _Tp, typename _RefL, typename _PtrL,
                          typename _RefR, typename _PtrR>
  inline bool
  operator!=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
           const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
  {
    return !(__x == __y);
  }

  template <typename _Tp, typename _Ref, typename _Ptr>
  inline bool
  operator<(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
           const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
  {
    return (__x._M_node == __y._M_node) ?
      (__x._M_cur < __y._M_cur) : (__x._M_node < __y._M_node);
  }

  template <typename _Tp, typename _RefL, typename _PtrL,
                          typename _RefR, typename _PtrR>
  inline bool
  operator<(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
           const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
  {
    return (__x._M_node == __y._M_node) ?
      (__x._M_cur < __y._M_cur) : (__x._M_node < __y._M_node);
  }

  template <typename _Tp, typename _Ref, typename _Ptr>
  inline bool
  operator>(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
           const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
  {
    return __y < __x;
  }

  template <typename _Tp, typename _RefL, typename _PtrL,
                          typename _RefR, typename _PtrR>
  inline bool
  operator>(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
           const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
  {
    return __y < __x;
  }

  template <typename _Tp, typename _Ref, typename _Ptr>
  inline bool
  operator<=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
           const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
  {
    return !(__y < __x);
  }

  template <typename _Tp, typename _RefL, typename _PtrL,
                          typename _RefR, typename _PtrR>
  inline bool
  operator<=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
           const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
  {
    return !(__y < __x);
  }

  template <typename _Tp, typename _Ref, typename _Ptr>
  inline bool
  operator>=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
           const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
  {
    return !(__x < __y);
  }

  template <typename _Tp, typename _RefL, typename _PtrL,
                          typename _RefR, typename _PtrR>
  inline bool
  operator>=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
           const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
  {
    return !(__x < __y);
  }





  template <typename _Tp, typename _RefL, typename _PtrL,
                          typename _RefR, typename _PtrR>
  inline typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
  operator-(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
          const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
  {
    return _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
      (_Deque_iterator<_Tp, _RefL, _PtrL>::_S_buffer_size()) *
      (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first) +
      (__y._M_last - __y._M_cur);
  }

  template <typename _Tp, typename _Ref, typename _Ptr>
  inline _Deque_iterator<_Tp, _Ref, _Ptr>
  operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)
  {
    return __x + __n;
  }
# 348 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
  template <typename _Tp, typename _Alloc, bool __is_static>
    class _Deque_alloc_base
  {
  public:
    typedef typename _Alloc_traits<_Tp,_Alloc>::allocator_type allocator_type;
    allocator_type get_allocator() const { return _M_node_allocator; }

    _Deque_alloc_base(const allocator_type& __a)
      : _M_node_allocator(__a), _M_map_allocator(__a),
        _M_map(0), _M_map_size(0)
    {}

  protected:
    typedef typename _Alloc_traits<_Tp*, _Alloc>::allocator_type
            _Map_allocator_type;

    _Tp*
    _M_allocate_node()
    {
      return _M_node_allocator.allocate(__deque_buf_size(sizeof(_Tp)));
    }

    void
    _M_deallocate_node(_Tp* __p)
    {
      _M_node_allocator.deallocate(__p, __deque_buf_size(sizeof(_Tp)));
    }

    _Tp**
    _M_allocate_map(size_t __n)
      { return _M_map_allocator.allocate(__n); }

    void
    _M_deallocate_map(_Tp** __p, size_t __n)
      { _M_map_allocator.deallocate(__p, __n); }

    allocator_type _M_node_allocator;
    _Map_allocator_type _M_map_allocator;
    _Tp** _M_map;
    size_t _M_map_size;
  };


  template <typename _Tp, typename _Alloc>
    class _Deque_alloc_base<_Tp, _Alloc, true>
  {
  public:
    typedef typename _Alloc_traits<_Tp,_Alloc>::allocator_type allocator_type;
    allocator_type get_allocator() const { return allocator_type(); }

    _Deque_alloc_base(const allocator_type&)
      : _M_map(0), _M_map_size(0)
    {}

  protected:
    typedef typename _Alloc_traits<_Tp,_Alloc>::_Alloc_type _Node_alloc_type;
    typedef typename _Alloc_traits<_Tp*,_Alloc>::_Alloc_type _Map_alloc_type;

    _Tp*
    _M_allocate_node()
    {
      return _Node_alloc_type::allocate(__deque_buf_size(sizeof(_Tp)));
    }

    void
    _M_deallocate_node(_Tp* __p)
    {
      _Node_alloc_type::deallocate(__p, __deque_buf_size(sizeof(_Tp)));
    }

    _Tp**
    _M_allocate_map(size_t __n)
      { return _Map_alloc_type::allocate(__n); }

    void
    _M_deallocate_map(_Tp** __p, size_t __n)
      { _Map_alloc_type::deallocate(__p, __n); }

    _Tp** _M_map;
    size_t _M_map_size;
  };
# 442 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
  template <typename _Tp, typename _Alloc>
    class _Deque_base
    : public _Deque_alloc_base<_Tp,_Alloc,
                                _Alloc_traits<_Tp, _Alloc>::_S_instanceless>
  {
  public:
    typedef _Deque_alloc_base<_Tp,_Alloc,
                               _Alloc_traits<_Tp, _Alloc>::_S_instanceless>
            _Base;
    typedef typename _Base::allocator_type allocator_type;
    typedef _Deque_iterator<_Tp,_Tp&,_Tp*> iterator;
    typedef _Deque_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;

    _Deque_base(const allocator_type& __a, size_t __num_elements)
      : _Base(__a), _M_start(), _M_finish()
      { _M_initialize_map(__num_elements); }
    _Deque_base(const allocator_type& __a)
      : _Base(__a), _M_start(), _M_finish() {}
    ~_Deque_base();

  protected:
    void _M_initialize_map(size_t);
    void _M_create_nodes(_Tp** __nstart, _Tp** __nfinish);
    void _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish);
    enum { _S_initial_map_size = 8 };

    iterator _M_start;
    iterator _M_finish;
  };


  template <typename _Tp, typename _Alloc>
  _Deque_base<_Tp,_Alloc>::~_Deque_base()
  {
    if (_M_map)
    {
      _M_destroy_nodes(_M_start._M_node, _M_finish._M_node + 1);
      _M_deallocate_map(_M_map, _M_map_size);
    }
  }
# 493 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
  template <typename _Tp, typename _Alloc>
  void
  _Deque_base<_Tp,_Alloc>::_M_initialize_map(size_t __num_elements)
  {
    size_t __num_nodes =
      __num_elements / __deque_buf_size(sizeof(_Tp)) + 1;

    _M_map_size = max((size_t) _S_initial_map_size, __num_nodes + 2);
    _M_map = _M_allocate_map(_M_map_size);





    _Tp** __nstart = _M_map + (_M_map_size - __num_nodes) / 2;
    _Tp** __nfinish = __nstart + __num_nodes;

    try
      { _M_create_nodes(__nstart, __nfinish); }
    catch(...)
      {
        _M_deallocate_map(_M_map, _M_map_size);
        _M_map = 0;
        _M_map_size = 0;
        throw;
      }

    _M_start._M_set_node(__nstart);
    _M_finish._M_set_node(__nfinish - 1);
    _M_start._M_cur = _M_start._M_first;
    _M_finish._M_cur = _M_finish._M_first +
                       __num_elements % __deque_buf_size(sizeof(_Tp));
  }

  template <typename _Tp, typename _Alloc>
  void _Deque_base<_Tp,_Alloc>::_M_create_nodes(_Tp** __nstart, _Tp** __nfinish)
  {
    _Tp** __cur;
    try
      {
        for (__cur = __nstart; __cur < __nfinish; ++__cur)
          *__cur = _M_allocate_node();
      }
    catch(...)
      {
        _M_destroy_nodes(__nstart, __cur);
        throw;
      }
  }

  template <typename _Tp, typename _Alloc>
  void
  _Deque_base<_Tp,_Alloc>::_M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish)
  {
    for (_Tp** __n = __nstart; __n < __nfinish; ++__n)
      _M_deallocate_node(*__n);
  }
# 636 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
  template <typename _Tp, typename _Alloc = allocator<_Tp> >
    class deque : protected _Deque_base<_Tp, _Alloc>
  {

   

    typedef _Deque_base<_Tp, _Alloc> _Base;

  public:
    typedef _Tp value_type;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef typename _Base::iterator iterator;
    typedef typename _Base::const_iterator const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef typename _Base::allocator_type allocator_type;

  protected:
    typedef pointer* _Map_pointer;
    static size_t _S_buffer_size() { return __deque_buf_size(sizeof(_Tp)); }


    using _Base::_M_initialize_map;
    using _Base::_M_create_nodes;
    using _Base::_M_destroy_nodes;
    using _Base::_M_allocate_node;
    using _Base::_M_deallocate_node;
    using _Base::_M_allocate_map;
    using _Base::_M_deallocate_map;







    using _Base::_M_map;
    using _Base::_M_map_size;
    using _Base::_M_start;
    using _Base::_M_finish;

  public:





    explicit
    deque(const allocator_type& __a = allocator_type())
      : _Base(__a, 0) {}
# 699 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
    deque(size_type __n, const value_type& __value,
          const allocator_type& __a = allocator_type())
      : _Base(__a, __n)
      { _M_fill_initialize(__value); }
# 711 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
    explicit
    deque(size_type __n)
      : _Base(allocator_type(), __n)
      { _M_fill_initialize(value_type()); }
# 723 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
    deque(const deque& __x)
      : _Base(__x.get_allocator(), __x.size())
      { uninitialized_copy(__x.begin(), __x.end(), _M_start); }
# 740 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
    template<typename _InputIterator>
      deque(_InputIterator __first, _InputIterator __last,
            const allocator_type& __a = allocator_type())
        : _Base(__a)
      {

        typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
        _M_initialize_dispatch(__first, __last, _Integral());
      }






    ~deque() { _Destroy(_M_start, _M_finish); }
# 764 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
    deque&
    operator=(const deque& __x);
# 777 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
    void
    assign(size_type __n, const value_type& __val) { _M_fill_assign(__n, __val); }
# 792 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
    template<typename _InputIterator>
      void
      assign(_InputIterator __first, _InputIterator __last)
      {
        typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
        _M_assign_dispatch(__first, __last, _Integral());
      }


    allocator_type
    get_allocator() const { return _Base::get_allocator(); }






    iterator
    begin() { return _M_start; }





    const_iterator
    begin() const { return _M_start; }





    iterator
    end() { return _M_finish; }





    const_iterator
    end() const { return _M_finish; }





    reverse_iterator
    rbegin() { return reverse_iterator(_M_finish); }





    const_reverse_iterator
    rbegin() const { return const_reverse_iterator(_M_finish); }






    reverse_iterator
    rend() { return reverse_iterator(_M_start); }






    const_reverse_iterator
    rend() const { return const_reverse_iterator(_M_start); }



    size_type
    size() const { return _M_finish - _M_start; }


    size_type
    max_size() const { return size_type(-1); }
# 882 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
    void
    resize(size_type __new_size, const value_type& __x)
    {
      const size_type __len = size();
      if (__new_size < __len)
        erase(_M_start + __new_size, _M_finish);
      else
        insert(_M_finish, __new_size - __len, __x);
    }
# 901 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
    void
    resize(size_type new_size) { resize(new_size, value_type()); }




    bool empty() const { return _M_finish == _M_start; }
# 919 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
    reference
    operator[](size_type __n) { return _M_start[difference_type(__n)]; }
# 931 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
    const_reference
    operator[](size_type __n) const { return _M_start[difference_type(__n)]; }

  protected:

    void
    _M_range_check(size_type __n) const
    {
      if (__n >= this->size())
        __throw_out_of_range("deque [] access out of range");
    }

  public:
# 954 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
    reference
    at(size_type __n) { _M_range_check(__n); return (*this)[__n]; }
# 967 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
    const_reference
    at(size_type __n) const { _M_range_check(__n); return (*this)[__n]; }





    reference
    front() { return *_M_start; }





    const_reference
    front() const { return *_M_start; }





    reference
    back()
    {
      iterator __tmp = _M_finish;
      --__tmp;
      return *__tmp;
    }





    const_reference
    back() const
    {
      const_iterator __tmp = _M_finish;
      --__tmp;
      return *__tmp;
    }
# 1017 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
    void
    push_front(const value_type& __x)
    {
      if (_M_start._M_cur != _M_start._M_first) {
        _Construct(_M_start._M_cur - 1, __x);
        --_M_start._M_cur;
      }
      else
        _M_push_front_aux(__x);
    }
# 1061 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
    void
    push_back(const value_type& __x)
    {
      if (_M_finish._M_cur != _M_finish._M_last - 1) {
        _Construct(_M_finish._M_cur, __x);
        ++_M_finish._M_cur;
      }
      else
        _M_push_back_aux(__x);
    }
# 1105 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
    void
    pop_front()
    {
      if (_M_start._M_cur != _M_start._M_last - 1) {
        _Destroy(_M_start._M_cur);
        ++_M_start._M_cur;
      }
      else
        _M_pop_front_aux();
    }
# 1124 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
    void
    pop_back()
    {
      if (_M_finish._M_cur != _M_finish._M_first) {
        --_M_finish._M_cur;
        _Destroy(_M_finish._M_cur);
      }
      else
        _M_pop_back_aux();
    }
# 1144 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
    iterator
    insert(iterator position, const value_type& __x);
# 1175 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
    void
    insert(iterator __position, size_type __n, const value_type& __x)
    { _M_fill_insert(__position, __n, __x); }
# 1189 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
    template<typename _InputIterator>
      void
      insert(iterator __pos, _InputIterator __first, _InputIterator __last)
      {

        typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
        _M_insert_dispatch(__pos, __first, __last, _Integral());
      }
# 1211 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
    iterator
    erase(iterator __position);
# 1230 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
    iterator
    erase(iterator __first, iterator __last);
# 1242 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
    void
    swap(deque& __x)
    {
      std::swap(_M_start, __x._M_start);
      std::swap(_M_finish, __x._M_finish);
      std::swap(_M_map, __x._M_map);
      std::swap(_M_map_size, __x._M_map_size);
    }







    void clear();

  protected:



    template<typename _Integer>
      void
      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
      {
        _M_initialize_map(__n);
        _M_fill_initialize(__x);
      }


    template<typename _InputIter>
      void
      _M_initialize_dispatch(_InputIter __first, _InputIter __last,
                             __false_type)
      {
        typedef typename iterator_traits<_InputIter>::iterator_category
                         _IterCategory;
        _M_range_initialize(__first, __last, _IterCategory());
      }
# 1296 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
    template <typename _InputIterator>
      void
      _M_range_initialize(_InputIterator __first, _InputIterator __last,
                          input_iterator_tag);


    template <typename _ForwardIterator>
      void
      _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
                          forward_iterator_tag);
# 1320 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
    void
    _M_fill_initialize(const value_type& __value);






    template<typename _Integer>
      void
      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
      {
        _M_fill_assign(static_cast<size_type>(__n),
                       static_cast<value_type>(__val));
      }


    template<typename _InputIter>
      void
      _M_assign_dispatch(_InputIter __first, _InputIter __last, __false_type)
      {
        typedef typename iterator_traits<_InputIter>::iterator_category
                         _IterCategory;
        _M_assign_aux(__first, __last, _IterCategory());
      }


    template <typename _InputIterator>
      void
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
                    input_iterator_tag);


    template <typename _ForwardIterator>
      void
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                    forward_iterator_tag)
      {
        size_type __len = distance(__first, __last);
        if (__len > size()) {
          _ForwardIterator __mid = __first;
          advance(__mid, size());
          copy(__first, __mid, begin());
          insert(end(), __mid, __last);
        }
        else
          erase(copy(__first, __last, begin()), end());
      }



    void
    _M_fill_assign(size_type __n, const value_type& __val)
    {
      if (__n > size())
      {
        fill(begin(), end(), __val);
        insert(end(), __n - size(), __val);
      }
      else
      {
        erase(begin() + __n, end());
        fill(begin(), end(), __val);
      }
    }
# 1393 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
    void _M_push_back_aux(const value_type&);
    void _M_push_front_aux(const value_type&);




    void _M_pop_back_aux();
    void _M_pop_front_aux();







    template<typename _Integer>
      void
      _M_insert_dispatch(iterator __pos,
                         _Integer __n, _Integer __x, __true_type)
      {
        _M_fill_insert(__pos, static_cast<size_type>(__n),
                       static_cast<value_type>(__x));
      }


    template<typename _InputIterator>
      void
      _M_insert_dispatch(iterator __pos,
                         _InputIterator __first, _InputIterator __last,
                         __false_type)
      {
        typedef typename iterator_traits<_InputIterator>::iterator_category
                         _IterCategory;
        _M_range_insert_aux(__pos, __first, __last, _IterCategory());
      }


    template <typename _InputIterator>
      void
      _M_range_insert_aux(iterator __pos, _InputIterator __first,
                          _InputIterator __last, input_iterator_tag);


    template <typename _ForwardIterator>
      void
      _M_range_insert_aux(iterator __pos, _ForwardIterator __first,
                          _ForwardIterator __last, forward_iterator_tag);




    void
    _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);


    iterator
    _M_insert_aux(iterator __pos, const value_type& __x);


    void
    _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);


    template <typename _ForwardIterator>
      void
      _M_insert_aux(iterator __pos,
                    _ForwardIterator __first, _ForwardIterator __last,
                    size_type __n);
# 1474 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
    iterator
    _M_reserve_elements_at_front(size_type __n)
    {
      size_type __vacancies = _M_start._M_cur - _M_start._M_first;
      if (__n > __vacancies)
        _M_new_elements_at_front(__n - __vacancies);
      return _M_start - difference_type(__n);
    }

    iterator
    _M_reserve_elements_at_back(size_type __n)
    {
      size_type __vacancies = (_M_finish._M_last - _M_finish._M_cur) - 1;
      if (__n > __vacancies)
        _M_new_elements_at_back(__n - __vacancies);
      return _M_finish + difference_type(__n);
    }

    void
    _M_new_elements_at_front(size_type __new_elements);

    void
    _M_new_elements_at_back(size_type __new_elements);
# 1510 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
    void
    _M_reserve_map_at_back (size_type __nodes_to_add = 1)
    {
      if (__nodes_to_add + 1 > _M_map_size - (_M_finish._M_node - _M_map))
        _M_reallocate_map(__nodes_to_add, false);
    }

    void
    _M_reserve_map_at_front (size_type __nodes_to_add = 1)
    {
      if (__nodes_to_add > size_type(_M_start._M_node - _M_map))
        _M_reallocate_map(__nodes_to_add, true);
    }

    void
    _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);

  };
# 1540 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
  template <typename _Tp, typename _Alloc>
  inline bool operator==(const deque<_Tp, _Alloc>& __x,
                         const deque<_Tp, _Alloc>& __y)
  {
    return __x.size() == __y.size() &&
           equal(__x.begin(), __x.end(), __y.begin());
  }
# 1559 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_deque.h" 3
  template <typename _Tp, typename _Alloc>
  inline bool operator<(const deque<_Tp, _Alloc>& __x,
                        const deque<_Tp, _Alloc>& __y)
  {
    return lexicographical_compare(__x.begin(), __x.end(),
                                   __y.begin(), __y.end());
  }


  template <typename _Tp, typename _Alloc>
  inline bool operator!=(const deque<_Tp, _Alloc>& __x,
                         const deque<_Tp, _Alloc>& __y) {
    return !(__x == __y);
  }


  template <typename _Tp, typename _Alloc>
  inline bool operator>(const deque<_Tp, _Alloc>& __x,
                        const deque<_Tp, _Alloc>& __y) {
    return __y < __x;
  }


  template <typename _Tp, typename _Alloc>
  inline bool operator<=(const deque<_Tp, _Alloc>& __x,
                         const deque<_Tp, _Alloc>& __y) {
    return !(__y < __x);
  }


  template <typename _Tp, typename _Alloc>
  inline bool operator>=(const deque<_Tp, _Alloc>& __x,
                         const deque<_Tp, _Alloc>& __y) {
    return !(__x < __y);
  }


  template <typename _Tp, typename _Alloc>
  inline void swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y)
  {
    __x.swap(__y);
  }
}
# 74 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/queue" 2 3

# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_queue.h" 1 3
# 66 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_queue.h" 3
namespace std
{


  template <typename _Tp, typename _Sequence = deque<_Tp> >
  class queue;

  template <typename _Tp, typename _Seq>
  inline bool operator==(const queue<_Tp,_Seq>&, const queue<_Tp,_Seq>&);

  template <typename _Tp, typename _Seq>
  inline bool operator<(const queue<_Tp,_Seq>&, const queue<_Tp,_Seq>&);
# 104 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_queue.h" 3
  template <typename _Tp, typename _Sequence>
    class queue
  {

    typedef typename _Sequence::value_type _Sequence_value_type;
   
   
   
   

    template <typename _Tp1, typename _Seq1>
    friend bool operator== (const queue<_Tp1, _Seq1>&,
                            const queue<_Tp1, _Seq1>&);
    template <typename _Tp1, typename _Seq1>
    friend bool operator< (const queue<_Tp1, _Seq1>&,
                           const queue<_Tp1, _Seq1>&);

  public:
    typedef typename _Sequence::value_type value_type;
    typedef typename _Sequence::reference reference;
    typedef typename _Sequence::const_reference const_reference;
    typedef typename _Sequence::size_type size_type;
    typedef _Sequence container_type;

  protected:







    _Sequence c;

  public:



    explicit
    queue(const _Sequence& __c = _Sequence())
    : c(__c) {}




    bool
    empty() const { return c.empty(); }


    size_type
    size() const { return c.size(); }





    reference
    front() { return c.front(); }





    const_reference
    front() const { return c.front(); }





    reference
    back() { return c.back(); }





    const_reference
    back() const { return c.back(); }
# 193 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_queue.h" 3
    void
    push(const value_type& __x) { c.push_back(__x); }
# 206 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_queue.h" 3
    void
    pop() { c.pop_front(); }
  };
# 222 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_queue.h" 3
  template <typename _Tp, typename _Sequence>
    inline bool
    operator==(const queue<_Tp,_Sequence>& __x, const queue<_Tp,_Sequence>& __y)
    { return __x.c == __y.c; }
# 239 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_queue.h" 3
  template <typename _Tp, typename _Sequence>
    inline bool
    operator<(const queue<_Tp,_Sequence>& __x, const queue<_Tp,_Sequence>& __y)
    { return __x.c < __y.c; }


  template <typename _Tp, typename _Sequence>
    inline bool
    operator!=(const queue<_Tp,_Sequence>& __x, const queue<_Tp,_Sequence>& __y)
    { return !(__x == __y); }


  template <typename _Tp, typename _Sequence>
    inline bool
    operator>(const queue<_Tp,_Sequence>& __x, const queue<_Tp,_Sequence>& __y)
    { return __y < __x; }


  template <typename _Tp, typename _Sequence>
    inline bool
    operator<=(const queue<_Tp,_Sequence>& __x, const queue<_Tp,_Sequence>& __y)
    { return !(__y < __x); }


  template <typename _Tp, typename _Sequence>
    inline bool
    operator>=(const queue<_Tp,_Sequence>& __x, const queue<_Tp,_Sequence>& __y)
    { return !(__x < __y); }
# 303 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_queue.h" 3
  template <typename _Tp, typename _Sequence = vector<_Tp>,
            typename _Compare = less<typename _Sequence::value_type> >
    class priority_queue
  {

    typedef typename _Sequence::value_type _Sequence_value_type;
   
   
   
   
   

  public:
    typedef typename _Sequence::value_type value_type;
    typedef typename _Sequence::reference reference;
    typedef typename _Sequence::const_reference const_reference;
    typedef typename _Sequence::size_type size_type;
    typedef _Sequence container_type;

  protected:

    _Sequence c;
    _Compare comp;

  public:



    explicit
    priority_queue(const _Compare& __x = _Compare(),
                   const _Sequence& __s = _Sequence())
    : c(__s), comp(__x)
    { make_heap(c.begin(), c.end(), comp); }
# 351 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_queue.h" 3
    template <typename _InputIterator>
      priority_queue(_InputIterator __first, _InputIterator __last,
                     const _Compare& __x = _Compare(),
                     const _Sequence& __s = _Sequence())
      : c(__s), comp(__x)
      {
        c.insert(c.end(), __first, __last);
        make_heap(c.begin(), c.end(), comp);
      }




    bool
    empty() const { return c.empty(); }


    size_type
    size() const { return c.size(); }





    const_reference
    top() const { return c.front(); }
# 386 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_queue.h" 3
    void
    push(const value_type& __x)
    {
      try
        {
          c.push_back(__x);
          push_heap(c.begin(), c.end(), comp);
        }
      catch(...)
        {
          c.clear();
          throw;
        }
    }
# 411 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_queue.h" 3
    void
    pop()
    {
      try
        {
          pop_heap(c.begin(), c.end(), comp);
          c.pop_back();
        }
      catch(...)
        {
          c.clear();
          throw;
        }
    }
  };


}
# 76 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/queue" 2 3


# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/deque.tcc" 1 3
# 64 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/deque.tcc" 3
namespace std
{
  template <typename _Tp, typename _Alloc>
    deque<_Tp,_Alloc>&
    deque<_Tp,_Alloc>::
    operator=(const deque& __x)
    {
      const size_type __len = size();
      if (&__x != this)
      {
        if (__len >= __x.size())
          erase(copy(__x.begin(), __x.end(), _M_start), _M_finish);
        else
        {
          const_iterator __mid = __x.begin() + difference_type(__len);
          copy(__x.begin(), __mid, _M_start);
          insert(_M_finish, __mid, __x.end());
        }
      }
      return *this;
    }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp,_Alloc>::iterator
    deque<_Tp,_Alloc>::
    insert(iterator position, const value_type& __x)
    {
      if (position._M_cur == _M_start._M_cur)
      {
        push_front(__x);
        return _M_start;
      }
      else if (position._M_cur == _M_finish._M_cur)
      {
        push_back(__x);
        iterator __tmp = _M_finish;
        --__tmp;
        return __tmp;
      }
      else
        return _M_insert_aux(position, __x);
    }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp,_Alloc>::iterator
    deque<_Tp,_Alloc>::
    erase(iterator __position)
    {
      iterator __next = __position;
      ++__next;
      size_type __index = __position - _M_start;
      if (__index < (size() >> 1))
      {
        copy_backward(_M_start, __position, __next);
        pop_front();
      }
      else
      {
        copy(__next, _M_finish, __position);
        pop_back();
      }
      return _M_start + __index;
    }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp,_Alloc>::iterator
    deque<_Tp,_Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first == _M_start && __last == _M_finish)
      {
        clear();
        return _M_finish;
      }
      else
      {
        difference_type __n = __last - __first;
        difference_type __elems_before = __first - _M_start;
        if (static_cast<size_type>(__elems_before) < (size() - __n) / 2)
        {
          copy_backward(_M_start, __first, __last);
          iterator __new_start = _M_start + __n;
          _Destroy(_M_start, __new_start);
          _M_destroy_nodes(_M_start._M_node, __new_start._M_node);
          _M_start = __new_start;
        }
        else
        {
          copy(__last, _M_finish, __first);
          iterator __new_finish = _M_finish - __n;
          _Destroy(__new_finish, _M_finish);
          _M_destroy_nodes(__new_finish._M_node + 1, _M_finish._M_node + 1);
          _M_finish = __new_finish;
        }
        return _M_start + __elems_before;
      }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp,_Alloc>::
    clear()
    {
      for (_Map_pointer __node = _M_start._M_node + 1;
           __node < _M_finish._M_node;
           ++__node)
      {
        _Destroy(*__node, *__node + _S_buffer_size());
        _M_deallocate_node(*__node);
      }

      if (_M_start._M_node != _M_finish._M_node)
      {
        _Destroy(_M_start._M_cur, _M_start._M_last);
        _Destroy(_M_finish._M_first, _M_finish._M_cur);
        _M_deallocate_node(_M_finish._M_first);
      }
      else
        _Destroy(_M_start._M_cur, _M_finish._M_cur);

      _M_finish = _M_start;
    }

  template <typename _Tp, class _Alloc>
    template <typename _InputIter>
      void
      deque<_Tp,_Alloc>
      ::_M_assign_aux(_InputIter __first, _InputIter __last, input_iterator_tag)
      {
        iterator __cur = begin();
        for ( ; __first != __last && __cur != end(); ++__cur, ++__first)
          *__cur = *__first;
        if (__first == __last)
          erase(__cur, end());
        else
          insert(end(), __first, __last);
      }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp,_Alloc>::
    _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)
    {
      if (__pos._M_cur == _M_start._M_cur)
      {
        iterator __new_start = _M_reserve_elements_at_front(__n);
        try
          {
            uninitialized_fill(__new_start, _M_start, __x);
            _M_start = __new_start;
          }
        catch(...)
          {
            _M_destroy_nodes(__new_start._M_node, _M_start._M_node);
            throw;
          }
      }
      else if (__pos._M_cur == _M_finish._M_cur)
      {
        iterator __new_finish = _M_reserve_elements_at_back(__n);
        try
          {
            uninitialized_fill(_M_finish, __new_finish, __x);
            _M_finish = __new_finish;
          }
        catch(...)
          {
            _M_destroy_nodes(_M_finish._M_node + 1, __new_finish._M_node + 1);
            throw;
          }
      }
      else
        _M_insert_aux(__pos, __n, __x);
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp,_Alloc>::
    _M_fill_initialize(const value_type& __value)
    {
      _Map_pointer __cur;
      try
        {
          for (__cur = _M_start._M_node; __cur < _M_finish._M_node; ++__cur)
            uninitialized_fill(*__cur, *__cur + _S_buffer_size(), __value);
          uninitialized_fill(_M_finish._M_first, _M_finish._M_cur, __value);
        }
      catch(...)
        {
          _Destroy(_M_start, iterator(*__cur, __cur));
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp,_Alloc>::
      _M_range_initialize(_InputIterator __first, _InputIterator __last,
                          input_iterator_tag)
      {
        _M_initialize_map(0);
        try
          {
            for ( ; __first != __last; ++__first)
              push_back(*__first);
          }
        catch(...)
          {
            clear();
            throw;
          }
      }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp,_Alloc>::
      _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
                          forward_iterator_tag)
      {
        size_type __n = distance(__first, __last);
        _M_initialize_map(__n);

        _Map_pointer __cur_node;
        try
          {
            for (__cur_node = _M_start._M_node;
                 __cur_node < _M_finish._M_node;
                 ++__cur_node)
            {
              _ForwardIterator __mid = __first;
              advance(__mid, _S_buffer_size());
              uninitialized_copy(__first, __mid, *__cur_node);
              __first = __mid;
            }
            uninitialized_copy(__first, __last, _M_finish._M_first);
          }
        catch(...)
          {
            _Destroy(_M_start, iterator(*__cur_node, __cur_node));
            throw;
          }
      }


  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp,_Alloc>::
    _M_push_back_aux(const value_type& __t)
    {
      value_type __t_copy = __t;
      _M_reserve_map_at_back();
      *(_M_finish._M_node + 1) = _M_allocate_node();
      try
        {
          _Construct(_M_finish._M_cur, __t_copy);
          _M_finish._M_set_node(_M_finish._M_node + 1);
          _M_finish._M_cur = _M_finish._M_first;
        }
      catch(...)
        {
          _M_deallocate_node(*(_M_finish._M_node + 1));
          throw;
        }
    }
# 355 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/deque.tcc" 3
  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp,_Alloc>::
    _M_push_front_aux(const value_type& __t)
    {
      value_type __t_copy = __t;
      _M_reserve_map_at_front();
      *(_M_start._M_node - 1) = _M_allocate_node();
      try
        {
          _M_start._M_set_node(_M_start._M_node - 1);
          _M_start._M_cur = _M_start._M_last - 1;
          _Construct(_M_start._M_cur, __t_copy);
        }
      catch(...)
        {
          ++_M_start;
          _M_deallocate_node(*(_M_start._M_node - 1));
          throw;
        }
    }
# 402 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/deque.tcc" 3
  template <typename _Tp, typename _Alloc>
    void deque<_Tp,_Alloc>::
    _M_pop_back_aux()
    {
      _M_deallocate_node(_M_finish._M_first);
      _M_finish._M_set_node(_M_finish._M_node - 1);
      _M_finish._M_cur = _M_finish._M_last - 1;
      _Destroy(_M_finish._M_cur);
    }





  template <typename _Tp, typename _Alloc>
    void deque<_Tp,_Alloc>::
    _M_pop_front_aux()
    {
      _Destroy(_M_start._M_cur);
      _M_deallocate_node(_M_start._M_first);
      _M_start._M_set_node(_M_start._M_node + 1);
      _M_start._M_cur = _M_start._M_first;
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp,_Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _InputIterator __first, _InputIterator __last,
                          input_iterator_tag)
      {
        copy(__first, __last, inserter(*this, __pos));
      }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp,_Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _ForwardIterator __first, _ForwardIterator __last,
                          forward_iterator_tag)
      {
        size_type __n = distance(__first, __last);
        if (__pos._M_cur == _M_start._M_cur)
        {
          iterator __new_start = _M_reserve_elements_at_front(__n);
          try
            {
              uninitialized_copy(__first, __last, __new_start);
              _M_start = __new_start;
            }
          catch(...)
            {
              _M_destroy_nodes(__new_start._M_node, _M_start._M_node);
              throw;
            }
        }
        else if (__pos._M_cur == _M_finish._M_cur)
        {
          iterator __new_finish = _M_reserve_elements_at_back(__n);
          try
            {
              uninitialized_copy(__first, __last, _M_finish);
              _M_finish = __new_finish;
            }
          catch(...)
            {
              _M_destroy_nodes(_M_finish._M_node + 1, __new_finish._M_node + 1);
              throw;
            }
        }
        else
          _M_insert_aux(__pos, __first, __last, __n);
      }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp,_Alloc>::
    _M_insert_aux(iterator __pos, const value_type& __x)
    {
      difference_type __index = __pos - _M_start;
      value_type __x_copy = __x;
      if (static_cast<size_type>(__index) < size() / 2)
      {
        push_front(front());
        iterator __front1 = _M_start;
        ++__front1;
        iterator __front2 = __front1;
        ++__front2;
        __pos = _M_start + __index;
        iterator __pos1 = __pos;
        ++__pos1;
        copy(__front2, __pos1, __front1);
      }
      else
      {
        push_back(back());
        iterator __back1 = _M_finish;
        --__back1;
        iterator __back2 = __back1;
        --__back2;
        __pos = _M_start + __index;
        copy_backward(__pos, __back2, __back1);
      }
      *__pos = __x_copy;
      return __pos;
    }
# 549 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/deque.tcc" 3
  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp,_Alloc>::
    _M_insert_aux(iterator __pos, size_type __n, const value_type& __x)
    {
      const difference_type __elems_before = __pos - _M_start;
      size_type __length = this->size();
      value_type __x_copy = __x;
      if (__elems_before < difference_type(__length / 2))
      {
        iterator __new_start = _M_reserve_elements_at_front(__n);
        iterator __old_start = _M_start;
        __pos = _M_start + __elems_before;
        try
          {
            if (__elems_before >= difference_type(__n))
            {
              iterator __start_n = _M_start + difference_type(__n);
              uninitialized_copy(_M_start, __start_n, __new_start);
              _M_start = __new_start;
              copy(__start_n, __pos, __old_start);
              fill(__pos - difference_type(__n), __pos, __x_copy);
            }
            else
            {
              __uninitialized_copy_fill(_M_start, __pos, __new_start,
                                        _M_start, __x_copy);
              _M_start = __new_start;
              fill(__old_start, __pos, __x_copy);
            }
          }
        catch(...)
          {
            _M_destroy_nodes(__new_start._M_node, _M_start._M_node);
            throw;
          }
      }
      else
      {
        iterator __new_finish = _M_reserve_elements_at_back(__n);
        iterator __old_finish = _M_finish;
        const difference_type __elems_after =
          difference_type(__length) - __elems_before;
        __pos = _M_finish - __elems_after;
        try
          {
            if (__elems_after > difference_type(__n))
            {
              iterator __finish_n = _M_finish - difference_type(__n);
              uninitialized_copy(__finish_n, _M_finish, _M_finish);
              _M_finish = __new_finish;
              copy_backward(__pos, __finish_n, __old_finish);
              fill(__pos, __pos + difference_type(__n), __x_copy);
            }
            else
            {
              __uninitialized_fill_copy(_M_finish, __pos + difference_type(__n),
                                        __x_copy, __pos, _M_finish);
              _M_finish = __new_finish;
              fill(__pos, __old_finish, __x_copy);
            }
          }
        catch(...)
          {
            _M_destroy_nodes(_M_finish._M_node + 1, __new_finish._M_node + 1);
            throw;
          }
      }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp,_Alloc>::
      _M_insert_aux(iterator __pos,
                    _ForwardIterator __first, _ForwardIterator __last,
                    size_type __n)
      {
        const difference_type __elemsbefore = __pos - _M_start;
        size_type __length = size();
        if (static_cast<size_type>(__elemsbefore) < __length / 2)
        {
          iterator __new_start = _M_reserve_elements_at_front(__n);
          iterator __old_start = _M_start;
          __pos = _M_start + __elemsbefore;
          try
            {
              if (__elemsbefore >= difference_type(__n))
              {
                iterator __start_n = _M_start + difference_type(__n);
                uninitialized_copy(_M_start, __start_n, __new_start);
                _M_start = __new_start;
                copy(__start_n, __pos, __old_start);
                copy(__first, __last, __pos - difference_type(__n));
              }
              else
              {
                _ForwardIterator __mid = __first;
                advance(__mid, difference_type(__n) - __elemsbefore);
                __uninitialized_copy_copy(_M_start, __pos, __first, __mid,
                                          __new_start);
                _M_start = __new_start;
                copy(__mid, __last, __old_start);
              }
            }
          catch(...)
            {
              _M_destroy_nodes(__new_start._M_node, _M_start._M_node);
              throw;
            }
        }
        else
        {
          iterator __new_finish = _M_reserve_elements_at_back(__n);
          iterator __old_finish = _M_finish;
          const difference_type __elemsafter =
            difference_type(__length) - __elemsbefore;
          __pos = _M_finish - __elemsafter;
          try
            {
              if (__elemsafter > difference_type(__n))
              {
                iterator __finish_n = _M_finish - difference_type(__n);
                uninitialized_copy(__finish_n, _M_finish, _M_finish);
                _M_finish = __new_finish;
                copy_backward(__pos, __finish_n, __old_finish);
                copy(__first, __last, __pos);
              }
              else
              {
                _ForwardIterator __mid = __first;
                advance(__mid, __elemsafter);
                __uninitialized_copy_copy(__mid, __last, __pos,
                                          _M_finish, _M_finish);
                _M_finish = __new_finish;
                copy(__first, __mid, __pos);
              }
            }
          catch(...)
            {
              _M_destroy_nodes(_M_finish._M_node + 1, __new_finish._M_node + 1);
              throw;
            }
        }
      }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp,_Alloc>::
    _M_new_elements_at_front(size_type __new_elems)
    {
      size_type __new_nodes
          = (__new_elems + _S_buffer_size() - 1) / _S_buffer_size();
      _M_reserve_map_at_front(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(_M_start._M_node - __i) = _M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(_M_start._M_node - __j));
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp,_Alloc>::
    _M_new_elements_at_back(size_type __new_elems)
    {
      size_type __new_nodes
          = (__new_elems + _S_buffer_size() - 1) / _S_buffer_size();
      _M_reserve_map_at_back(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(_M_finish._M_node + __i) = _M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(_M_finish._M_node + __j));
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp,_Alloc>::
    _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)
    {
      size_type __old_num_nodes = _M_finish._M_node - _M_start._M_node + 1;
      size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;

      _Map_pointer __new_nstart;
      if (_M_map_size > 2 * __new_num_nodes)
      {
        __new_nstart = _M_map + (_M_map_size - __new_num_nodes) / 2
                         + (__add_at_front ? __nodes_to_add : 0);
        if (__new_nstart < _M_start._M_node)
          copy(_M_start._M_node, _M_finish._M_node + 1, __new_nstart);
        else
          copy_backward(_M_start._M_node, _M_finish._M_node + 1,
                        __new_nstart + __old_num_nodes);
      }
      else
      {
        size_type __new_map_size =
          _M_map_size + max(_M_map_size, __nodes_to_add) + 2;

        _Map_pointer __new_map = _M_allocate_map(__new_map_size);
        __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
                             + (__add_at_front ? __nodes_to_add : 0);
        copy(_M_start._M_node, _M_finish._M_node + 1, __new_nstart);
        _M_deallocate_map(_M_map, _M_map_size);

        _M_map = __new_map;
        _M_map_size = __new_map_size;
      }

      _M_start._M_set_node(__new_nstart);
      _M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
    }
}
# 79 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/queue" 2 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/vector.tcc" 1 3
# 64 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/vector.tcc" 3
namespace std
{
  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp,_Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
        __throw_length_error("vector::reserve");
      if (this->capacity() < __n)
        {
          const size_type __old_size = size();
          pointer __tmp = _M_allocate_and_copy(__n, _M_start, _M_finish);
          _Destroy(_M_start, _M_finish);
          _M_deallocate(_M_start, _M_end_of_storage - _M_start);
          _M_start = __tmp;
          _M_finish = __tmp + __old_size;
          _M_end_of_storage = _M_start + __n;
        }
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp,_Alloc>::iterator
    vector<_Tp,_Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      size_type __n = __position - begin();
      if (_M_finish != _M_end_of_storage && __position == end())
      {
        _Construct(_M_finish, __x);
        ++_M_finish;
      }
      else
        _M_insert_aux(__position, __x);
      return begin() + __n;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp,_Alloc>::iterator
    vector<_Tp,_Alloc>::
    erase(iterator __position)
    {
      if (__position + 1 != end())
        copy(__position + 1, end(), __position);
      --_M_finish;
      _Destroy(_M_finish);
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp,_Alloc>::iterator
    vector<_Tp,_Alloc>::
    erase(iterator __first, iterator __last)
    {
      iterator __i(copy(__last, end(), __first));
      _Destroy(__i, end());
      _M_finish = _M_finish - (__last - __first);
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp,_Alloc>&
    vector<_Tp,_Alloc>::
    operator=(const vector<_Tp,_Alloc>& __x)
    {
      if (&__x != this)
      {
        const size_type __xlen = __x.size();
        if (__xlen > capacity())
        {
          pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(), __x.end());
          _Destroy(_M_start, _M_finish);
          _M_deallocate(_M_start, _M_end_of_storage - _M_start);
          _M_start = __tmp;
          _M_end_of_storage = _M_start + __xlen;
        }
        else if (size() >= __xlen)
        {
          iterator __i(copy(__x.begin(), __x.end(), begin()));
          _Destroy(__i, end());
        }
        else
        {
          copy(__x.begin(), __x.begin() + size(), _M_start);
          uninitialized_copy(__x.begin() + size(), __x.end(), _M_finish);
        }
        _M_finish = _M_start + __xlen;
      }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp,_Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
      {
        vector __tmp(__n, __val, get_allocator());
        __tmp.swap(*this);
      }
      else if (__n > size())
      {
        fill(begin(), end(), __val);
        _M_finish = uninitialized_fill_n(_M_finish, __n - size(), __val);
      }
      else
        erase(fill_n(begin(), __n, __val), end());
    }

  template<typename _Tp, typename _Alloc> template<typename _InputIter>
    void
    vector<_Tp,_Alloc>::
    _M_assign_aux(_InputIter __first, _InputIter __last, input_iterator_tag)
    {
      iterator __cur(begin());
      for ( ; __first != __last && __cur != end(); ++__cur, ++__first)
        *__cur = *__first;
      if (__first == __last)
        erase(__cur, end());
      else
        insert(end(), __first, __last);
    }

  template<typename _Tp, typename _Alloc> template<typename _ForwardIter>
    void
    vector<_Tp,_Alloc>::
    _M_assign_aux(_ForwardIter __first, _ForwardIter __last,
                  forward_iterator_tag)
    {
      size_type __len = distance(__first, __last);

      if (__len > capacity())
      {
        pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
        _Destroy(_M_start, _M_finish);
        _M_deallocate(_M_start, _M_end_of_storage - _M_start);
        _M_start = __tmp;
        _M_end_of_storage = _M_finish = _M_start + __len;
      }
      else if (size() >= __len)
      {
        iterator __new_finish(copy(__first, __last, _M_start));
        _Destroy(__new_finish, end());
        _M_finish = __new_finish.base();
      }
      else
      {
        _ForwardIter __mid = __first;
        advance(__mid, size());
        copy(__first, __mid, _M_start);
        _M_finish = uninitialized_copy(__mid, __last, _M_finish);
      }
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp,_Alloc>::
    _M_insert_aux(iterator __position, const _Tp& __x)
    {
      if (_M_finish != _M_end_of_storage)
      {
        _Construct(_M_finish, *(_M_finish - 1));
        ++_M_finish;
        _Tp __x_copy = __x;
        copy_backward(__position, iterator(_M_finish-2), iterator(_M_finish-1));
        *__position = __x_copy;
      }
      else
      {
        const size_type __old_size = size();
        const size_type __len = __old_size != 0 ? 2 * __old_size : 1;
        iterator __new_start(_M_allocate(__len));
        iterator __new_finish(__new_start);
        try
          {
            __new_finish = uninitialized_copy(iterator(_M_start), __position,
                                              __new_start);
            _Construct(__new_finish.base(), __x);
            ++__new_finish;
            __new_finish = uninitialized_copy(__position, iterator(_M_finish),
                                              __new_finish);
          }
        catch(...)
          {
            _Destroy(__new_start,__new_finish);
            _M_deallocate(__new_start.base(),__len);
            throw;
          }
        _Destroy(begin(), end());
        _M_deallocate(_M_start, _M_end_of_storage - _M_start);
        _M_start = __new_start.base();
        _M_finish = __new_finish.base();
        _M_end_of_storage = __new_start.base() + __len;
      }
    }
# 305 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/vector.tcc" 3
  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp,_Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
      {
        if (size_type(_M_end_of_storage - _M_finish) >= __n)
          {
           value_type __x_copy = __x;
           const size_type __elems_after = end() - __position;
           iterator __old_finish(_M_finish);
           if (__elems_after > __n)
             {
               uninitialized_copy(_M_finish - __n, _M_finish, _M_finish);
               _M_finish += __n;
               copy_backward(__position, __old_finish - __n, __old_finish);
               fill(__position, __position + __n, __x_copy);
             }
           else
             {
               uninitialized_fill_n(_M_finish, __n - __elems_after, __x_copy);
               _M_finish += __n - __elems_after;
               uninitialized_copy(__position, __old_finish, _M_finish);
               _M_finish += __elems_after;
               fill(__position, __old_finish, __x_copy);
             }
          }
        else
          {
            const size_type __old_size = size();
            const size_type __len = __old_size + max(__old_size, __n);
            iterator __new_start(_M_allocate(__len));
            iterator __new_finish(__new_start);
            try
              {
                __new_finish = uninitialized_copy(begin(), __position,
                                                  __new_start);
                __new_finish = uninitialized_fill_n(__new_finish, __n, __x);
                __new_finish = uninitialized_copy(__position, end(),
                                                  __new_finish);
              }
            catch(...)
              {
                _Destroy(__new_start,__new_finish);
                _M_deallocate(__new_start.base(),__len);
                throw;
              }
            _Destroy(_M_start, _M_finish);
            _M_deallocate(_M_start, _M_end_of_storage - _M_start);
            _M_start = __new_start.base();
            _M_finish = __new_finish.base();
            _M_end_of_storage = __new_start.base() + __len;
          }
      }
    }

  template<typename _Tp, typename _Alloc> template<typename _InputIterator>
    void
    vector<_Tp,_Alloc>::
    _M_range_insert(iterator __pos,
                    _InputIterator __first, _InputIterator __last,
                    input_iterator_tag)
    {
      for ( ; __first != __last; ++__first)
      {
        __pos = insert(__pos, *__first);
        ++__pos;
      }
    }

  template<typename _Tp, typename _Alloc> template<typename _ForwardIterator>
    void
    vector<_Tp,_Alloc>::
    _M_range_insert(iterator __position,_ForwardIterator __first,
                    _ForwardIterator __last, forward_iterator_tag)
    {
      if (__first != __last)
      {
        size_type __n = distance(__first, __last);
        if (size_type(_M_end_of_storage - _M_finish) >= __n)
        {
          const size_type __elems_after = end() - __position;
          iterator __old_finish(_M_finish);
          if (__elems_after > __n)
          {
            uninitialized_copy(_M_finish - __n, _M_finish, _M_finish);
            _M_finish += __n;
            copy_backward(__position, __old_finish - __n, __old_finish);
            copy(__first, __last, __position);
          }
          else
          {
            _ForwardIterator __mid = __first;
            advance(__mid, __elems_after);
            uninitialized_copy(__mid, __last, _M_finish);
            _M_finish += __n - __elems_after;
            uninitialized_copy(__position, __old_finish, _M_finish);
            _M_finish += __elems_after;
            copy(__first, __mid, __position);
          }
        }
        else
        {
          const size_type __old_size = size();
          const size_type __len = __old_size + max(__old_size, __n);
          iterator __new_start(_M_allocate(__len));
          iterator __new_finish(__new_start);
          try
            {
              __new_finish = uninitialized_copy(iterator(_M_start),
                                                __position, __new_start);
              __new_finish = uninitialized_copy(__first, __last, __new_finish);
              __new_finish = uninitialized_copy(__position, iterator(_M_finish),
                                                __new_finish);
            }
          catch(...)
            {
              _Destroy(__new_start,__new_finish);
              _M_deallocate(__new_start.base(), __len);
              throw;
            }
          _Destroy(_M_start, _M_finish);
          _M_deallocate(_M_start, _M_end_of_storage - _M_start);
          _M_start = __new_start.base();
          _M_finish = __new_finish.base();
          _M_end_of_storage = __new_start.base() + __len;
        }
      }
    }
}
# 80 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/queue" 2 3
# 31 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/common/definitions.h" 2
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/set" 1 3
# 65 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/set" 3


# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_set.h" 1 3
# 66 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_set.h" 3
namespace std
{



template <class _Key, class _Compare = less<_Key>,
          class _Alloc = allocator<_Key> >
class set;

template <class _Key, class _Compare, class _Alloc>
inline bool operator==(const set<_Key,_Compare,_Alloc>& __x,
                       const set<_Key,_Compare,_Alloc>& __y);

template <class _Key, class _Compare, class _Alloc>
inline bool operator<(const set<_Key,_Compare,_Alloc>& __x,
                      const set<_Key,_Compare,_Alloc>& __y);


template <class _Key, class _Compare, class _Alloc>
class set
{

 
  ;

public:

  typedef _Key key_type;
  typedef _Key value_type;
  typedef _Compare key_compare;
  typedef _Compare value_compare;
private:
  typedef _Rb_tree<key_type, value_type,
                  _Identity<value_type>, key_compare, _Alloc> _Rep_type;
  _Rep_type _M_t;
public:
  typedef typename _Rep_type::const_pointer pointer;
  typedef typename _Rep_type::const_pointer const_pointer;
  typedef typename _Rep_type::const_reference reference;
  typedef typename _Rep_type::const_reference const_reference;
  typedef typename _Rep_type::const_iterator iterator;
  typedef typename _Rep_type::const_iterator const_iterator;
  typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
  typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
  typedef typename _Rep_type::size_type size_type;
  typedef typename _Rep_type::difference_type difference_type;
  typedef typename _Rep_type::allocator_type allocator_type;



  set() : _M_t(_Compare(), allocator_type()) {}
  explicit set(const _Compare& __comp,
               const allocator_type& __a = allocator_type())
    : _M_t(__comp, __a) {}

  template <class _InputIterator>
  set(_InputIterator __first, _InputIterator __last)
    : _M_t(_Compare(), allocator_type())
    { _M_t.insert_unique(__first, __last); }

  template <class _InputIterator>
  set(_InputIterator __first, _InputIterator __last, const _Compare& __comp,
      const allocator_type& __a = allocator_type())
    : _M_t(__comp, __a) { _M_t.insert_unique(__first, __last); }

  set(const set<_Key,_Compare,_Alloc>& __x) : _M_t(__x._M_t) {}
  set<_Key,_Compare,_Alloc>& operator=(const set<_Key, _Compare, _Alloc>& __x)
  {
    _M_t = __x._M_t;
    return *this;
  }



  key_compare key_comp() const { return _M_t.key_comp(); }
  value_compare value_comp() const { return _M_t.key_comp(); }
  allocator_type get_allocator() const { return _M_t.get_allocator(); }

  iterator begin() const { return _M_t.begin(); }
  iterator end() const { return _M_t.end(); }
  reverse_iterator rbegin() const { return _M_t.rbegin(); }
  reverse_iterator rend() const { return _M_t.rend(); }
  bool empty() const { return _M_t.empty(); }
  size_type size() const { return _M_t.size(); }
  size_type max_size() const { return _M_t.max_size(); }
  void swap(set<_Key,_Compare,_Alloc>& __x) { _M_t.swap(__x._M_t); }


  pair<iterator,bool> insert(const value_type& __x) {
    pair<typename _Rep_type::iterator, bool> __p = _M_t.insert_unique(__x);
    return pair<iterator, bool>(__p.first, __p.second);
  }
  iterator insert(iterator __position, const value_type& __x) {
    typedef typename _Rep_type::iterator _Rep_iterator;
    return _M_t.insert_unique((_Rep_iterator&)__position, __x);
  }
  template <class _InputIterator>
  void insert(_InputIterator __first, _InputIterator __last) {
    _M_t.insert_unique(__first, __last);
  }
  void erase(iterator __position) {
    typedef typename _Rep_type::iterator _Rep_iterator;
    _M_t.erase((_Rep_iterator&)__position);
  }
  size_type erase(const key_type& __x) {
    return _M_t.erase(__x);
  }
  void erase(iterator __first, iterator __last) {
    typedef typename _Rep_type::iterator _Rep_iterator;
    _M_t.erase((_Rep_iterator&)__first, (_Rep_iterator&)__last);
  }
  void clear() { _M_t.clear(); }



  size_type count(const key_type& __x) const {
    return _M_t.find(__x) == _M_t.end() ? 0 : 1;
  }



  iterator find(const key_type& __x) { return _M_t.find(__x); }
  const_iterator find(const key_type& __x) const { return _M_t.find(__x); }
  iterator lower_bound(const key_type& __x) {
    return _M_t.lower_bound(__x);
  }
  const_iterator lower_bound(const key_type& __x) const {
    return _M_t.lower_bound(__x);
  }
  iterator upper_bound(const key_type& __x) {
    return _M_t.upper_bound(__x);
  }
  const_iterator upper_bound(const key_type& __x) const {
    return _M_t.upper_bound(__x);
  }
  pair<iterator,iterator> equal_range(const key_type& __x) {
    return _M_t.equal_range(__x);
  }
  pair<const_iterator,const_iterator> equal_range(const key_type& __x) const {
    return _M_t.equal_range(__x);
  }
# 220 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_set.h" 3
  template <class _K1, class _C1, class _A1>
  friend bool operator== (const set<_K1,_C1,_A1>&, const set<_K1,_C1,_A1>&);
  template <class _K1, class _C1, class _A1>
  friend bool operator< (const set<_K1,_C1,_A1>&, const set<_K1,_C1,_A1>&);
};

template <class _Key, class _Compare, class _Alloc>
inline bool operator==(const set<_Key,_Compare,_Alloc>& __x,
                       const set<_Key,_Compare,_Alloc>& __y) {
  return __x._M_t == __y._M_t;
}

template <class _Key, class _Compare, class _Alloc>
inline bool operator<(const set<_Key,_Compare,_Alloc>& __x,
                      const set<_Key,_Compare,_Alloc>& __y) {
  return __x._M_t < __y._M_t;
}

template <class _Key, class _Compare, class _Alloc>
inline bool operator!=(const set<_Key,_Compare,_Alloc>& __x,
                       const set<_Key,_Compare,_Alloc>& __y) {
  return !(__x == __y);
}

template <class _Key, class _Compare, class _Alloc>
inline bool operator>(const set<_Key,_Compare,_Alloc>& __x,
                      const set<_Key,_Compare,_Alloc>& __y) {
  return __y < __x;
}

template <class _Key, class _Compare, class _Alloc>
inline bool operator<=(const set<_Key,_Compare,_Alloc>& __x,
                       const set<_Key,_Compare,_Alloc>& __y) {
  return !(__y < __x);
}

template <class _Key, class _Compare, class _Alloc>
inline bool operator>=(const set<_Key,_Compare,_Alloc>& __x,
                       const set<_Key,_Compare,_Alloc>& __y) {
  return !(__x < __y);
}

template <class _Key, class _Compare, class _Alloc>
inline void swap(set<_Key,_Compare,_Alloc>& __x,
                 set<_Key,_Compare,_Alloc>& __y) {
  __x.swap(__y);
}

}
# 68 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/set" 2 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_multiset.h" 1 3
# 66 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_multiset.h" 3
namespace std
{



template <class _Key, class _Compare = less<_Key>,
          class _Alloc = allocator<_Key> >
class multiset;

template <class _Key, class _Compare, class _Alloc>
inline bool operator==(const multiset<_Key,_Compare,_Alloc>& __x,
                       const multiset<_Key,_Compare,_Alloc>& __y);

template <class _Key, class _Compare, class _Alloc>
inline bool operator<(const multiset<_Key,_Compare,_Alloc>& __x,
                      const multiset<_Key,_Compare,_Alloc>& __y);

template <class _Key, class _Compare, class _Alloc>
class multiset
{

 
  ;

public:



  typedef _Key key_type;
  typedef _Key value_type;
  typedef _Compare key_compare;
  typedef _Compare value_compare;
private:
  typedef _Rb_tree<key_type, value_type,
                  _Identity<value_type>, key_compare, _Alloc> _Rep_type;
  _Rep_type _M_t;
public:
  typedef typename _Rep_type::const_pointer pointer;
  typedef typename _Rep_type::const_pointer const_pointer;
  typedef typename _Rep_type::const_reference reference;
  typedef typename _Rep_type::const_reference const_reference;
  typedef typename _Rep_type::const_iterator iterator;
  typedef typename _Rep_type::const_iterator const_iterator;
  typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
  typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
  typedef typename _Rep_type::size_type size_type;
  typedef typename _Rep_type::difference_type difference_type;
  typedef typename _Rep_type::allocator_type allocator_type;



  multiset() : _M_t(_Compare(), allocator_type()) {}
  explicit multiset(const _Compare& __comp,
                    const allocator_type& __a = allocator_type())
    : _M_t(__comp, __a) {}

  template <class _InputIterator>
  multiset(_InputIterator __first, _InputIterator __last)
    : _M_t(_Compare(), allocator_type())
    { _M_t.insert_equal(__first, __last); }

  template <class _InputIterator>
  multiset(_InputIterator __first, _InputIterator __last,
           const _Compare& __comp,
           const allocator_type& __a = allocator_type())
    : _M_t(__comp, __a) { _M_t.insert_equal(__first, __last); }

  multiset(const multiset<_Key,_Compare,_Alloc>& __x) : _M_t(__x._M_t) {}

  multiset<_Key,_Compare,_Alloc>&
  operator=(const multiset<_Key,_Compare,_Alloc>& __x) {
    _M_t = __x._M_t;
    return *this;
  }



  key_compare key_comp() const { return _M_t.key_comp(); }
  value_compare value_comp() const { return _M_t.key_comp(); }
  allocator_type get_allocator() const { return _M_t.get_allocator(); }

  iterator begin() const { return _M_t.begin(); }
  iterator end() const { return _M_t.end(); }
  reverse_iterator rbegin() const { return _M_t.rbegin(); }
  reverse_iterator rend() const { return _M_t.rend(); }
  bool empty() const { return _M_t.empty(); }
  size_type size() const { return _M_t.size(); }
  size_type max_size() const { return _M_t.max_size(); }
  void swap(multiset<_Key,_Compare,_Alloc>& __x) { _M_t.swap(__x._M_t); }


  iterator insert(const value_type& __x) {
    return _M_t.insert_equal(__x);
  }
  iterator insert(iterator __position, const value_type& __x) {
    typedef typename _Rep_type::iterator _Rep_iterator;
    return _M_t.insert_equal((_Rep_iterator&)__position, __x);
  }

  template <class _InputIterator>
  void insert(_InputIterator __first, _InputIterator __last) {
    _M_t.insert_equal(__first, __last);
  }
  void erase(iterator __position) {
    typedef typename _Rep_type::iterator _Rep_iterator;
    _M_t.erase((_Rep_iterator&)__position);
  }
  size_type erase(const key_type& __x) {
    return _M_t.erase(__x);
  }
  void erase(iterator __first, iterator __last) {
    typedef typename _Rep_type::iterator _Rep_iterator;
    _M_t.erase((_Rep_iterator&)__first, (_Rep_iterator&)__last);
  }
  void clear() { _M_t.clear(); }



  size_type count(const key_type& __x) const { return _M_t.count(__x); }



  iterator find(const key_type& __x) { return _M_t.find(__x); }
  const_iterator find(const key_type& __x) const { return _M_t.find(__x); }
  iterator lower_bound(const key_type& __x) {
    return _M_t.lower_bound(__x);
  }
  const_iterator lower_bound(const key_type& __x) const {
    return _M_t.lower_bound(__x);
  }
  iterator upper_bound(const key_type& __x) {
    return _M_t.upper_bound(__x);
  }
  const_iterator upper_bound(const key_type& __x) const {
    return _M_t.upper_bound(__x);
  }
  pair<iterator,iterator> equal_range(const key_type& __x) {
    return _M_t.equal_range(__x);
  }
  pair<const_iterator,const_iterator> equal_range(const key_type& __x) const {
    return _M_t.equal_range(__x);
  }
# 221 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_multiset.h" 3
  template <class _K1, class _C1, class _A1>
  friend bool operator== (const multiset<_K1,_C1,_A1>&,
                          const multiset<_K1,_C1,_A1>&);
  template <class _K1, class _C1, class _A1>
  friend bool operator< (const multiset<_K1,_C1,_A1>&,
                         const multiset<_K1,_C1,_A1>&);
};

template <class _Key, class _Compare, class _Alloc>
inline bool operator==(const multiset<_Key,_Compare,_Alloc>& __x,
                       const multiset<_Key,_Compare,_Alloc>& __y) {
  return __x._M_t == __y._M_t;
}

template <class _Key, class _Compare, class _Alloc>
inline bool operator<(const multiset<_Key,_Compare,_Alloc>& __x,
                      const multiset<_Key,_Compare,_Alloc>& __y) {
  return __x._M_t < __y._M_t;
}

template <class _Key, class _Compare, class _Alloc>
inline bool operator!=(const multiset<_Key,_Compare,_Alloc>& __x,
                       const multiset<_Key,_Compare,_Alloc>& __y) {
  return !(__x == __y);
}

template <class _Key, class _Compare, class _Alloc>
inline bool operator>(const multiset<_Key,_Compare,_Alloc>& __x,
                      const multiset<_Key,_Compare,_Alloc>& __y) {
  return __y < __x;
}

template <class _Key, class _Compare, class _Alloc>
inline bool operator<=(const multiset<_Key,_Compare,_Alloc>& __x,
                       const multiset<_Key,_Compare,_Alloc>& __y) {
  return !(__y < __x);
}

template <class _Key, class _Compare, class _Alloc>
inline bool operator>=(const multiset<_Key,_Compare,_Alloc>& __x,
                       const multiset<_Key,_Compare,_Alloc>& __y) {
  return !(__x < __y);
}

template <class _Key, class _Compare, class _Alloc>
inline void swap(multiset<_Key,_Compare,_Alloc>& __x,
                 multiset<_Key,_Compare,_Alloc>& __y) {
  __x.swap(__y);
}

}
# 69 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/set" 2 3
# 32 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/common/definitions.h" 2
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/vector" 1 3
# 65 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/vector" 3

# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/functexcept.h" 1 3
# 34 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/functexcept.h" 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/exception_defines.h" 1 3
# 35 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/functexcept.h" 2 3

namespace std
{

  void
  __throw_bad_exception(void);


  void
  __throw_bad_alloc(void);


  void
  __throw_bad_cast(void);

  void
  __throw_bad_typeid(void);


  void
  __throw_logic_error(const char* __s);

  void
  __throw_domain_error(const char* __s);

  void
  __throw_invalid_argument(const char* __s);

  void
  __throw_length_error(const char* __s);

  void
  __throw_out_of_range(const char* __s);

  void
  __throw_runtime_error(const char* __s);

  void
  __throw_range_error(const char* __s);

  void
  __throw_overflow_error(const char* __s);

  void
  __throw_underflow_error(const char* __s);


  void
  __throw_ios_failure(const char* __s);
}
# 67 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/vector" 2 3





# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_bvector.h" 1 3
# 64 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stl_bvector.h" 3
namespace std
{
  typedef unsigned long _Bit_type;
  enum { _M_word_bit = int(8 * sizeof(_Bit_type)) };

struct _Bit_reference {

  _Bit_type * _M_p;
  _Bit_type _M_mask;
  _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) {}

public:
  _Bit_reference() : _M_p(0), _M_mask(0) {}
  operator bool() const { return !!(*_M_p & _M_mask); }
  _Bit_reference& operator=(bool __x)
  {
    if (__x) *_M_p |= _M_mask;
    else *_M_p &= ~_M_mask;
    return *this;
  }
  _Bit_reference& operator=(const _Bit_reference& __x)
    { return *this = bool(__x); }
  bool operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }
  bool operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }
  void flip() { *_M_p ^= _M_mask; }
};

struct _Bit_iterator_base : public iterator<random_access_iterator_tag, bool>
{
  _Bit_type * _M_p;
  unsigned int _M_offset;

  _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) {}

  void _M_bump_up() {
    if (_M_offset++ == _M_word_bit - 1) {
      _M_offset = 0;
      ++_M_p;
    }
  }
  void _M_bump_down() {
    if (_M_offset-- == 0) {
      _M_offset = _M_word_bit - 1;
      --_M_p;
    }
  }

  void _M_incr(ptrdiff_t __i) {
    difference_type __n = __i + _M_offset;
    _M_p += __n / _M_word_bit;
    __n = __n % _M_word_bit;
    if (__n < 0) {
      _M_offset = (unsigned int) __n + _M_word_bit;
      --_M_p;
    } else
      _M_offset = (unsigned int) __n;
  }

  bool operator==(const _Bit_iterator_base& __i) const {
    return _M_p == __i._M_p && _M_offset == __i._M_offset;
  }
  bool operator<(const _Bit_iterator_base& __i) const {
    return _M_p < __i._M_p || (_M_p == __i._M_p && _M_offset < __i._M_offset);
  }
  bool operator!=(const _Bit_iterator_base& __i) const {
    return !(*this == __i);
  }
  bool operator>(const _Bit_iterator_base& __i) const {
    return __i < *this;
  }
  bool operator<=(const _Bit_iterator_base& __i) const {
    return !(__i < *this);
  }
  bool operator>=(const _Bit_iterator_base& __i) const {
    return !(*this < __i);
  }
};

inline ptrdiff_t
operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y) {
  return _M_word_bit * (__x._M_p - __y._M_p) + __x._M_offset - __y._M_offset;
}


struct _Bit_iterator : public _Bit_iterator_base
{
  typedef _Bit_reference reference;
  typedef _Bit_reference* pointer;
  typedef _Bit_iterator iterator;

  _Bit_iterator() : _Bit_iterator_base(0, 0) {}
  _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) {}

  reference operator*() const { return reference(_M_p, 1UL << _M_offset); }
  iterator& operator++() {
    _M_bump_up();
    return *this;
  }
  iterator operator++(int) {
    iterator __tmp = *this;
    _M_bump_up();
    return __tmp;
  }
  iterator& operator--() {
    _M_bump_down();
    return *this;
  }
  iterator operator--(int) {
    iterator __tmp = *this;
    _M_bump_down();
    return __tmp;
  }
  iterator& operator+=(difference_type __i) {
    _M_incr(__i);
    return *this;
  }
  iterator& operator-=(difference_type __i) {
    *this += -__i;
    return *this;
  }
  iterator operator+(difference_type __i) const {
    iterator __tmp = *this;
    return __tmp += __i;
  }
  iterator operator-(difference_type __i) const {
    iterator __tmp = *this;
    return __tmp -= __i;
  }

  reference operator[](difference_type __i) { return *(*this + __i); }
};

inline _Bit_iterator
operator+(ptrdiff_t __n, const _Bit_iterator& __x) { return __x + __n; }


struct _Bit_const_iterator : public _Bit_iterator_base
{
  typedef bool reference;
  typedef bool const_reference;
  typedef const bool* pointer;
  typedef _Bit_const_iterator const_iterator;

  _Bit_const_iterator() : _Bit_iterator_base(0, 0) {}
  _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) {}
  _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) {}

  const_reference operator*() const {
    return _Bit_reference(_M_p, 1UL << _M_offset);
  }
  const_iterator& operator++() {
    _M_bump_up();
    return *this;
  }
  const_iterator operator++(int) {
    const_iterator __tmp = *this;
    _M_bump_up();
    return __tmp;
  }
  const_iterator& operator--() {
    _M_bump_down();
    return *this;
  }
  const_iterator operator--(int) {
    const_iterator __tmp = *this;
    _M_bump_down();
    return __tmp;
  }
  const_iterator& operator+=(difference_type __i) {
    _M_incr(__i);
    return *this;
  }
  const_iterator& operator-=(difference_type __i) {
    *this += -__i;
    return *this;
  }
  const_iterator operator+(difference_type __i) const {
    const_iterator __tmp = *this;
    return __tmp += __i;
  }
  const_iterator operator-(difference_type __i) const {
    const_iterator __tmp = *this;
    return __tmp -= __i;
  }
  const_reference operator[](difference_type __i) {
    return *(*this + __i);
  }
};

inline _Bit_const_iterator
operator+(ptrdiff_t __n, const _Bit_const_iterator& __x) { return __x + __n; }






template <class _Allocator, bool __is_static>
class _Bvector_alloc_base {
public:
  typedef typename _Alloc_traits<bool, _Allocator>::allocator_type
          allocator_type;
  allocator_type get_allocator() const { return _M_data_allocator; }

  _Bvector_alloc_base(const allocator_type& __a)
    : _M_data_allocator(__a), _M_start(), _M_finish(), _M_end_of_storage(0) {}

protected:
  _Bit_type * _M_bit_alloc(size_t __n)
    { return _M_data_allocator.allocate((__n + _M_word_bit - 1)/_M_word_bit); }
  void _M_deallocate() {
    if (_M_start._M_p)
      _M_data_allocator.deallocate(_M_start._M_p,
                                   _M_end_of_storage - _M_start._M_p);
  }

  typename _Alloc_traits<_Bit_type, _Allocator>::allocator_type
          _M_data_allocator;
  _Bit_iterator _M_start;
  _Bit_iterator _M_finish;
  _Bit_type * _M_end_of_storage;
};


template <class _Allocator>
class _Bvector_alloc_base<_Allocator, true> {
public:
  typedef typename _Alloc_traits<bool, _Allocator>::allocator_type
          allocator_type;
  allocator_type get_allocator() const { return allocator_type(); }

  _Bvector_alloc_base(const allocator_type&)
    : _M_start(), _M_finish(), _M_end_of_storage(0) {}

protected:
  typedef typename _Alloc_traits<_Bit_type, _Allocator>::_Alloc_type
          _Alloc_type;

  _Bit_type * _M_bit_alloc(size_t __n)
    { return _Alloc_type::allocate((__n + _M_word_bit - 1)/_M_word_bit); }
  void _M_deallocate() {
    if (_M_start._M_p)
      _Alloc_type::deallocate(_M_start._M_p,
                              _M_end_of_storage - _M_start._M_p);
  }

  _Bit_iterator _M_start;
  _Bit_iterator _M_finish;
  _Bit_type * _M_end_of_storage;
};

template <class _Alloc>
class _Bvector_base
  : public _Bvector_alloc_base<_Alloc,
                               _Alloc_traits<bool, _Alloc>::_S_instanceless>
{
  typedef _Bvector_alloc_base<_Alloc,
                              _Alloc_traits<bool, _Alloc>::_S_instanceless>
          _Base;
public:
  typedef typename _Base::allocator_type allocator_type;

  _Bvector_base(const allocator_type& __a) : _Base(__a) {}
  ~_Bvector_base() { _Base::_M_deallocate(); }
};

}



namespace std
{

template <typename _Alloc>
  class vector<bool, _Alloc> : public _Bvector_base<_Alloc>
  {
  public:
    typedef bool value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Bit_reference reference;
    typedef bool const_reference;
    typedef _Bit_reference* pointer;
    typedef const bool* const_pointer;

    typedef _Bit_iterator iterator;
    typedef _Bit_const_iterator const_iterator;

    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;

    typedef typename _Bvector_base<_Alloc>::allocator_type allocator_type;
    allocator_type get_allocator() const {
      return _Bvector_base<_Alloc>::get_allocator();
    }

  protected:
    using _Bvector_base<_Alloc>::_M_bit_alloc;
    using _Bvector_base<_Alloc>::_M_deallocate;
    using _Bvector_base<_Alloc>::_M_start;
    using _Bvector_base<_Alloc>::_M_finish;
    using _Bvector_base<_Alloc>::_M_end_of_storage;

  protected:
    void _M_initialize(size_type __n) {
      _Bit_type * __q = _M_bit_alloc(__n);
      _M_end_of_storage = __q + (__n + _M_word_bit - 1)/_M_word_bit;
      _M_start = iterator(__q, 0);
      _M_finish = _M_start + difference_type(__n);
    }
    void _M_insert_aux(iterator __position, bool __x) {
      if (_M_finish._M_p != _M_end_of_storage) {
        copy_backward(__position, _M_finish, _M_finish + 1);
        *__position = __x;
        ++_M_finish;
      }
      else {
        size_type __len = size()
                          ? 2 * size() : static_cast<size_type>(_M_word_bit);
        _Bit_type * __q = _M_bit_alloc(__len);
        iterator __i = copy(begin(), __position, iterator(__q, 0));
        *__i++ = __x;
        _M_finish = copy(__position, end(), __i);
        _M_deallocate();
        _M_end_of_storage = __q + (__len + _M_word_bit - 1)/_M_word_bit;
        _M_start = iterator(__q, 0);
      }
    }

    template <class _InputIterator>
    void _M_initialize_range(_InputIterator __first, _InputIterator __last,
                             input_iterator_tag) {
      _M_start = iterator();
      _M_finish = iterator();
      _M_end_of_storage = 0;
      for ( ; __first != __last; ++__first)
        push_back(*__first);
    }

    template <class _ForwardIterator>
    void _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
                             forward_iterator_tag) {
      size_type __n = distance(__first, __last);
      _M_initialize(__n);
      copy(__first, __last, _M_start);
    }

    template <class _InputIterator>
    void _M_insert_range(iterator __pos,
                         _InputIterator __first, _InputIterator __last,
                         input_iterator_tag) {
      for ( ; __first != __last; ++__first) {
        __pos = insert(__pos, *__first);
        ++__pos;
      }
    }

    template <class _ForwardIterator>
    void _M_insert_range(iterator __position,
                         _ForwardIterator __first, _ForwardIterator __last,
                         forward_iterator_tag) {
      if (__first != __last) {
        size_type __n = distance(__first, __last);
        if (capacity() - size() >= __n) {
          copy_backward(__position, end(), _M_finish + difference_type(__n));
          copy(__first, __last, __position);
          _M_finish += difference_type(__n);
        }
        else {
          size_type __len = size() + max(size(), __n);
          _Bit_type * __q = _M_bit_alloc(__len);
          iterator __i = copy(begin(), __position, iterator(__q, 0));
          __i = copy(__first, __last, __i);
          _M_finish = copy(__position, end(), __i);
          _M_deallocate();
          _M_end_of_storage = __q + (__len + _M_word_bit - 1)/_M_word_bit;
          _M_start = iterator(__q, 0);
        }
      }
    }

  public:
    iterator begin() { return _M_start; }
    const_iterator begin() const { return _M_start; }
    iterator end() { return _M_finish; }
    const_iterator end() const { return _M_finish; }

    reverse_iterator rbegin() { return reverse_iterator(end()); }
    const_reverse_iterator rbegin() const {
      return const_reverse_iterator(end());
    }
    reverse_iterator rend() { return reverse_iterator(begin()); }
    const_reverse_iterator rend() const {
      return const_reverse_iterator(begin());
    }

    size_type size() const { return size_type(end() - begin()); }
    size_type max_size() const { return size_type(-1); }
    size_type capacity() const {
      return size_type(const_iterator(_M_end_of_storage, 0) - begin());
    }
    bool empty() const { return begin() == end(); }

    reference operator[](size_type __n)
      { return *(begin() + difference_type(__n)); }
    const_reference operator[](size_type __n) const
      { return *(begin() + difference_type(__n)); }

    void _M_range_check(size_type __n) const {
      if (__n >= this->size())
        __throw_out_of_range("vector<bool>");
    }

    reference at(size_type __n)
      { _M_range_check(__n); return (*this)[__n]; }
    const_reference at(size_type __n) const
      { _M_range_check(__n); return (*this)[__n]; }

    explicit vector(const allocator_type& __a = allocator_type())
      : _Bvector_base<_Alloc>(__a) {}

    vector(size_type __n, bool __value,
              const allocator_type& __a = allocator_type())
      : _Bvector_base<_Alloc>(__a)
    {
      _M_initialize(__n);
      fill(_M_start._M_p, _M_end_of_storage, __value ? ~0 : 0);
    }

    explicit vector(size_type __n)
      : _Bvector_base<_Alloc>(allocator_type())
    {
      _M_initialize(__n);
      fill(_M_start._M_p, _M_end_of_storage, 0);
    }

    vector(const vector& __x) : _Bvector_base<_Alloc>(__x.get_allocator()) {
      _M_initialize(__x.size());
      copy(__x.begin(), __x.end(), _M_start);
    }



    template <class _Integer>
    void _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type) {
      _M_initialize(__n);
      fill(_M_start._M_p, _M_end_of_storage, __x ? ~0 : 0);
    }

    template <class _InputIterator>
    void _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
                                __false_type) {
      _M_initialize_range(__first, __last, __iterator_category(__first));
    }

    template <class _InputIterator>
    vector(_InputIterator __first, _InputIterator __last,
             const allocator_type& __a = allocator_type())
      : _Bvector_base<_Alloc>(__a)
    {
      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
      _M_initialize_dispatch(__first, __last, _Integral());
    }

    ~vector() { }

    vector& operator=(const vector& __x) {
      if (&__x == this) return *this;
      if (__x.size() > capacity()) {
        _M_deallocate();
        _M_initialize(__x.size());
      }
      copy(__x.begin(), __x.end(), begin());
      _M_finish = begin() + difference_type(__x.size());
      return *this;
    }






    void _M_fill_assign(size_t __n, bool __x) {
      if (__n > size()) {
        fill(_M_start._M_p, _M_end_of_storage, __x ? ~0 : 0);
        insert(end(), __n - size(), __x);
      }
      else {
        erase(begin() + __n, end());
        fill(_M_start._M_p, _M_end_of_storage, __x ? ~0 : 0);
      }
    }

    void assign(size_t __n, bool __x) { _M_fill_assign(__n, __x); }

    template <class _InputIterator>
    void assign(_InputIterator __first, _InputIterator __last) {
      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
      _M_assign_dispatch(__first, __last, _Integral());
    }

    template <class _Integer>
    void _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
      { _M_fill_assign((size_t) __n, (bool) __val); }

    template <class _InputIter>
    void _M_assign_dispatch(_InputIter __first, _InputIter __last, __false_type)
      { _M_assign_aux(__first, __last, __iterator_category(__first)); }

    template <class _InputIterator>
    void _M_assign_aux(_InputIterator __first, _InputIterator __last,
                       input_iterator_tag) {
      iterator __cur = begin();
      for ( ; __first != __last && __cur != end(); ++__cur, ++__first)
        *__cur = *__first;
      if (__first == __last)
        erase(__cur, end());
      else
        insert(end(), __first, __last);
    }

    template <class _ForwardIterator>
    void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                       forward_iterator_tag) {
      size_type __len = distance(__first, __last);
      if (__len < size())
        erase(copy(__first, __last, begin()), end());
      else {
        _ForwardIterator __mid = __first;
        advance(__mid, size());
        copy(__first, __mid, begin());
        insert(end(), __mid, __last);
      }
    }

    void reserve(size_type __n) {
      if (__n > this->max_size())
        __throw_length_error("vector::reserve");
      if (this->capacity() < __n) {
        _Bit_type * __q = _M_bit_alloc(__n);
        _M_finish = copy(begin(), end(), iterator(__q, 0));
        _M_deallocate();
        _M_start = iterator(__q, 0);
        _M_end_of_storage = __q + (__n + _M_word_bit - 1)/_M_word_bit;
      }
    }

    reference front() { return *begin(); }
    const_reference front() const { return *begin(); }
    reference back() { return *(end() - 1); }
    const_reference back() const { return *(end() - 1); }
    void push_back(bool __x) {
      if (_M_finish._M_p != _M_end_of_storage)
        *_M_finish++ = __x;
      else
        _M_insert_aux(end(), __x);
    }
    void swap(vector<bool, _Alloc>& __x) {
      std::swap(_M_start, __x._M_start);
      std::swap(_M_finish, __x._M_finish);
      std::swap(_M_end_of_storage, __x._M_end_of_storage);
    }


    static void swap(reference __x, reference __y) {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    iterator insert(iterator __position, bool __x = bool()) {
      difference_type __n = __position - begin();
      if (_M_finish._M_p != _M_end_of_storage && __position == end())
        *_M_finish++ = __x;
      else
        _M_insert_aux(__position, __x);
      return begin() + __n;
    }



    template <class _Integer>
    void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
                            __true_type) {
      _M_fill_insert(__pos, __n, __x);
    }

    template <class _InputIterator>
    void _M_insert_dispatch(iterator __pos,
                            _InputIterator __first, _InputIterator __last,
                            __false_type) {
      _M_insert_range(__pos, __first, __last, __iterator_category(__first));
    }

    template <class _InputIterator>
    void insert(iterator __position,
                _InputIterator __first, _InputIterator __last) {
      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
      _M_insert_dispatch(__position, __first, __last, _Integral());
    }

    void _M_fill_insert(iterator __position, size_type __n, bool __x) {
      if (__n == 0) return;
      if (capacity() - size() >= __n) {
        copy_backward(__position, end(), _M_finish + difference_type(__n));
        fill(__position, __position + difference_type(__n), __x);
        _M_finish += difference_type(__n);
      }
      else {
        size_type __len = size() + max(size(), __n);
        _Bit_type * __q = _M_bit_alloc(__len);
        iterator __i = copy(begin(), __position, iterator(__q, 0));
        fill_n(__i, __n, __x);
        _M_finish = copy(__position, end(), __i + difference_type(__n));
        _M_deallocate();
        _M_end_of_storage = __q + (__len + _M_word_bit - 1)/_M_word_bit;
        _M_start = iterator(__q, 0);
      }
    }

    void insert(iterator __position, size_type __n, bool __x) {
      _M_fill_insert(__position, __n, __x);
    }

    void pop_back() { --_M_finish; }
    iterator erase(iterator __position) {
      if (__position + 1 != end())
        copy(__position + 1, end(), __position);
        --_M_finish;
      return __position;
    }
    iterator erase(iterator __first, iterator __last) {
      _M_finish = copy(__last, end(), __first);
      return __first;
    }
    void resize(size_type __new_size, bool __x = bool()) {
      if (__new_size < size())
        erase(begin() + difference_type(__new_size), end());
      else
        insert(end(), __new_size - size(), __x);
    }
    void flip() {
      for (_Bit_type * __p = _M_start._M_p; __p != _M_end_of_storage; ++__p)
        *__p = ~*__p;
    }

    void clear() { erase(begin(), end()); }
  };


typedef vector<bool, __alloc> bit_vector;

}
# 73 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/vector" 2 3
# 33 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/common/definitions.h" 2
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ext/hash_map" 1 3
# 65 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ext/hash_map" 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ext/stl_hashtable.h" 1 3
# 69 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ext/stl_hashtable.h" 3
# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/iterator" 1 3
# 65 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/iterator" 3







# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stream_iterator.h" 1 3
# 39 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/bits/stream_iterator.h" 3

namespace std
{
  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT>, typename _Dist = ptrdiff_t>
    class istream_iterator
      : public iterator<input_iterator_tag, _Tp, _Dist, const _Tp*, const _Tp&>
    {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_istream<_CharT, _Traits> istream_type;

    private:
      istream_type* _M_stream;
      _Tp _M_value;
      bool _M_ok;

    public:
      istream_iterator() : _M_stream(0), _M_ok(false) {}

      istream_iterator(istream_type& __s) : _M_stream(&__s) { _M_read(); }

      istream_iterator(const istream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_value(__obj._M_value),
        _M_ok(__obj._M_ok)
      { }

      const _Tp&
      operator*() const { return _M_value; }

      const _Tp*
      operator->() const { return &(operator*()); }

      istream_iterator&
      operator++()
      { _M_read(); return *this; }

      istream_iterator
      operator++(int)
      {
        istream_iterator __tmp = *this;
        _M_read();
        return __tmp;
      }

      bool
      _M_equal(const istream_iterator& __x) const
      { return (_M_ok == __x._M_ok) && (!_M_ok || _M_stream == __x._M_stream);}

    private:
      void
      _M_read()
      {
        _M_ok = (_M_stream && *_M_stream) ? true : false;
        if (_M_ok)
          {
            *_M_stream >> _M_value;
            _M_ok = *_M_stream ? true : false;
          }
      }
    };

  template<typename _Tp, typename _CharT, typename _Traits, typename _Dist>
    inline bool
    operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
               const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)
    { return __x._M_equal(__y); }

  template <class _Tp, class _CharT, class _Traits, class _Dist>
    inline bool
    operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
               const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)
    { return !__x._M_equal(__y); }


  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT> >
    class ostream_iterator
      : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;

    private:
      ostream_type* _M_stream;
      const _CharT* _M_string;

    public:
      ostream_iterator(ostream_type& __s) : _M_stream(&__s), _M_string(0) {}

      ostream_iterator(ostream_type& __s, const _CharT* __c)
      : _M_stream(&__s), _M_string(__c) { }

      ostream_iterator(const ostream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_string(__obj._M_string) { }

      ostream_iterator&
      operator=(const _Tp& __value)
      {
        *_M_stream << __value;
        if (_M_string) *_M_stream << _M_string;
        return *this;
      }

      ostream_iterator&
      operator*() { return *this; }

      ostream_iterator&
      operator++() { return *this; }

      ostream_iterator&
      operator++(int) { return *this; }
    };
}
# 73 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/iterator" 2 3
# 70 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ext/stl_hashtable.h" 2 3


# 1 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ext/stl_hash_fun.h" 1 3
# 67 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ext/stl_hash_fun.h" 3
namespace __gnu_cxx
{
using std::size_t;

template <class _Key> struct hash { };

inline size_t __stl_hash_string(const char* __s)
{
  unsigned long __h = 0;
  for ( ; *__s; ++__s)
    __h = 5*__h + *__s;

  return size_t(__h);
}

template<> struct hash<char*>
{
  size_t operator()(const char* __s) const { return __stl_hash_string(__s); }
};

template<> struct hash<const char*>
{
  size_t operator()(const char* __s) const { return __stl_hash_string(__s); }
};

template<> struct hash<char> {
  size_t operator()(char __x) const { return __x; }
};
template<> struct hash<unsigned char> {
  size_t operator()(unsigned char __x) const { return __x; }
};
template<> struct hash<signed char> {
  size_t operator()(unsigned char __x) const { return __x; }
};
template<> struct hash<short> {
  size_t operator()(short __x) const { return __x; }
};
template<> struct hash<unsigned short> {
  size_t operator()(unsigned short __x) const { return __x; }
};
template<> struct hash<int> {
  size_t operator()(int __x) const { return __x; }
};
template<> struct hash<unsigned int> {
  size_t operator()(unsigned int __x) const { return __x; }
};
template<> struct hash<long> {
  size_t operator()(long __x) const { return __x; }
};
template<> struct hash<unsigned long> {
  size_t operator()(unsigned long __x) const { return __x; }
};

}
# 73 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ext/stl_hashtable.h" 2 3

namespace __gnu_cxx
{
using std::size_t;
using std::ptrdiff_t;
using std::forward_iterator_tag;
using std::input_iterator_tag;
using std::_Alloc_traits;
using std::_Construct;
using std::_Destroy;
using std::distance;
using std::vector;
using std::pair;
using std::__iterator_category;

template <class _Val>
struct _Hashtable_node
{
  _Hashtable_node* _M_next;
  _Val _M_val;
};

template <class _Val, class _Key, class _HashFcn,
          class _ExtractKey, class _EqualKey, class _Alloc = std::__alloc>
class hashtable;

template <class _Val, class _Key, class _HashFcn,
          class _ExtractKey, class _EqualKey, class _Alloc>
struct _Hashtable_iterator;

template <class _Val, class _Key, class _HashFcn,
          class _ExtractKey, class _EqualKey, class _Alloc>
struct _Hashtable_const_iterator;

template <class _Val, class _Key, class _HashFcn,
          class _ExtractKey, class _EqualKey, class _Alloc>
struct _Hashtable_iterator {
  typedef hashtable<_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc>
          _Hashtable;
  typedef _Hashtable_iterator<_Val, _Key, _HashFcn,
                              _ExtractKey, _EqualKey, _Alloc>
          iterator;
  typedef _Hashtable_const_iterator<_Val, _Key, _HashFcn,
                                    _ExtractKey, _EqualKey, _Alloc>
          const_iterator;
  typedef _Hashtable_node<_Val> _Node;

  typedef forward_iterator_tag iterator_category;
  typedef _Val value_type;
  typedef ptrdiff_t difference_type;
  typedef size_t size_type;
  typedef _Val& reference;
  typedef _Val* pointer;

  _Node* _M_cur;
  _Hashtable* _M_ht;

  _Hashtable_iterator(_Node* __n, _Hashtable* __tab)
    : _M_cur(__n), _M_ht(__tab) {}
  _Hashtable_iterator() {}
  reference operator*() const { return _M_cur->_M_val; }
  pointer operator->() const { return &(operator*()); }
  iterator& operator++();
  iterator operator++(int);
  bool operator==(const iterator& __it) const
    { return _M_cur == __it._M_cur; }
  bool operator!=(const iterator& __it) const
    { return _M_cur != __it._M_cur; }
};


template <class _Val, class _Key, class _HashFcn,
          class _ExtractKey, class _EqualKey, class _Alloc>
struct _Hashtable_const_iterator {
  typedef hashtable<_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc>
          _Hashtable;
  typedef _Hashtable_iterator<_Val,_Key,_HashFcn,
                              _ExtractKey,_EqualKey,_Alloc>
          iterator;
  typedef _Hashtable_const_iterator<_Val, _Key, _HashFcn,
                                    _ExtractKey, _EqualKey, _Alloc>
          const_iterator;
  typedef _Hashtable_node<_Val> _Node;

  typedef forward_iterator_tag iterator_category;
  typedef _Val value_type;
  typedef ptrdiff_t difference_type;
  typedef size_t size_type;
  typedef const _Val& reference;
  typedef const _Val* pointer;

  const _Node* _M_cur;
  const _Hashtable* _M_ht;

  _Hashtable_const_iterator(const _Node* __n, const _Hashtable* __tab)
    : _M_cur(__n), _M_ht(__tab) {}
  _Hashtable_const_iterator() {}
  _Hashtable_const_iterator(const iterator& __it)
    : _M_cur(__it._M_cur), _M_ht(__it._M_ht) {}
  reference operator*() const { return _M_cur->_M_val; }
  pointer operator->() const { return &(operator*()); }
  const_iterator& operator++();
  const_iterator operator++(int);
  bool operator==(const const_iterator& __it) const
    { return _M_cur == __it._M_cur; }
  bool operator!=(const const_iterator& __it) const
    { return _M_cur != __it._M_cur; }
};


enum { __stl_num_primes = 28 };

static const unsigned long __stl_prime_list[__stl_num_primes] =
{
  53ul, 97ul, 193ul, 389ul, 769ul,
  1543ul, 3079ul, 6151ul, 12289ul, 24593ul,
  49157ul, 98317ul, 196613ul, 393241ul, 786433ul,
  1572869ul, 3145739ul, 6291469ul, 12582917ul, 25165843ul,
  50331653ul, 100663319ul, 201326611ul, 402653189ul, 805306457ul,
  1610612741ul, 3221225473ul, 4294967291ul
};

inline unsigned long __stl_next_prime(unsigned long __n)
{
  const unsigned long* __first = __stl_prime_list;
  const unsigned long* __last = __stl_prime_list + (int)__stl_num_primes;
  const unsigned long* pos = std::lower_bound(__first, __last, __n);
  return pos == __last ? *(__last - 1) : *pos;
}



template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
class hashtable;

template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
bool operator==(const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht1,
                const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht2);
# 221 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ext/stl_hashtable.h" 3
template <class _Val, class _Key, class _HashFcn,
          class _ExtractKey, class _EqualKey, class _Alloc>
class hashtable {
public:
  typedef _Key key_type;
  typedef _Val value_type;
  typedef _HashFcn hasher;
  typedef _EqualKey key_equal;

  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef value_type& reference;
  typedef const value_type& const_reference;

  hasher hash_funct() const { return _M_hash; }
  key_equal key_eq() const { return _M_equals; }

private:
  typedef _Hashtable_node<_Val> _Node;

public:
  typedef typename _Alloc_traits<_Val,_Alloc>::allocator_type allocator_type;
  allocator_type get_allocator() const { return _M_node_allocator; }
private:
  typename _Alloc_traits<_Node, _Alloc>::allocator_type _M_node_allocator;
  _Node* _M_get_node() { return _M_node_allocator.allocate(1); }
  void _M_put_node(_Node* __p) { _M_node_allocator.deallocate(__p, 1); }

private:
  hasher _M_hash;
  key_equal _M_equals;
  _ExtractKey _M_get_key;
  vector<_Node*,_Alloc> _M_buckets;
  size_type _M_num_elements;

public:
  typedef _Hashtable_iterator<_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc>
          iterator;
  typedef _Hashtable_const_iterator<_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,
                                    _Alloc>
          const_iterator;

  friend struct
  _Hashtable_iterator<_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc>;
  friend struct
  _Hashtable_const_iterator<_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc>;

public:
  hashtable(size_type __n,
            const _HashFcn& __hf,
            const _EqualKey& __eql,
            const _ExtractKey& __ext,
            const allocator_type& __a = allocator_type())
    : _M_node_allocator(__a),
      _M_hash(__hf),
      _M_equals(__eql),
      _M_get_key(__ext),
      _M_buckets(__a),
      _M_num_elements(0)
  {
    _M_initialize_buckets(__n);
  }

  hashtable(size_type __n,
            const _HashFcn& __hf,
            const _EqualKey& __eql,
            const allocator_type& __a = allocator_type())
    : _M_node_allocator(__a),
      _M_hash(__hf),
      _M_equals(__eql),
      _M_get_key(_ExtractKey()),
      _M_buckets(__a),
      _M_num_elements(0)
  {
    _M_initialize_buckets(__n);
  }

  hashtable(const hashtable& __ht)
    : _M_node_allocator(__ht.get_allocator()),
      _M_hash(__ht._M_hash),
      _M_equals(__ht._M_equals),
      _M_get_key(__ht._M_get_key),
      _M_buckets(__ht.get_allocator()),
      _M_num_elements(0)
  {
    _M_copy_from(__ht);
  }

  hashtable& operator= (const hashtable& __ht)
  {
    if (&__ht != this) {
      clear();
      _M_hash = __ht._M_hash;
      _M_equals = __ht._M_equals;
      _M_get_key = __ht._M_get_key;
      _M_copy_from(__ht);
    }
    return *this;
  }

  ~hashtable() { clear(); }

  size_type size() const { return _M_num_elements; }
  size_type max_size() const { return size_type(-1); }
  bool empty() const { return size() == 0; }

  void swap(hashtable& __ht)
  {
    std::swap(_M_hash, __ht._M_hash);
    std::swap(_M_equals, __ht._M_equals);
    std::swap(_M_get_key, __ht._M_get_key);
    _M_buckets.swap(__ht._M_buckets);
    std::swap(_M_num_elements, __ht._M_num_elements);
  }

  iterator begin()
  {
    for (size_type __n = 0; __n < _M_buckets.size(); ++__n)
      if (_M_buckets[__n])
        return iterator(_M_buckets[__n], this);
    return end();
  }

  iterator end() { return iterator(0, this); }

  const_iterator begin() const
  {
    for (size_type __n = 0; __n < _M_buckets.size(); ++__n)
      if (_M_buckets[__n])
        return const_iterator(_M_buckets[__n], this);
    return end();
  }

  const_iterator end() const { return const_iterator(0, this); }

  template <class _Vl, class _Ky, class _HF, class _Ex, class _Eq, class _Al>
  friend bool operator== (const hashtable<_Vl, _Ky, _HF, _Ex, _Eq, _Al>&,
                          const hashtable<_Vl, _Ky, _HF, _Ex, _Eq, _Al>&);
public:

  size_type bucket_count() const { return _M_buckets.size(); }

  size_type max_bucket_count() const
    { return __stl_prime_list[(int)__stl_num_primes - 1]; }

  size_type elems_in_bucket(size_type __bucket) const
  {
    size_type __result = 0;
    for (_Node* __cur = _M_buckets[__bucket]; __cur; __cur = __cur->_M_next)
      __result += 1;
    return __result;
  }

  pair<iterator, bool> insert_unique(const value_type& __obj)
  {
    resize(_M_num_elements + 1);
    return insert_unique_noresize(__obj);
  }

  iterator insert_equal(const value_type& __obj)
  {
    resize(_M_num_elements + 1);
    return insert_equal_noresize(__obj);
  }

  pair<iterator, bool> insert_unique_noresize(const value_type& __obj);
  iterator insert_equal_noresize(const value_type& __obj);

  template <class _InputIterator>
  void insert_unique(_InputIterator __f, _InputIterator __l)
  {
    insert_unique(__f, __l, __iterator_category(__f));
  }

  template <class _InputIterator>
  void insert_equal(_InputIterator __f, _InputIterator __l)
  {
    insert_equal(__f, __l, __iterator_category(__f));
  }

  template <class _InputIterator>
  void insert_unique(_InputIterator __f, _InputIterator __l,
                     input_iterator_tag)
  {
    for ( ; __f != __l; ++__f)
      insert_unique(*__f);
  }

  template <class _InputIterator>
  void insert_equal(_InputIterator __f, _InputIterator __l,
                    input_iterator_tag)
  {
    for ( ; __f != __l; ++__f)
      insert_equal(*__f);
  }

  template <class _ForwardIterator>
  void insert_unique(_ForwardIterator __f, _ForwardIterator __l,
                     forward_iterator_tag)
  {
    size_type __n = distance(__f, __l);
    resize(_M_num_elements + __n);
    for ( ; __n > 0; --__n, ++__f)
      insert_unique_noresize(*__f);
  }

  template <class _ForwardIterator>
  void insert_equal(_ForwardIterator __f, _ForwardIterator __l,
                    forward_iterator_tag)
  {
    size_type __n = distance(__f, __l);
    resize(_M_num_elements + __n);
    for ( ; __n > 0; --__n, ++__f)
      insert_equal_noresize(*__f);
  }

  reference find_or_insert(const value_type& __obj);

  iterator find(const key_type& __key)
  {
    size_type __n = _M_bkt_num_key(__key);
    _Node* __first;
    for ( __first = _M_buckets[__n];
          __first && !_M_equals(_M_get_key(__first->_M_val), __key);
          __first = __first->_M_next)
      {}
    return iterator(__first, this);
  }

  const_iterator find(const key_type& __key) const
  {
    size_type __n = _M_bkt_num_key(__key);
    const _Node* __first;
    for ( __first = _M_buckets[__n];
          __first && !_M_equals(_M_get_key(__first->_M_val), __key);
          __first = __first->_M_next)
      {}
    return const_iterator(__first, this);
  }

  size_type count(const key_type& __key) const
  {
    const size_type __n = _M_bkt_num_key(__key);
    size_type __result = 0;

    for (const _Node* __cur = _M_buckets[__n]; __cur; __cur = __cur->_M_next)
      if (_M_equals(_M_get_key(__cur->_M_val), __key))
        ++__result;
    return __result;
  }

  pair<iterator, iterator>
  equal_range(const key_type& __key);

  pair<const_iterator, const_iterator>
  equal_range(const key_type& __key) const;

  size_type erase(const key_type& __key);
  void erase(const iterator& __it);
  void erase(iterator __first, iterator __last);

  void erase(const const_iterator& __it);
  void erase(const_iterator __first, const_iterator __last);

  void resize(size_type __num_elements_hint);
  void clear();

private:
  size_type _M_next_size(size_type __n) const
    { return __stl_next_prime(__n); }

  void _M_initialize_buckets(size_type __n)
  {
    const size_type __n_buckets = _M_next_size(__n);
    _M_buckets.reserve(__n_buckets);
    _M_buckets.insert(_M_buckets.end(), __n_buckets, (_Node*) 0);
    _M_num_elements = 0;
  }

  size_type _M_bkt_num_key(const key_type& __key) const
  {
    return _M_bkt_num_key(__key, _M_buckets.size());
  }

  size_type _M_bkt_num(const value_type& __obj) const
  {
    return _M_bkt_num_key(_M_get_key(__obj));
  }

  size_type _M_bkt_num_key(const key_type& __key, size_t __n) const
  {
    return _M_hash(__key) % __n;
  }

  size_type _M_bkt_num(const value_type& __obj, size_t __n) const
  {
    return _M_bkt_num_key(_M_get_key(__obj), __n);
  }

  _Node* _M_new_node(const value_type& __obj)
  {
    _Node* __n = _M_get_node();
    __n->_M_next = 0;
    try {
      _Construct(&__n->_M_val, __obj);
      return __n;
    }
    catch(...)
      {
        _M_put_node(__n);
        throw;
      }
  }

  void _M_delete_node(_Node* __n)
  {
    _Destroy(&__n->_M_val);
    _M_put_node(__n);
  }

  void _M_erase_bucket(const size_type __n, _Node* __first, _Node* __last);
  void _M_erase_bucket(const size_type __n, _Node* __last);

  void _M_copy_from(const hashtable& __ht);

};

template <class _Val, class _Key, class _HF, class _ExK, class _EqK,
          class _All>
_Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>&
_Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>::operator++()
{
  const _Node* __old = _M_cur;
  _M_cur = _M_cur->_M_next;
  if (!_M_cur) {
    size_type __bucket = _M_ht->_M_bkt_num(__old->_M_val);
    while (!_M_cur && ++__bucket < _M_ht->_M_buckets.size())
      _M_cur = _M_ht->_M_buckets[__bucket];
  }
  return *this;
}

template <class _Val, class _Key, class _HF, class _ExK, class _EqK,
          class _All>
inline _Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>
_Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>::operator++(int)
{
  iterator __tmp = *this;
  ++*this;
  return __tmp;
}

template <class _Val, class _Key, class _HF, class _ExK, class _EqK,
          class _All>
_Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>&
_Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>::operator++()
{
  const _Node* __old = _M_cur;
  _M_cur = _M_cur->_M_next;
  if (!_M_cur) {
    size_type __bucket = _M_ht->_M_bkt_num(__old->_M_val);
    while (!_M_cur && ++__bucket < _M_ht->_M_buckets.size())
      _M_cur = _M_ht->_M_buckets[__bucket];
  }
  return *this;
}

template <class _Val, class _Key, class _HF, class _ExK, class _EqK,
          class _All>
inline _Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>
_Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>::operator++(int)
{
  const_iterator __tmp = *this;
  ++*this;
  return __tmp;
}

template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
bool operator==(const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht1,
                const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht2)
{
  typedef typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::_Node _Node;
  if (__ht1._M_buckets.size() != __ht2._M_buckets.size())
    return false;
  for (size_t __n = 0; __n < __ht1._M_buckets.size(); ++__n) {
    _Node* __cur1 = __ht1._M_buckets[__n];
    _Node* __cur2 = __ht2._M_buckets[__n];

    for ( ; __cur1 && __cur2;
          __cur1 = __cur1->_M_next, __cur2 = __cur2->_M_next)
      {}
    if (__cur1 || __cur2)
      return false;

    for (__cur1 = __ht1._M_buckets[__n] ; __cur1; __cur1 = __cur1->_M_next)
    {
      bool _found__cur1 = false;
      for (_Node* __cur2 = __ht2._M_buckets[__n];
           __cur2; __cur2 = __cur2->_M_next)
      {
        if (__cur1->_M_val == __cur2->_M_val)
        {
          _found__cur1 = true;
          break;
        }
      }
      if (!_found__cur1)
        return false;
    }
  }
  return true;
}

template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
inline bool operator!=(const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht1,
                       const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht2) {
  return !(__ht1 == __ht2);
}

template <class _Val, class _Key, class _HF, class _Extract, class _EqKey,
          class _All>
inline void swap(hashtable<_Val, _Key, _HF, _Extract, _EqKey, _All>& __ht1,
                 hashtable<_Val, _Key, _HF, _Extract, _EqKey, _All>& __ht2) {
  __ht1.swap(__ht2);
}


template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
pair<typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::iterator, bool>
hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>
  ::insert_unique_noresize(const value_type& __obj)
{
  const size_type __n = _M_bkt_num(__obj);
  _Node* __first = _M_buckets[__n];

  for (_Node* __cur = __first; __cur; __cur = __cur->_M_next)
    if (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj)))
      return pair<iterator, bool>(iterator(__cur, this), false);

  _Node* __tmp = _M_new_node(__obj);
  __tmp->_M_next = __first;
  _M_buckets[__n] = __tmp;
  ++_M_num_elements;
  return pair<iterator, bool>(iterator(__tmp, this), true);
}

template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::iterator
hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>
  ::insert_equal_noresize(const value_type& __obj)
{
  const size_type __n = _M_bkt_num(__obj);
  _Node* __first = _M_buckets[__n];

  for (_Node* __cur = __first; __cur; __cur = __cur->_M_next)
    if (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj))) {
      _Node* __tmp = _M_new_node(__obj);
      __tmp->_M_next = __cur->_M_next;
      __cur->_M_next = __tmp;
      ++_M_num_elements;
      return iterator(__tmp, this);
    }

  _Node* __tmp = _M_new_node(__obj);
  __tmp->_M_next = __first;
  _M_buckets[__n] = __tmp;
  ++_M_num_elements;
  return iterator(__tmp, this);
}

template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::reference
hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::find_or_insert(const value_type& __obj)
{
  resize(_M_num_elements + 1);

  size_type __n = _M_bkt_num(__obj);
  _Node* __first = _M_buckets[__n];

  for (_Node* __cur = __first; __cur; __cur = __cur->_M_next)
    if (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj)))
      return __cur->_M_val;

  _Node* __tmp = _M_new_node(__obj);
  __tmp->_M_next = __first;
  _M_buckets[__n] = __tmp;
  ++_M_num_elements;
  return __tmp->_M_val;
}

template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
pair<typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::iterator,
     typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::iterator>
hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::equal_range(const key_type& __key)
{
  typedef pair<iterator, iterator> _Pii;
  const size_type __n = _M_bkt_num_key(__key);

  for (_Node* __first = _M_buckets[__n]; __first; __first = __first->_M_next)
    if (_M_equals(_M_get_key(__first->_M_val), __key)) {
      for (_Node* __cur = __first->_M_next; __cur; __cur = __cur->_M_next)
        if (!_M_equals(_M_get_key(__cur->_M_val), __key))
          return _Pii(iterator(__first, this), iterator(__cur, this));
      for (size_type __m = __n + 1; __m < _M_buckets.size(); ++__m)
        if (_M_buckets[__m])
          return _Pii(iterator(__first, this),
                     iterator(_M_buckets[__m], this));
      return _Pii(iterator(__first, this), end());
    }
  return _Pii(end(), end());
}

template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
pair<typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::const_iterator,
     typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::const_iterator>
hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>
  ::equal_range(const key_type& __key) const
{
  typedef pair<const_iterator, const_iterator> _Pii;
  const size_type __n = _M_bkt_num_key(__key);

  for (const _Node* __first = _M_buckets[__n] ;
       __first;
       __first = __first->_M_next) {
    if (_M_equals(_M_get_key(__first->_M_val), __key)) {
      for (const _Node* __cur = __first->_M_next;
           __cur;
           __cur = __cur->_M_next)
        if (!_M_equals(_M_get_key(__cur->_M_val), __key))
          return _Pii(const_iterator(__first, this),
                      const_iterator(__cur, this));
      for (size_type __m = __n + 1; __m < _M_buckets.size(); ++__m)
        if (_M_buckets[__m])
          return _Pii(const_iterator(__first, this),
                      const_iterator(_M_buckets[__m], this));
      return _Pii(const_iterator(__first, this), end());
    }
  }
  return _Pii(end(), end());
}

template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::size_type
hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::erase(const key_type& __key)
{
  const size_type __n = _M_bkt_num_key(__key);
  _Node* __first = _M_buckets[__n];
  size_type __erased = 0;

  if (__first) {
    _Node* __cur = __first;
    _Node* __next = __cur->_M_next;
    while (__next) {
      if (_M_equals(_M_get_key(__next->_M_val), __key)) {
        __cur->_M_next = __next->_M_next;
        _M_delete_node(__next);
        __next = __cur->_M_next;
        ++__erased;
        --_M_num_elements;
      }
      else {
        __cur = __next;
        __next = __cur->_M_next;
      }
    }
    if (_M_equals(_M_get_key(__first->_M_val), __key)) {
      _M_buckets[__n] = __first->_M_next;
      _M_delete_node(__first);
      ++__erased;
      --_M_num_elements;
    }
  }
  return __erased;
}

template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::erase(const iterator& __it)
{
  _Node* __p = __it._M_cur;
  if (__p) {
    const size_type __n = _M_bkt_num(__p->_M_val);
    _Node* __cur = _M_buckets[__n];

    if (__cur == __p) {
      _M_buckets[__n] = __cur->_M_next;
      _M_delete_node(__cur);
      --_M_num_elements;
    }
    else {
      _Node* __next = __cur->_M_next;
      while (__next) {
        if (__next == __p) {
          __cur->_M_next = __next->_M_next;
          _M_delete_node(__next);
          --_M_num_elements;
          break;
        }
        else {
          __cur = __next;
          __next = __cur->_M_next;
        }
      }
    }
  }
}

template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>
  ::erase(iterator __first, iterator __last)
{
  size_type __f_bucket = __first._M_cur ?
    _M_bkt_num(__first._M_cur->_M_val) : _M_buckets.size();
  size_type __l_bucket = __last._M_cur ?
    _M_bkt_num(__last._M_cur->_M_val) : _M_buckets.size();

  if (__first._M_cur == __last._M_cur)
    return;
  else if (__f_bucket == __l_bucket)
    _M_erase_bucket(__f_bucket, __first._M_cur, __last._M_cur);
  else {
    _M_erase_bucket(__f_bucket, __first._M_cur, 0);
    for (size_type __n = __f_bucket + 1; __n < __l_bucket; ++__n)
      _M_erase_bucket(__n, 0);
    if (__l_bucket != _M_buckets.size())
      _M_erase_bucket(__l_bucket, __last._M_cur);
  }
}

template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
inline void
hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::erase(const_iterator __first,
                                             const_iterator __last)
{
  erase(iterator(const_cast<_Node*>(__first._M_cur),
                 const_cast<hashtable*>(__first._M_ht)),
        iterator(const_cast<_Node*>(__last._M_cur),
                 const_cast<hashtable*>(__last._M_ht)));
}

template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
inline void
hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::erase(const const_iterator& __it)
{
  erase(iterator(const_cast<_Node*>(__it._M_cur),
                 const_cast<hashtable*>(__it._M_ht)));
}

template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>
  ::resize(size_type __num_elements_hint)
{
  const size_type __old_n = _M_buckets.size();
  if (__num_elements_hint > __old_n) {
    const size_type __n = _M_next_size(__num_elements_hint);
    if (__n > __old_n) {
      vector<_Node*, _All> __tmp(__n, (_Node*)(0),
                                 _M_buckets.get_allocator());
      try {
        for (size_type __bucket = 0; __bucket < __old_n; ++__bucket) {
          _Node* __first = _M_buckets[__bucket];
          while (__first) {
            size_type __new_bucket = _M_bkt_num(__first->_M_val, __n);
            _M_buckets[__bucket] = __first->_M_next;
            __first->_M_next = __tmp[__new_bucket];
            __tmp[__new_bucket] = __first;
            __first = _M_buckets[__bucket];
          }
        }
        _M_buckets.swap(__tmp);
      }
      catch(...) {
        for (size_type __bucket = 0; __bucket < __tmp.size(); ++__bucket) {
          while (__tmp[__bucket]) {
            _Node* __next = __tmp[__bucket]->_M_next;
            _M_delete_node(__tmp[__bucket]);
            __tmp[__bucket] = __next;
          }
        }
        throw;
      }
    }
  }
}

template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>
  ::_M_erase_bucket(const size_type __n, _Node* __first, _Node* __last)
{
  _Node* __cur = _M_buckets[__n];
  if (__cur == __first)
    _M_erase_bucket(__n, __last);
  else {
    _Node* __next;
    for (__next = __cur->_M_next;
         __next != __first;
         __cur = __next, __next = __cur->_M_next)
      ;
    while (__next != __last) {
      __cur->_M_next = __next->_M_next;
      _M_delete_node(__next);
      __next = __cur->_M_next;
      --_M_num_elements;
    }
  }
}

template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>
  ::_M_erase_bucket(const size_type __n, _Node* __last)
{
  _Node* __cur = _M_buckets[__n];
  while (__cur != __last) {
    _Node* __next = __cur->_M_next;
    _M_delete_node(__cur);
    __cur = __next;
    _M_buckets[__n] = __cur;
    --_M_num_elements;
  }
}

template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::clear()
{
  for (size_type __i = 0; __i < _M_buckets.size(); ++__i) {
    _Node* __cur = _M_buckets[__i];
    while (__cur != 0) {
      _Node* __next = __cur->_M_next;
      _M_delete_node(__cur);
      __cur = __next;
    }
    _M_buckets[__i] = 0;
  }
  _M_num_elements = 0;
}


template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>
  ::_M_copy_from(const hashtable& __ht)
{
  _M_buckets.clear();
  _M_buckets.reserve(__ht._M_buckets.size());
  _M_buckets.insert(_M_buckets.end(), __ht._M_buckets.size(), (_Node*) 0);
  try {
    for (size_type __i = 0; __i < __ht._M_buckets.size(); ++__i) {
      const _Node* __cur = __ht._M_buckets[__i];
      if (__cur) {
        _Node* __local_copy = _M_new_node(__cur->_M_val);
        _M_buckets[__i] = __local_copy;

        for (_Node* __next = __cur->_M_next;
             __next;
             __cur = __next, __next = __cur->_M_next) {
          __local_copy->_M_next = _M_new_node(__next->_M_val);
          __local_copy = __local_copy->_M_next;
        }
      }
    }
    _M_num_elements = __ht._M_num_elements;
  }
  catch(...)
    {
      clear();
      throw;
    }
}

}
# 66 "/s/gcc-3.3.1/i386_rh72/include/c++/3.3.1/ext/hash_map" 2 3


namespace __gnu_cxx
{
using std::equal_to;
using std::allocator;
using std::pair;
using std::_Select1st;



template <class _Key, class _Tp,
          class _HashFcn = hash<_Key>,
          class _EqualKey = equal_to<_Key>,
          class _Alloc = allocator<_Tp> >
class hash_map;

template <class _Key, class _Tp, class _HashFn, class _EqKey, class _Alloc>
inline bool operator==(const hash_map<_Key, _Tp, _HashFn, _EqKey, _Alloc>&,
                       const hash_map<_Key, _Tp, _HashFn, _EqKey, _Alloc>&);





template <class _Key, class _Tp, class _HashFcn, class _EqualKey,
          class _Alloc>
class hash_map
{
private:
  typedef hashtable<pair<const _Key,_Tp>,_Key,_HashFcn,
                    _Select1st<pair<const _Key,_Tp> >,_EqualKey,_Alloc> _Ht;
  _Ht _M_ht;

public:
  typedef typename _Ht::key_type key_type;
  typedef _Tp data_type;
  typedef _Tp mapped_type;
  typedef typename _Ht::value_type value_type;
  typedef typename _Ht::hasher hasher;
  typedef typename _Ht::key_equal key_equal;

  typedef typename _Ht::size_type size_type;
  typedef typename _Ht::difference_type difference_type;
  typedef typename _Ht::pointer pointer;
  typedef typename _Ht::const_pointer const_pointer;
  typedef typename _Ht::reference reference;
  typedef typename _Ht::const_reference const_reference;

  typedef typename _Ht::iterator iterator;
  typedef typename _Ht::const_iterator const_iterator;

  typedef typename _Ht::allocator_type allocator_type;

  hasher hash_funct() const { return _M_ht.hash_funct(); }
  key_equal key_eq() const { return _M_ht.key_eq(); }
  allocator_type get_allocator() const { return _M_ht.get_allocator(); }

public:
  hash_map() : _M_ht(100, hasher(), key_equal(), allocator_type()) {}
  explicit hash_map(size_type __n)
    : _M_ht(__n, hasher(), key_equal(), allocator_type()) {}
  hash_map(size_type __n, const hasher& __hf)
    : _M_ht(__n, __hf, key_equal(), allocator_type()) {}
  hash_map(size_type __n, const hasher& __hf, const key_equal& __eql,
           const allocator_type& __a = allocator_type())
    : _M_ht(__n, __hf, __eql, __a) {}

  template <class _InputIterator>
  hash_map(_InputIterator __f, _InputIterator __l)
    : _M_ht(100, hasher(), key_equal(), allocator_type())
    { _M_ht.insert_unique(__f, __l); }
  template <class _InputIterator>
  hash_map(_InputIterator __f, _InputIterator __l, size_type __n)
    : _M_ht(__n, hasher(), key_equal(), allocator_type())
    { _M_ht.insert_unique(__f, __l); }
  template <class _InputIterator>
  hash_map(_InputIterator __f, _InputIterator __l, size_type __n,
           const hasher& __hf)
    : _M_ht(__n, __hf, key_equal(), allocator_type())
    { _M_ht.insert_unique(__f, __l); }
  template <class _InputIterator>
  hash_map(_InputIterator __f, _InputIterator __l, size_type __n,
           const hasher& __hf, const key_equal& __eql,
           const allocator_type& __a = allocator_type())
    : _M_ht(__n, __hf, __eql, __a)
    { _M_ht.insert_unique(__f, __l); }

public:
  size_type size() const { return _M_ht.size(); }
  size_type max_size() const { return _M_ht.max_size(); }
  bool empty() const { return _M_ht.empty(); }
  void swap(hash_map& __hs) { _M_ht.swap(__hs._M_ht); }

  template <class _K1, class _T1, class _HF, class _EqK, class _Al>
  friend bool operator== (const hash_map<_K1, _T1, _HF, _EqK, _Al>&,
                          const hash_map<_K1, _T1, _HF, _EqK, _Al>&);

  iterator begin() { return _M_ht.begin(); }
  iterator end() { return _M_ht.end(); }
  const_iterator begin() const { return _M_ht.begin(); }
  const_iterator end() const { return _M_ht.end(); }

public:
  pair<iterator,bool> insert(const value_type& __obj)
    { return _M_ht.insert_unique(__obj); }
  template <class _InputIterator>
  void insert(_InputIterator __f, _InputIterator __l)
    { _M_ht.insert_unique(__f,__l); }
  pair<iterator,bool> insert_noresize(const value_type& __obj)
    { return _M_ht.insert_unique_noresize(__obj); }

  iterator find(const key_type& __key) { return _M_ht.find(__key); }
  const_iterator find(const key_type& __key) const
    { return _M_ht.find(__key); }

  _Tp& operator[](const key_type& __key) {
    return _M_ht.find_or_insert(value_type(__key, _Tp())).second;
  }

  size_type count(const key_type& __key) const { return _M_ht.count(__key); }

  pair<iterator, iterator> equal_range(const key_type& __key)
    { return _M_ht.equal_range(__key); }
  pair<const_iterator, const_iterator>
  equal_range(const key_type& __key) const
    { return _M_ht.equal_range(__key); }

  size_type erase(const key_type& __key) {return _M_ht.erase(__key); }
  void erase(iterator __it) { _M_ht.erase(__it); }
  void erase(iterator __f, iterator __l) { _M_ht.erase(__f, __l); }
  void clear() { _M_ht.clear(); }

  void resize(size_type __hint) { _M_ht.resize(__hint); }
  size_type bucket_count() const { return _M_ht.bucket_count(); }
  size_type max_bucket_count() const { return _M_ht.max_bucket_count(); }
  size_type elems_in_bucket(size_type __n) const
    { return _M_ht.elems_in_bucket(__n); }
};

template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>
inline bool
operator==(const hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm1,
           const hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm2)
{
  return __hm1._M_ht == __hm2._M_ht;
}

template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>
inline bool
operator!=(const hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm1,
           const hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm2) {
  return !(__hm1 == __hm2);
}

template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>
inline void
swap(hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm1,
     hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm2)
{
  __hm1.swap(__hm2);
}



template <class _Key, class _Tp,
          class _HashFcn = hash<_Key>,
          class _EqualKey = equal_to<_Key>,
          class _Alloc = allocator<_Tp> >
class hash_multimap;

template <class _Key, class _Tp, class _HF, class _EqKey, class _Alloc>
inline bool
operator==(const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm1,
           const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm2);






template <class _Key, class _Tp, class _HashFcn, class _EqualKey, class _Alloc>
class hash_multimap
{

 
 
  ;
  ;

private:
  typedef hashtable<pair<const _Key, _Tp>, _Key, _HashFcn,
                    _Select1st<pair<const _Key, _Tp> >, _EqualKey, _Alloc>
          _Ht;
  _Ht _M_ht;

public:
  typedef typename _Ht::key_type key_type;
  typedef _Tp data_type;
  typedef _Tp mapped_type;
  typedef typename _Ht::value_type value_type;
  typedef typename _Ht::hasher hasher;
  typedef typename _Ht::key_equal key_equal;

  typedef typename _Ht::size_type size_type;
  typedef typename _Ht::difference_type difference_type;
  typedef typename _Ht::pointer pointer;
  typedef typename _Ht::const_pointer const_pointer;
  typedef typename _Ht::reference reference;
  typedef typename _Ht::const_reference const_reference;

  typedef typename _Ht::iterator iterator;
  typedef typename _Ht::const_iterator const_iterator;

  typedef typename _Ht::allocator_type allocator_type;

  hasher hash_funct() const { return _M_ht.hash_funct(); }
  key_equal key_eq() const { return _M_ht.key_eq(); }
  allocator_type get_allocator() const { return _M_ht.get_allocator(); }

public:
  hash_multimap() : _M_ht(100, hasher(), key_equal(), allocator_type()) {}
  explicit hash_multimap(size_type __n)
    : _M_ht(__n, hasher(), key_equal(), allocator_type()) {}
  hash_multimap(size_type __n, const hasher& __hf)
    : _M_ht(__n, __hf, key_equal(), allocator_type()) {}
  hash_multimap(size_type __n, const hasher& __hf, const key_equal& __eql,
                const allocator_type& __a = allocator_type())
    : _M_ht(__n, __hf, __eql, __a) {}

  template <class _InputIterator>
  hash_multimap(_InputIterator __f, _InputIterator __l)
    : _M_ht(100, hasher(), key_equal(), allocator_type())
    { _M_ht.insert_equal(__f, __l); }
  template <class _InputIterator>
  hash_multimap(_InputIterator __f, _InputIterator __l, size_type __n)
    : _M_ht(__n, hasher(), key_equal(), allocator_type())
    { _M_ht.insert_equal(__f, __l); }
  template <class _InputIterator>
  hash_multimap(_InputIterator __f, _InputIterator __l, size_type __n,
                const hasher& __hf)
    : _M_ht(__n, __hf, key_equal(), allocator_type())
    { _M_ht.insert_equal(__f, __l); }
  template <class _InputIterator>
  hash_multimap(_InputIterator __f, _InputIterator __l, size_type __n,
                const hasher& __hf, const key_equal& __eql,
                const allocator_type& __a = allocator_type())
    : _M_ht(__n, __hf, __eql, __a)
    { _M_ht.insert_equal(__f, __l); }

public:
  size_type size() const { return _M_ht.size(); }
  size_type max_size() const { return _M_ht.max_size(); }
  bool empty() const { return _M_ht.empty(); }
  void swap(hash_multimap& __hs) { _M_ht.swap(__hs._M_ht); }

  template <class _K1, class _T1, class _HF, class _EqK, class _Al>
  friend bool operator== (const hash_multimap<_K1, _T1, _HF, _EqK, _Al>&,
                          const hash_multimap<_K1, _T1, _HF, _EqK, _Al>&);

  iterator begin() { return _M_ht.begin(); }
  iterator end() { return _M_ht.end(); }
  const_iterator begin() const { return _M_ht.begin(); }
  const_iterator end() const { return _M_ht.end(); }

public:
  iterator insert(const value_type& __obj)
    { return _M_ht.insert_equal(__obj); }
  template <class _InputIterator>
  void insert(_InputIterator __f, _InputIterator __l)
    { _M_ht.insert_equal(__f,__l); }
  iterator insert_noresize(const value_type& __obj)
    { return _M_ht.insert_equal_noresize(__obj); }

  iterator find(const key_type& __key) { return _M_ht.find(__key); }
  const_iterator find(const key_type& __key) const
    { return _M_ht.find(__key); }

  size_type count(const key_type& __key) const { return _M_ht.count(__key); }

  pair<iterator, iterator> equal_range(const key_type& __key)
    { return _M_ht.equal_range(__key); }
  pair<const_iterator, const_iterator>
  equal_range(const key_type& __key) const
    { return _M_ht.equal_range(__key); }

  size_type erase(const key_type& __key) {return _M_ht.erase(__key); }
  void erase(iterator __it) { _M_ht.erase(__it); }
  void erase(iterator __f, iterator __l) { _M_ht.erase(__f, __l); }
  void clear() { _M_ht.clear(); }

public:
  void resize(size_type __hint) { _M_ht.resize(__hint); }
  size_type bucket_count() const { return _M_ht.bucket_count(); }
  size_type max_bucket_count() const { return _M_ht.max_bucket_count(); }
  size_type elems_in_bucket(size_type __n) const
    { return _M_ht.elems_in_bucket(__n); }
};

template <class _Key, class _Tp, class _HF, class _EqKey, class _Alloc>
inline bool
operator==(const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm1,
           const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm2)
{
  return __hm1._M_ht == __hm2._M_ht;
}

template <class _Key, class _Tp, class _HF, class _EqKey, class _Alloc>
inline bool
operator!=(const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm1,
           const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm2) {
  return !(__hm1 == __hm2);
}

template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>
inline void
swap(hash_multimap<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm1,
     hash_multimap<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm2)
{
  __hm1.swap(__hm2);
}

}

namespace std
{



template <class _Key, class _Tp, class _HashFn, class _EqKey, class _Alloc>
class insert_iterator<__gnu_cxx::hash_map<_Key, _Tp, _HashFn, _EqKey, _Alloc> > {
protected:
  typedef __gnu_cxx::hash_map<_Key, _Tp, _HashFn, _EqKey, _Alloc> _Container;
  _Container* container;
public:
  typedef _Container container_type;
  typedef output_iterator_tag iterator_category;
  typedef void value_type;
  typedef void difference_type;
  typedef void pointer;
  typedef void reference;

  insert_iterator(_Container& __x) : container(&__x) {}
  insert_iterator(_Container& __x, typename _Container::iterator)
    : container(&__x) {}
  insert_iterator<_Container>&
  operator=(const typename _Container::value_type& __value) {
    container->insert(__value);
    return *this;
  }
  insert_iterator<_Container>& operator*() { return *this; }
  insert_iterator<_Container>& operator++() { return *this; }
  insert_iterator<_Container>& operator++(int) { return *this; }
};

template <class _Key, class _Tp, class _HashFn, class _EqKey, class _Alloc>
class insert_iterator<__gnu_cxx::hash_multimap<_Key, _Tp, _HashFn, _EqKey, _Alloc> > {
protected:
  typedef __gnu_cxx::hash_multimap<_Key, _Tp, _HashFn, _EqKey, _Alloc> _Container;
  _Container* container;
  typename _Container::iterator iter;
public:
  typedef _Container container_type;
  typedef output_iterator_tag iterator_category;
  typedef void value_type;
  typedef void difference_type;
  typedef void pointer;
  typedef void reference;

  insert_iterator(_Container& __x) : container(&__x) {}
  insert_iterator(_Container& __x, typename _Container::iterator)
    : container(&__x) {}
  insert_iterator<_Container>&
  operator=(const typename _Container::value_type& __value) {
    container->insert(__value);
    return *this;
  }
  insert_iterator<_Container>& operator*() { return *this; }
  insert_iterator<_Container>& operator++() { return *this; }
  insert_iterator<_Container>& operator++(int) { return *this; }
};

}
# 34 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/common/definitions.h" 2
using namespace __gnu_cxx;
using namespace std;


# 1 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/common/debugio.h" 1
# 13 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/common/debugio.h"
class debugio_t {

public:
        debugio_t ();
        ~debugio_t ();

        static void verbose_info (const uint32 level, const char *fmt, ...);
        static void verbose_log (const uint32 level, const char *fmt, ...);

        static void out_info (const char *fmt, ...);
        static void out_log (const char *fmt, ...);
    static void flush_out();

        static void out_error (const char*fmt, ...);

        static FILE *get_logfp (void);
        static void open_log (const char *filename, bool overwrite);
        static void close_log (void);

private:
        static FILE *logfp;
};
# 39 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/common/definitions.h" 2


class base_counter_t;
class double_counter_t;
class breakdown_counter_t;
class ratio_print_t;
class histo_1d_t;
class st_entry_t;
class st_print_t;
class group_counter_t;
class base_histo_index_t;
class base_histo_t;
class stats_t;
class profiles_t;
class profile_entry_t;
class config_t;


class basic_circuit_t;
class core_power_t;
class cache_power_t;
class power_util_t;


typedef uint64 tick_t;
typedef uint64 addr_t;
# 96 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/common/definitions.h"
struct addr_t_hash_fn : public unary_function <uint64, size_t> {
        size_t operator() (uint64 addr) const { return (addr & 0xffffffff); }
};


# 1 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/processor/proc_defs.h" 1
# 14 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/processor/proc_defs.h"
class iwindow_t;
class dynamic_instr_t;
class mai_t;
class mai_instruction_t;
class sequencer_t;
class chip_t;
class debugio_t;
class fu_t;
class yags_t;
class cascade_t;
class gpc_t;
class bpred_state_t;
class ctrl_flow_t;
class ras_t;
class ras_state_t;
class lsq_t;
class disambig_t;
class fetch_line_entry_t;
class fetch_buffer_t;
class st_buffer_t;
class mem_xaction_t;
class v9_mem_xaction_t;
class wait_list_t;
class mem_hier_handle_t;
class mem_hier_handle_iface_t;
class proc_object_t;
class proc_stats_t;
class fastsim_t;
template <class T> class window_t;

class mmu_t;
class mmu_asi_interface_t;
class mmu_info_t;
typedef struct cmp_mmu_iface cmp_mmu_iface_t;


class mem_hier_interface_t;
class mem_trans_t;
class invalidate_addr_t;

class eventq_t;

class thread_scheduler_t;
class thread_context_t;

class csp_algorithm_t;
class base_algorithm_t;
class tsp_algorithm_t;
class ssp_algorithm_t;
class esp_algorithm_t;
class msp_algoruthm_t;
class bank_algorithm_t;

class spin_heuristic_t;
class disable_timer_t;



enum reg_index_t {
    RS1 = 0,
    RS2 = 4,
    RS_RD = 8,
    RS_CC = 24,
    RD = 25,
    RD_CC = 41,
    RI_NUMBER = 42,
};

const int32 CC = 100;
const int32 SP = 14;
const int32 FP = 30;
const int32 REG_NA = -1;
const int32 CWP_NA = -1;
enum reginfo_index_t {
    RN_RS1,
    RN_RS2,
    RN_RS_RD,
    RN_RD,
    RN_NUMBER
};
const int32 regbox_index[RN_NUMBER] = {RS1, RS2, RS_RD, RD};


const int32 NWINDOW = 8;
const int32 N_GLOBAL = 8;
const int32 N_GPR = 32;
const int32 N_GPR_PER_WINDOW = 16;

const int32 NLOGICAL = (NWINDOW * N_GPR_PER_WINDOW + N_GLOBAL) + 1;
const int32 N_FPR = 64;



enum value_ready_t {
        VR_NO,
        VR_YES,
        VR_SPEC,
        VR_NUMBER,
};


enum fu_type_t {
        FU_NONE = 0,
        FU_INTALU,
        FU_INTMULT,
        FU_INTDIV,
        FU_BRANCH,
        FU_FLOATADD,
        FU_FLOATCMP,
        FU_FLOATCVT,
        FU_FLOATMULT,
        FU_FLOATDIV,
        FU_FLOATSQRT,
        FU_MEMRDPORT,
        FU_MEMWRPORT,
        FU_TYPES
};


enum pipe_stage_t {
        PIPE_NONE,
        PIPE_FETCH,
        PIPE_FETCH_MEM_ACCESS,
        PIPE_INSERT,
        PIPE_PRE_DECODE,
        PIPE_DECODE,
        PIPE_RENAME,
        PIPE_WAIT,
        PIPE_EXECUTE,
        PIPE_EXECUTE_DONE,

        PIPE_MEM_ACCESS,

        PIPE_MEM_ACCESS_SAFE,

        PIPE_MEM_ACCESS_RETRY,

        PIPE_MEM_ACCESS_PROGRESS,

        PIPE_MEM_ACCESS_PROGRESS_S2,

        PIPE_MEM_ACCESS_REEXEC,

        PIPE_COMMIT,
        PIPE_COMMIT_CONTINUE,

        PIPE_EXCEPTION,
        PIPE_SPEC_EXCEPTION,
        PIPE_REPLAY,

        PIPE_ST_BUF_MEM_ACCESS_PROGRESS,
        PIPE_END,
        PIPE_STAGES
};

enum gran_t {
        GRAN_BYTE = 0,
        GRAN_HALF,
        GRAN_WORD,
        GRAN_QUAD,
        GRAN_BLOCK,
        GRAN_GRANS
};


enum instruction_type_t {
        IT_NONE,
        IT_EXECUTE,
        IT_CONTROL,
        IT_LOAD,
        IT_STORE,
        IT_PREFETCH,
        IT_TYPES
};

const uint32 AI_NONE = 0x0;
const uint32 AI_ATOMIC = 0x1;
const uint32 AI_ALT_SPACE = 0x2;
const uint32 AI_PREFETCH = 0x4;

const uint32 PENDING_EVENTQ = 0x1;
const uint32 PENDING_MEM_HIER = 0x2;
const uint32 PENDING_WAIT_LIST = 0x4;


enum branch_type_t {
    BRANCH_NONE,
    BRANCH_UNCOND,
    BRANCH_COND,
    BRANCH_PCOND,
    BRANCH_CALL,
    BRANCH_RETURN,
    BRANCH_INDIRECT,
    BRANCH_CWP,
    BRANCH_TRAP_RETURN,
    BRANCH_TRAP,
    BRANCH_PRIV,
    BRANCH_TYPES
};


enum mai_instr_stage_t {
        INSTR_CREATED,
        INSTR_FETCHED,
        INSTR_DECODED,
        INSTR_EXECUTED,
        INSTR_ST_RETIRED,
        INSTR_COMMITTED,
        INSTR_STAGES
};


enum instr_event_t {
        EVENT_OK,
        EVENT_FAILED,
        EVENT_EXCEPTION,
        EVENT_SPEC_EXCEPTION,
        EVENT_STALL,
        EVENT_SQUASH,
        EVENT_SYNC,
        EVENT_UNRESOLVED_DEP,
        EVENT_UNRESOLVED,
    EVENT_SPECULATIVE,
        EVENT_EVENTS
};


enum sync_type_t {
        SYNC_NONE = 0,
        SYNC_ONE,
        SYNC_TWO,
        SYNC_TYPES
};

enum snoop_status_t {
        SNOOP_NO_CONFLICT,
        SNOOP_BYPASS_COMPLETE,
        SNOOP_BYPASS_EXTND,
        SNOOP_REPLAY,
        SNOOP_UNRESOLVED_ST,
        SNOOP_PRED_SAFE_ST,
        SNOOP_UNSAFE,
        SNOOP_UNKNOWN,
        SNOOP_STATUS
};

enum ts_yield_reason_t {
        YIELD_NONE,
        YIELD_DONE_RETRY,
        YIELD_EXCEPTION,
        YIELD_PAGE_FAULT,
        YIELD_LONG_RUNNING,
        YIELD_MUTEX_LOCKED,
        YIELD_IDLE_ENTER,
        YIELD_SYSCALL_SWITCH,
    YIELD_PAUSED_THREAD_INTERRUPT,
    YIELD_EXTRA_LONG_RUNNING,
    YIELD_PROC_MODE_CHANGE,
    YIELD_DISABLE_CORE,
    YIELD_FUNCTION,
        YIELD_ENTRIES,
};


const uint64 SYS_NUM_SW_INTR = 300;
const uint64 SYS_NUM_HW_INTR = 301;
const uint64 SYS_NUM_PAGE_FAULT = 400;
const uint64 SYS_NUM_OS_SCHED = 500;
const uint64 SYS_UNKNOWN_BOOT = 600;
const uint64 SYS_UNKNOWN_SCHED = 700;
const uint64 SYS_UNKNOWN_INTR = 800;

const addr_t THREAD_STATE_BASE = 0xbeef00000000000ULL;




typedef int64 stick_t;
typedef uint64 tag_t;
typedef uint32 direct_state_t;
typedef uint32 indirect_state_t;

typedef uint64 counter_t;

typedef struct {
        uint64 value;
        bool valid;

        void initialize (uint64 value = 0) {
                value = 0;
                valid = false;
        }

        void set (uint64 _v) {
                value = _v;
                valid = true;
        }

        bool is_valid () {
                return valid;
        }

        uint64 get () {
                ASSERT (valid);
                return value;
        }

        void invalidate () {
                valid = false;
        }

} safe_uint64;
# 102 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/common/definitions.h" 2
# 1 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/mem-hier/mem_hier_defs.h" 1
# 21 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/mem-hier/mem_hier_defs.h"
typedef uint32 size_t;


class mem_hier_t;
class mem_driver_t;


class mem_hier_interface_t;
class proc_interface_t;
class mem_trans_t;
class dynamic_instr_t;
class invalidate_addr_t;


class cache_t;
class cache_bank_t;
class line_t;
template <class prot_t> class tcache_t;
template <class type_t> class mshr_t;
template <class type_t> class mshrs_t;
template <class cache_t> class prefetch_engine_t;
struct cache_config_t;


class link_t;
class device_t;
class message_t;


class generic_proc_t;
template <class prot_t, class msg_t> class proc_t;
template <class prot_t, class msg_t> class main_mem_t;

class interconnect_t;
class mesh_router_t;
class mesh_simple_t;



template <typename action_t, typename state_t,
          class prot_line_t> class transfn_info_t;
template <typename state_t, class prot_line_t> class transfn_return_t;
template <class prot_t> class statemachine_t;


template <class data_type, class context_type> class event_t;
class generic_event_t;
class meventq_t;
class trans_rec_t;
class random_tester_t;


class mem_tracer_t;
class profile_spinlock_t;
class codeshare_t;
class stackheap_t;

class sms_t;


enum stall_status_t {
        StallNone,
        StallSetEvent,
        StallOtherEvent,
        StallPoll,
        StallMax
};

enum mem_return_t {
        MemComplete,
        MemMiss,
        MemStall,
        MemReturnMax
};
# 103 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/common/definitions.h" 2
# 65 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/power/basic_circuit.cc" 2
# 1 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/common/config_extern.h" 1
# 42 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/common/config_extern.h"
# 1 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/common/config_params.h" 1

const string g_conf_compile_time_version = "default_config_testing";

extern int64 g_conf_debug_level;

const int64 g_conf_name_width = 25;
const int64 g_conf_value_width = 20;
const int64 g_conf_desc_width = 50;

# 1 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/processor/proc_params.h" 1


extern int64 g_conf_fu_count [];
extern int64 g_conf_fu_latencies [];

extern int64 g_conf_fetch_stages;
extern int64 g_conf_decode_stages;
extern int64 g_conf_rename_stages;
extern int64 g_conf_commit_stages;
extern int64 g_conf_window_size;
extern int64 g_conf_lsq_load_size;
extern int64 g_conf_lsq_store_size;
extern int64 g_conf_stbuf_size;

extern int64 g_conf_max_fetch;
extern int64 g_conf_max_issue;
extern int64 g_conf_max_commit;

extern bool g_conf_kernel_params;

extern int64 g_conf_yags_choice_bits;
extern int64 g_conf_yags_exception_bits;
extern int64 g_conf_yags_tag_bits;

extern int64 g_conf_cas_filter_bits;
extern int64 g_conf_cas_exception_bits;
extern int64 g_conf_cas_exception_shift;

extern int64 g_conf_max_latency;

extern int64 g_conf_ras_table_bits;

extern int64 g_conf_stats_print_cycles;
extern int64 g_conf_run_cycles;
extern int64 g_conf_run_commits;
extern int64 g_conf_run_user_commits;
extern bool g_conf_overwrite_stats;
extern string g_conf_stats_log;

extern bool g_conf_disable_stbuffer;

extern bool g_conf_initiate_loads_commit;

extern bool g_conf_issue_inorder;

extern bool g_conf_issue_load_commit;
extern bool g_conf_issue_store_commit;

extern bool g_conf_issue_non_spec;
extern bool g_conf_issue_loads_non_spec;
extern bool g_conf_issue_stores_non_spec;

extern bool g_conf_disable_complete_bypass;
extern bool g_conf_disable_extended_bypass;
extern bool g_conf_use_fetch_buffer;
extern int64 g_conf_fetch_buffer_size;

extern int64 g_conf_wait_list_size;
extern bool g_conf_retry;

extern bool g_conf_check_lsq_bypass;
extern bool g_conf_initiate_loads_unresolved;
extern bool g_conf_store_prefetch;

extern bool g_conf_handle_interrupt_early;
extern bool g_conf_kernel_stats;

extern bool g_conf_stall_mem_access;
extern int64 g_conf_stall_mem_access_cycles;

extern int64 g_conf_check_freq;
extern int64 g_conf_eventq_size;


extern int64 g_conf_dead_list_size;
extern int64 g_conf_recycle_list_size;

extern int64 g_conf_trap_levels;
extern bool g_conf_recycle_instr;

extern bool g_conf_use_internal_lsq;

extern bool g_conf_heart_beat;
extern int64 g_conf_heart_beat_cycles;

extern bool g_conf_use_fastsim;
extern int64 g_conf_fastsim_icount;

extern bool g_conf_separate_kbp;

extern bool g_conf_use_mem_hier;
extern bool g_conf_use_processor;

extern bool g_conf_disambig_prediction;
extern int64 g_conf_disambig_size;
extern bool g_conf_prefetch_unresolved;

extern bool g_conf_sync2_runahead;



extern string g_conf_processor_checkpoint_in;
extern string g_conf_processor_checkpoint_out;

extern bool g_conf_use_mmu;
extern bool g_conf_mmu_hw_fill;

extern int64 g_conf_memory_image_size;

extern bool g_conf_trace_commits;
extern bool g_conf_trace_pipe;
extern int64 g_conf_trace_cpu;

extern bool g_conf_line_prefetch;
extern bool g_conf_straight_line_prefetch;
extern int64 g_conf_line_pred_bits;

extern int64 g_conf_extra_seq;

extern bool g_conf_separate_user_os;
extern int64 g_conf_num_user_seq;
extern int64 g_conf_thread_preempt;


extern int64 g_conf_chip_design [];
extern int64 g_conf_spin_loop_pcs [];
extern int64 g_conf_mutex_locked_pc;
extern int64 g_conf_kernel_idle_enter;
extern int64 g_conf_kernel_idle_exit;
extern int64 g_conf_kernel_scheduler_pc;

extern int64 g_conf_syscall_provision [];
extern int64 g_conf_scheduling_algorithm;
extern bool g_conf_cache_only_provision;
extern int64 g_conf_thread_hop_interval;
extern int64 g_conf_syscall_coupling [];

extern bool g_conf_per_syscall_kern_stack;
extern bool g_conf_per_syscall_kern_map;
extern bool g_conf_share_br_pred;

extern bool g_conf_csp_use_mmu;
extern bool g_conf_csp_stop_tick;


extern int64 g_conf_spinloop_threshold;
extern int64 g_conf_spin_check_interval;
extern int64 g_conf_spin_detection_algorithm;
extern bool g_conf_trigger_spin;
extern int64 g_conf_user_spin_factor;
extern bool g_conf_spin_proc_mode;

extern int64 g_conf_store_count_factor;
extern int64 g_conf_load_count_factor;
extern int64 g_conf_adaptive_pc_threshold;

extern bool g_conf_cache_vcpu_state;
extern int64 g_conf_state_size;
extern int64 g_conf_thread_state_offset;
extern int64 g_conf_max_outstanding_thread_state;
extern bool g_conf_optimize_thread_state_addr;
extern int64 g_conf_thread_switch_latency;

extern int64 g_conf_periodic_interrupt;
extern int64 g_conf_long_thread_preempt;
extern bool g_conf_no_os_pause;
extern bool g_conf_safe_trap;


extern int64 g_conf_transaction_leak_interval;
extern bool g_conf_paused_vcpu_interrupt;
extern bool g_conf_software_interrupt_only;
extern int64 g_conf_interrupt_handle_cycle;

extern bool g_conf_observe_kstack;


extern bool g_conf_enable_disable_core;
extern int64 g_conf_disable_interval;
extern int64 g_conf_disable_period;
extern int64 g_conf_disable_event_count;
extern int64 g_conf_disable_interval_stddev;
extern int64 g_conf_disable_interval_mean;


extern int64 g_conf_disable_faulty_cores;


extern bool g_conf_asi_ie_safe;
extern bool g_conf_asi_sec_safe;
extern bool g_conf_asi_blk_safe;
extern bool g_conf_ldd_std_safe;


extern bool g_conf_stat_os_entry_only;
extern bool g_conf_interrupt_core_change;

extern int64 g_conf_num_machines;
extern bool g_conf_override_idsr_read;


extern int64 g_conf_print_commit_stat_trace;
extern int64 g_conf_print_l1miss_stat_trace;
extern int64 g_conf_print_l2miss_stat_trace;
extern int64 g_conf_print_sync_stat_trace;

extern int64 g_conf_l2stripe_threshold;;


extern bool g_conf_avoid_idle_context;
extern bool g_conf_eager_yield;
extern bool g_conf_copy_brpred_state;
extern int64 g_conf_max_ssp_context;



extern int64 g_conf_function_map [];
extern string g_conf_function_file;


extern bool g_conf_operand_width_analysis;
extern bool g_conf_ignore_sllx;
extern bool g_conf_ignore_cmp;



extern int64 g_conf_vary_max_issue [];
extern int64 g_conf_vary_max_fetch [];
extern int64 g_conf_vary_max_commit [];
extern int64 g_conf_vary_issue_inorder [];





extern bool g_conf_power_profile;
extern int64 g_conf_opcode_length;
extern int64 g_conf_inst_length;
extern int64 g_conf_data_width;
extern int64 g_conf_addr_width;
# 11 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/common/config_params.h" 2
# 1 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/mem-hier/mem_hier_params.h" 1


extern string g_conf_memory_topology;


extern int64 g_conf_l1d_latency;
extern int64 g_conf_l1d_assoc;
extern int64 g_conf_l1d_size;
extern int64 g_conf_l1d_banks;
extern int64 g_conf_l1d_bank_bw_inv;
extern int64 g_conf_l1d_req_q_size;
extern int64 g_conf_l1d_lsize;
extern int64 g_conf_l1d_num_mshrs;
extern int64 g_conf_l1d_requests_per_mshr;
extern int64 g_conf_l1d_writeback_buffers;;

extern int64 g_conf_l1i_latency;
extern int64 g_conf_l1i_assoc;
extern int64 g_conf_l1i_size;
extern int64 g_conf_l1i_banks;
extern int64 g_conf_l1i_bank_bw_inv;
extern int64 g_conf_l1i_req_q_size;
extern int64 g_conf_l1i_lsize;
extern int64 g_conf_l1i_num_mshrs;
extern int64 g_conf_l1i_requests_per_mshr;
extern bool g_conf_l1i_next_line_prefetch;
extern int64 g_conf_l1i_next_line_pref_num;

extern int64 g_conf_l2_latency;
extern int64 g_conf_l2_assoc;
extern int64 g_conf_l2_size;
extern int64 g_conf_l2_banks;
extern int64 g_conf_l2_bank_bw_inv;
extern int64 g_conf_l2_req_q_size;
extern int64 g_conf_l2_lsize;
extern int64 g_conf_l2_num_mshrs;
extern int64 g_conf_l2_requests_per_mshr;
extern int64 g_conf_l2_writeback_buffers;;

extern int64 g_conf_l3_latency;
extern int64 g_conf_l3_assoc;
extern int64 g_conf_l3_size;
extern int64 g_conf_l3_banks;
extern int64 g_conf_l3_bank_bw_inv;
extern int64 g_conf_l3_req_q_size;
extern int64 g_conf_l3_lsize;
extern int64 g_conf_l3_num_mshrs;
extern int64 g_conf_l3_requests_per_mshr;
extern int64 g_conf_l3_writeback_buffers;;
extern bool g_conf_l3_stride_prefetch;

extern int64 g_conf_l1dir_latency;

extern int64 g_conf_main_mem_latency;
extern int64 g_conf_main_mem_bandwidth;


extern int64 g_conf_default_link_latency;
extern int64 g_conf_default_messages_per_link;

extern int64 g_conf_num_addr_bus;
extern int64 g_conf_num_data_bus;


extern bool g_conf_cache_data;
extern bool g_conf_break_data_mismatch;;


extern bool g_conf_cache_io_space;

extern bool g_conf_handle_io_devices;

extern bool g_conf_handle_iodev_reads;

extern bool g_conf_single_trans_atomics;

extern bool g_conf_ignore_uncacheable;


extern bool g_conf_delay_zero_latency;

extern bool g_conf_copy_transaction;

extern bool g_conf_randomize_mm;
extern int64 g_conf_random_mm_dist;
extern int64 g_conf_random_seed;

extern bool g_conf_shadow_timing;


extern int64 g_conf_mem_hier_warmup;
extern bool g_conf_fetch_profile;
extern bool g_conf_watch_idle_loop;
extern int64 g_conf_idle_min_pc;
extern int64 g_conf_idle_max_pc;


extern bool g_conf_mem_hier_response_tracking;
extern int64 g_conf_mem_hier_response_threshold;
extern int64 g_conf_mem_hier_check_frequency;


extern int64 g_conf_stats_print_cycle;
extern int64 g_conf_quiesce_delta;
extern int64 g_conf_max_classname_len;
extern bool g_conf_print_transition_stats;

extern bool g_conf_profile_mem_addresses;
extern int64 g_conf_prof_ma_granularity_bits;
extern int64 g_conf_prof_mostly_kernel_ratio;
extern int64 g_conf_prof_mostly_user_ratio;
extern bool g_conf_prof_ma_ignore_ifetch;
extern bool g_conf_prof_ma_ignore_stores;
extern bool g_conf_prof_ma_regwin_as_user;
extern bool g_conf_prof_ma_print_addresses;

extern bool g_conf_profile_spin_locks;
extern bool g_conf_prof_sl_print_each_lock;
extern bool g_conf_profile_codeshare;


extern string g_conf_mem_hier_checkpoint_in;
extern string g_conf_mem_hier_checkpoint_out;
extern string g_conf_workload_checkpoint;

extern int64 g_conf_warmup_transactions;
extern int64 g_conf_random_addresses;
extern int64 g_conf_random_transaction_traffic;
extern int64 g_conf_random_transaction_frequency;


extern bool g_conf_cmp_incl_l2_read_fwd;;
extern int64 g_conf_cmp_interconnect_latency;
extern int64 g_conf_cmp_interconnect_bw_addr;
extern int64 g_conf_cmp_interconnect_bw_data;
extern int64 g_conf_cmp_interconnect_topo;


extern int64 g_conf_mem_trans_count;
extern int64 g_conf_warmup_l1_size;
extern int64 g_conf_warmup_l2_size;
extern int64 g_conf_warmup_l3_size;


extern bool g_conf_icache_inclusion;

extern bool g_conf_perfect_icache;;
extern bool g_conf_perfect_dcache;;
extern bool g_conf_perfect_store_access;;
extern bool g_conf_no_c2c_latency;;
extern bool g_conf_mem_ignore_os;;
extern bool g_conf_mem_ignore_user;;

extern bool g_conf_keep_thread_state;;
extern bool g_conf_tstate_l1_bypass;
extern bool g_conf_sep_kern_cache;;
extern bool g_conf_optimize_os_user_spills;;
extern bool g_conf_optimize_os_lwp;;


extern int64 g_conf_sms_region_bits;

extern bool g_conf_stackheap_profile;
extern bool g_conf_optimize_stack_write;
# 12 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/common/config_params.h" 2
# 43 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/common/config_extern.h" 2
# 66 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/power/basic_circuit.cc" 2
# 1 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/common/profiles.h" 1
# 24 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/common/profiles.h"
class profile_entry_t {
        protected:

        string name;
        string desc;
        stats_t *stats;

        public:
        profile_entry_t(string name);
        bool name_as(const string &n);
        string get_name();
    const char *get_cname();

        virtual void print_stats();
        virtual ~profile_entry_t();

        void clear_stats();

    virtual void to_file(FILE *f) {};
    virtual void from_file(FILE *f) {};



};

class profiles_list_entry_t {
public:
        profile_entry_t * entry;
        profiles_list_entry_t * next;

        profiles_list_entry_t ();
        profiles_list_entry_t (profile_entry_t * ent);

        void print_stats();
        void clear_stats();
};



class profiles_t {
protected:
        string name;
        uint32 num;
        profiles_list_entry_t * list, * tail;

public:
        profiles_t ();

        profiles_t (const string &n);


        ~profiles_t ();


        bool check_name (const string &name);


        profile_entry_t * enqueue (profile_entry_t * ent);





        void print ();


        void clear();
    void to_file(FILE *f);
    void from_file(FILE *f);

};
# 67 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/power/basic_circuit.cc" 2
# 1 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/power/power_def.h" 1
# 32 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/power/power_def.h"
class sparc_regfile_t;
# 414 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/power/power_def.h"
typedef struct {
   int tech;
   int iw;
   int winsize;
   int nvreg;
   int npreg;
   int nvreg_width;
   int npreg_width;
   int data_width;
} parameter_type;

class core_power_result_type {

    public:
        double btb;
        double local_predict;
        double global_predict;
        double chooser;
        double ras;
        double rat_driver;
        double rat_decoder;
        double rat_wordline;
        double rat_bitline;
        double rat_senseamp;
        double dcl_compare;
        double dcl_pencode;
        double inst_decoder_power;
        double wakeup_tagdrive;
        double wakeup_tagmatch;
        double wakeup_ormatch;
        double lsq_wakeup_tagdrive;
        double lsq_wakeup_tagmatch;
        double lsq_wakeup_ormatch;
        double selection;
        double reorder_driver;
        double reorder_decoder;
        double reorder_wordline;
        double reorder_bitline;
        double reorder_senseamp;
        double rs_driver;
        double rs_decoder;
        double rs_wordline;
        double rs_bitline;
        double rs_senseamp;
        double lsq_rs_driver;
        double lsq_rs_decoder;
        double lsq_rs_wordline;
        double lsq_rs_bitline;
        double lsq_rs_senseamp;
        double resultbus;


        double total_power;
        double ialu_power;
        double falu_power;
        double bpred_power;
        double rename_power;
        double rat_power;
        double dcl_power;
        double window_power;
        double lsq_power;
        double wakeup_power;
        double lsq_wakeup_power;
        double rs_power;
        double rs_power_nobit;
        double lsq_rs_power;
        double lsq_rs_power_nobit;
        double selection_power;
        double result_power;

        double itlb_power;
        double dtlb_power;

        double clock_power;

};

class cache_power_result_type {
    public:

        double decoder;
        double wordline;
        double bitline;
        double senseamp;
        double tagarray;

        double tlb;
};




class time_parameter_type {
    public:
        int cache_size;
        int number_of_sets;
        int associativity;
        int block_size;
};

class time_result_type {
    public:

        double access_time,cycle_time;
        int best_Ndwl,best_Ndbl;
        int best_Nspd;
        int best_Ntwl,best_Ntbl;
        int best_Ntspd;
        double decoder_delay_data,decoder_delay_tag;
        double dec_data_driver,dec_data_3to8,dec_data_inv;
        double dec_tag_driver,dec_tag_3to8,dec_tag_inv;
        double wordline_delay_data,wordline_delay_tag;
        double bitline_delay_data,bitline_delay_tag;
        double sense_amp_delay_data,sense_amp_delay_tag;
        double senseext_driver_delay_data;
        double compare_part_delay;
        double drive_mux_delay;
        double selb_delay;
        double data_output_delay;
        double drive_valid_delay;
        double precharge_delay;

} ;
# 68 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/power/basic_circuit.cc" 2
# 1 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/power/basic_circuit.h" 1
# 63 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/power/basic_circuit.h"
class basic_circuit_t {
    public:

        basic_circuit_t();
        int powers (int base, int n);
        double logtwo (double x);
        double gatecap (double width,double wirelength);
        double gatecappass (double width,double wirelength);
        double draincap (double width,int nchannel,int stack);
        double transresswitch (double width,int nchannel,int stack);
        double transreson (double width,int nchannel,int stack);
        double restowidth (double res,int nchannel);
        double horowitz (double inputramptime,double tf,double vs1,
            double vs2,int rise);
        inline double pow2 (double _s) { return _s * _s;}
};
# 69 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/power/basic_circuit.cc" 2

basic_circuit_t::basic_circuit_t()
{

}

int basic_circuit_t::powers (int base, int n)
{
    int i, p;

    p = 1;
    for (i = 1; i <= n; ++i)
        p *= base;
    return p;
}


double basic_circuit_t::logtwo (double x)
{
    if (x <= 0)
        printf ("%e\n", x);
    return ((double) (log (x) / log (2.0)));
}





double basic_circuit_t::gatecap (double width,double wirelength)
{
    return (width * (0.8 * 0.4375) * 1.95e-15 + wirelength * (0.25e-15 * (5.2197) * 0.4375) * (0.8 * 0.4375));
}

double basic_circuit_t::gatecappass (double width,double wirelength)
{
    return (width * (0.8 * 0.4375) * 1.45e-15 + wirelength * (0.25e-15 * (5.2197) * 0.4375) * (0.8 * 0.4375));
}
# 119 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/power/basic_circuit.cc"
double basic_circuit_t::draincap (double width,int nchannel,int stack)
{
    double Cdiffside, Cdiffarea, Coverlap, cap;

    Cdiffside = (nchannel) ? 0.275e-15 : 0.275e-15;
    Cdiffarea = (nchannel) ? 0.137e-15 : 0.343e-15;
    Coverlap = (nchannel) ? (0.138e-15 + 0.263e-15) :
    (0.138e-15 + 0.338e-15);


    if(stack > 1) {
        if (width >= 10/1.0) {
            cap = 3.0 * (0.8 * 0.4375) * width / 2.0 * Cdiffarea + 6.0 * (0.8 * 0.4375) * Cdiffside +
            width * Coverlap;
            cap += (double) (stack - 1) * ((0.8 * 0.4375) * width * Cdiffarea +
                4.0 * (0.8 * 0.4375) * Cdiffside +
                2.0 * width * Coverlap);
        }
        else {
            cap =
            3.0 * (0.8 * 0.4375) * width * Cdiffarea + (6.0 * (0.8 * 0.4375) + width) * Cdiffside +
            width * Coverlap;
            cap +=
            (double) (stack - 1) * ((0.8 * 0.4375) * width * Cdiffarea +
                2.0 * (0.8 * 0.4375) * Cdiffside +
                2.0 * width * Coverlap);
        }
    }
    else {
        if (width >= 10/1.0) {
            cap = 3.0 * (0.8 * 0.4375) * width / 2.0 * Cdiffarea + 6.0 * (0.8 * 0.4375) * Cdiffside +
            width * Coverlap;
        }
        else {
            cap = 3.0 * (0.8 * 0.4375) * width * Cdiffarea + (6.0 * (0.8 * 0.4375) + width) * Cdiffside +
            width * Coverlap;
        }
    }
    return (cap);
}
# 173 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/power/basic_circuit.cc"
double basic_circuit_t::transresswitch (double width,int nchannel,int stack)
{
  double restrans;
  restrans = (nchannel) ? ((25800 * 0.4375)) : ((61200 * 0.4375));


  return ((1.0 + ((stack - 1.0) * 0.8)) * restrans / width);
}
# 189 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/power/basic_circuit.cc"
double basic_circuit_t::transreson (double width,int nchannel,int stack)
{
    double restrans;
    restrans = (nchannel) ? (9723 * 0.4375) : (22400 * 0.4375);



    return (stack * restrans / width);

}
# 209 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/power/basic_circuit.cc"
double basic_circuit_t::restowidth (double res,int nchannel)
{
    double restrans;

    restrans = (nchannel) ? (9723 * 0.4375) : (22400 * 0.4375);

    return (restrans / res);

}
# 226 "/u/k/c/kchak/rs1/comp_spread/src/mscalar/ms2sim_smt/power/basic_circuit.cc"
double basic_circuit_t::horowitz (double inputramptime,double tf,double vs1,double vs2,int rise)

{
    double a, b, td;

    a = inputramptime / tf;
    if (rise == 1)
    {
        b = 0.5;
        td = tf * sqrt (log (vs1) * log (vs1) + 2 * a * b * (1.0 - vs1)) +
        tf * (log (vs1) - log (vs2));
    }
    else
    {
        b = 0.4;
        td = tf * sqrt (log (1.0 - vs1) * log (1.0 - vs1) + 2 * a * b * (vs1)) +
        tf * (log (1.0 - vs1) - log (1.0 - vs2));
    }
    return (td);
}
